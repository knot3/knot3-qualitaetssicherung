\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper,left=20mm,right=20mm,top=20mm,bottom=20mm]{geometry}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage[pdftex]{color}
\usepackage{colortbl}
\definecolor{green}{rgb}{0,1,0.12}
\definecolor{red}{rgb}{1,0,0}
\definecolor{gray}{rgb}{0.86,0.86,0.86}

\usepackage[pdftex,
            colorlinks=true, linkcolor=red, urlcolor=green, citecolor=red,%
            raiselinks=true,%
            bookmarks=true,%
            bookmarksopenlevel=1,%
            bookmarksopen=true,%
            bookmarksnumbered=true,%
            hyperindex=true,% 
            plainpages=false,% correct hyperlinks
            pdfpagelabels=true%,% view TeX pagenumber in PDF reader
            %pdfborder={0 0 0.5}
            ]{hyperref}

\hypersetup{pdftitle={Coverage Report},
            pdfauthor={ReportGenerator - 1.9.1.0}
           }

\pagestyle{fancy}
\fancyhead[LE,LO]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{ReportGenerator - 1.9.1.0}

\begin{document}

\setcounter{secnumdepth}{-1}
\section{Summary}
\begin{longtable}[l]{ll}
\textbf{Generated on:} & 17.02.2014 - 21:47:38\\
\textbf{Parser:} & OpenCoverParser\\
\textbf{Assemblies:} & 1\\
\textbf{Classes:} & 50\\
\textbf{Files:} & 49\\
\textbf{Coverage:} & 43.2\%\\
\textbf{Covered lines:} & 1423\\
\textbf{Uncovered lines:} & 1866\\
\textbf{Coverable lines:} & 3289\\
\textbf{Total lines:} & 9770\\
\end{longtable}
\section{Assemblies}
\begin{longtable}[l]{ll}
\textbf{Knot3} & \textbf{43.2\%}\\
Knot3.Audio.AudioManager & 42.8\%\\
Knot3.Audio.LoopPlaylist & 0\%\\
Knot3.Audio.OggVorbisFile & 0\%\\
Knot3.Audio.SoundEffectFile & 0\%\\
Knot3.Core.Angles3 & 100\%\\
Knot3.Core.BooleanOptionInfo & 0\%\\
Knot3.Core.Camera & 61.9\%\\
Knot3.Core.ConfigFile & 100\%\\
Knot3.Core.DisplayLayer & 98.3\%\\
Knot3.Core.DistinctOptionInfo & 0\%\\
Knot3.Core.DrawableGameScreenComponent & 84.6\%\\
Knot3.Core.FloatOptionInfo & 0\%\\
Knot3.Core.GameScreenComponent & 77.7\%\\
Knot3.Core.KeyOptionInfo & 0\%\\
Knot3.Core.Localizer & 0\%\\
Knot3.Core.OptionInfo & 0\%\\
Knot3.Core.Options & 81.2\%\\
Knot3.Core.World & 13.5\%\\
Knot3.Data.Challenge & 0\%\\
Knot3.Data.ChallengeFileIO & 0\%\\
Knot3.Data.ChallengeMetaData & 0\%\\
Knot3.Data.CircleEntry`1 & 92.1\%\\
Knot3.Data.CircleExtensions & 100\%\\
Knot3.Data.Direction & 98.7\%\\
Knot3.Data.DirectionHelper & 0\%\\
Knot3.Data.Edge & 95.3\%\\
Knot3.Data.Knot & 84.9\%\\
Knot3.Data.KnotFileIO & 20.5\%\\
Knot3.Data.KnotMetaData & 60.3\%\\
Knot3.Data.KnotStringIO & 40.1\%\\
Knot3.Data.Node & 76.1\%\\
Knot3.Data.NodeMap & 88.5\%\\
Knot3.Data.PrinterIO & 0\%\\
Knot3.Data.RectangleMap & 0\%\\
Knot3.Data.ZipHelper & 0\%\\
Knot3.Platform.SystemInfo & 88.6\%\\
Knot3.Utilities.BoundingCylinder & 0\%\\
Knot3.Utilities.ColorHelper & 0\%\\
Knot3.Utilities.DictionaryHelper & 100\%\\
Knot3.Utilities.EnumHelper & 14.2\%\\
Knot3.Utilities.FileIndex & 0\%\\
Knot3.Utilities.FileUtility & 36.1\%\\
Knot3.Utilities.FrustumHelper & 0\%\\
Knot3.Utilities.IniFile & 81.1\%\\
Knot3.Utilities.InputHelper & 0\%\\
Knot3.Utilities.RayExtensions & 0\%\\
Knot3.Utilities.SavegameLoader`2 & 0\%\\
Knot3.Utilities.TextHelper & 0\%\\
Knot3.Utilities.TextureHelper & 0\%\\
Knot3.Utilities.VectorHelper & 21.3\%\\
\end{longtable}
\newpage
\section{Knot3.Audio.AudioManager}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Audio.AudioManager\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash AudioManager.cs}\end{minipage} \\
\textbf{Coverage:} & 42.8\%\\
\textbf{Covered lines:} & 48\\
\textbf{Uncovered lines:} & 64\\
\textbf{Coverable lines:} & 112\\
\textbf{Total lines:} & 245\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 4 & 100 & 71.43\\
\hline
\textbf{Reset()} & 1 & 100 & 100\\
\hline
\textbf{AddXnaAudioFile(...)} & 3 & 0 & 0\\
\hline
\textbf{LoadXnaSoundEffect(.} & 1 & 0 & 0\\
\hline
\textbf{AddOggAudioFile(...)} & 3 & 100 & 80\\
\hline
\textbf{LoadOggAudioFile(...} & 1 & 90.91 & 100\\
\hline
\textbf{StartBackgroundMusic} & 2 & 0 & 0\\
\hline
\textbf{PlaySound(...)} & 2 & 0 & 0\\
\hline
\textbf{Update(...)} & 2 & 0 & 0\\
\hline
\textbf{UnloadContent()} & 1 & 0 & 0\\
\hline
\textbf{Volume(...)} & 1 & 0 & 0\\
\hline
\textbf{SetVolume(...)} & 1 & 100 & 100\\
\hline
\textbf{ValidVolume(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash AudioManager.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~57~ & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & \verb~namespace Knot3.Audio~\\
\cellcolor{gray} &  & \verb~59~ & \verb~{~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public class AudioManager : DrawableGameScreenComponent~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Eine Zuordnung zwischen dem Typ der Audiodateien und den Ordnern unter~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// in denen sich die Audiodateien befinden.~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~    private static readonly Dictionary<Sound, string> AudioDirectories~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    = new Dictionary<Sound, string> {~\\
\cellcolor{gray} &  & \verb~68~ & \verb~      { Sound.CreativeMusic,      "Music/Creative" },~\\
\cellcolor{gray} &  & \verb~69~ & \verb~      { Sound.ChallengeMusic,      "Music/Challenge" },~\\
\cellcolor{gray} &  & \verb~70~ & \verb~      { Sound.MenuMusic,        "Music/Menu" },~\\
\cellcolor{gray} &  & \verb~71~ & \verb~      { Sound.PipeMoveSound,      "Sound/Pipe/Move" },~\\
\cellcolor{gray} &  & \verb~72~ & \verb~      { Sound.PipeInvalidMoveSound,  "Sound/Pipe/Invalid-Move" },~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    };~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    // Enthält alle gefunden Audiodateien, sortiert nach ihrem Zweck~\\
\cellcolor{green} & 1 & \verb~76~ & \verb~    private static Dictionary<Sound, HashSet<IAudioFile>> AudioFiles~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        = new Dictionary<Sound, HashSet<IAudioFile>> ();~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// Die aktuell verwendete Hintergrundmusik.~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    public Sound BackgroundMusic~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~        return _backgroundMusic;~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~        if (value != Sound.None && value != _backgroundMusic) {~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~          _backgroundMusic = value;~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~          StartBackgroundMusic ();~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{green} & 1 & \verb~95~ & \verb~    private static Sound _backgroundMusic = Sound.None;~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// Enthält die Playlist, die aktuell abgespielt wird,~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// oder null, falls keine Playlist abgespielt wird.~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    public static IPlaylist Playlist { get; set; }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{green} & 1 & \verb~103~ & \verb~    private static Dictionary<Sound, float> VolumeMap = new Dictionary<Sound, ~\\
\cellcolor{gray} &  & \verb~104~ & \verb~~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    /// Erstellt einen neuen AudioManager für den angegebenen Spielzustand.~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    /// </summary>~\\
\cellcolor{green} & 3 & \verb~108~ & \verb~    public AudioManager (IGameScreen screen, string directory = ".")~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    : base (screen, DisplayLayer.None)~\\
\cellcolor{green} & 3 & \verb~110~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~111~ & \verb~      if (AudioFiles.Count == 0) {~\\
\cellcolor{gray} &  & \verb~112~ & \verb~        // Erstelle für alle Enum-Werte von Sound ein HashSet~\\
\cellcolor{green} & 63 & \verb~113~ & \verb~        foreach (Sound soundType in typeof (Sound).ToEnumValues<Sound>()) {~\\
\cellcolor{green} & 18 & \verb~114~ & \verb~          AudioFiles [soundType] = new HashSet<IAudioFile> ();~\\
\cellcolor{green} & 18 & \verb~115~ & \verb~          VolumeMap [soundType] = ValidVolume (Options.Default ["volume", soun~\\
\cellcolor{green} & 18 & \verb~116~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        // Suche nach XNA-Audio-Dateien~\\
\cellcolor{green} & 3 & \verb~119~ & \verb~        FileUtility.SearchFiles (directory, new string[] {".xnb"}, AddXnaAudio~\\
\cellcolor{gray} &  & \verb~120~ & \verb~~\\
\cellcolor{gray} &  & \verb~121~ & \verb~        // Suche nach OGG-Dateien~\\
\cellcolor{green} & 3 & \verb~122~ & \verb~        FileUtility.SearchFiles (directory, new string[] {".ogg"}, AddOggAudio~\\
\cellcolor{green} & 3 & \verb~123~ & \verb~      }~\\
\cellcolor{green} & 3 & \verb~124~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~125~ & \verb~~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    public static void Reset ()~\\
\cellcolor{green} & 3 & \verb~127~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~128~ & \verb~      AudioFiles.Clear ();~\\
\cellcolor{green} & 3 & \verb~129~ & \verb~      VolumeMap.Clear ();~\\
\cellcolor{green} & 3 & \verb~130~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{gray} &  & \verb~132~ & \verb~    private void AddXnaAudioFile (string filepath)~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~      filepath = filepath.Replace (".xnb", String.Empty).Replace (@"Content\",~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~      foreach (KeyValuePair<Sound,string> pair in AudioDirectories) {~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~        Sound soundType = pair.Key;~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~        string directory = pair.Value;~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~        if (filepath.ToLower ().Contains (directory.ToLower ())) {~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~          string name = Path.GetFileName (filepath);~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~          LoadXnaSoundEffect (filepath, name, soundType);~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~          break;~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~    private void LoadXnaSoundEffect (string filepath, string name, Sound sound~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~      try {~\\
\cellcolor{gray} &  & \verb~150~ & \verb~        // versuche, die Audiodatei als "SoundEffect" zu laden~\\
\cellcolor{red} & 0 & \verb~151~ & \verb~        SoundEffect soundEffect = Screen.Content.Load<SoundEffect> (filepath);~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~        AudioFiles [soundType].Add (new SoundEffectFile (name, soundEffect, so~\\
\cellcolor{red} & 0 & \verb~153~ & \verb~        Log.Debug ("Load sound effect (", soundType, "): ", filepath);~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~155~ & \verb~      catch (Exception ex) {~\\
\cellcolor{red} & 0 & \verb~156~ & \verb~        Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~158~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~    private void AddOggAudioFile (string filepath)~\\
\cellcolor{green} & 6 & \verb~161~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~162~ & \verb~      filepath = filepath.Replace (@"\", "/");~\\
\cellcolor{gray} &  & \verb~163~ & \verb~~\\
\cellcolor{green} & 57 & \verb~164~ & \verb~      foreach (KeyValuePair<Sound,string> pair in AudioDirectories) {~\\
\cellcolor{green} & 15 & \verb~165~ & \verb~        Sound soundType = pair.Key;~\\
\cellcolor{green} & 15 & \verb~166~ & \verb~        string directory = pair.Value;~\\
\cellcolor{green} & 21 & \verb~167~ & \verb~        if (filepath.ToLower ().Contains (directory.ToLower ())) {~\\
\cellcolor{green} & 6 & \verb~168~ & \verb~          string name = Path.GetFileName (filepath);~\\
\cellcolor{green} & 6 & \verb~169~ & \verb~          LoadOggAudioFile (filepath, name, soundType);~\\
\cellcolor{green} & 6 & \verb~170~ & \verb~          break;~\\
\cellcolor{gray} &  & \verb~171~ & \verb~        }~\\
\cellcolor{green} & 9 & \verb~172~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~173~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~174~ & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & \verb~    private void LoadOggAudioFile (string filepath, string name, Sound soundTy~\\
\cellcolor{green} & 6 & \verb~176~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~177~ & \verb~      try {~\\
\cellcolor{gray} &  & \verb~178~ & \verb~        // erstelle ein AudioFile-Objekt~\\
\cellcolor{green} & 6 & \verb~179~ & \verb~        Log.Debug ("Load ogg audio file (", soundType, "): ", filepath);~\\
\cellcolor{green} & 6 & \verb~180~ & \verb~        AudioFiles [soundType].Add (new OggVorbisFile (name, filepath, soundTy~\\
\cellcolor{red} & 0 & \verb~181~ & \verb~      }~\\
\cellcolor{green} & 12 & \verb~182~ & \verb~      catch (Exception ex) {~\\
\cellcolor{gray} &  & \verb~183~ & \verb~        // egal, warum das laden nicht klappt; mehr als die Fehlermeldung anze~\\
\cellcolor{gray} &  & \verb~184~ & \verb~        // macht wegen einer fehlenden Musikdatei keinen Sinn~\\
\cellcolor{green} & 6 & \verb~185~ & \verb~        Log.Debug ("Failed to load ffmpeg audio file (", soundType, "): ", fil~\\
\cellcolor{green} & 6 & \verb~186~ & \verb~        Log.Debug (ex);~\\
\cellcolor{green} & 6 & \verb~187~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~188~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~189~ & \verb~~\\
\cellcolor{gray} &  & \verb~190~ & \verb~    private void StartBackgroundMusic ()~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~192~ & \verb~      if (Playlist != null) {~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~        Playlist.Stop ();~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~      Log.Debug ("Background Music: ", BackgroundMusic);~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~      Playlist = new LoopPlaylist (AudioFiles [BackgroundMusic]);~\\
\cellcolor{red} & 0 & \verb~197~ & \verb~      Playlist.Shuffle ();~\\
\cellcolor{red} & 0 & \verb~198~ & \verb~      Playlist.Start ();~\\
\cellcolor{red} & 0 & \verb~199~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~200~ & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & \verb~    public void PlaySound (Sound sound)~\\
\cellcolor{red} & 0 & \verb~202~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~203~ & \verb~      Log.Debug ("Sound: ", sound);~\\
\cellcolor{red} & 0 & \verb~204~ & \verb~      if (AudioFiles [sound].Count > 0) {~\\
\cellcolor{red} & 0 & \verb~205~ & \verb~        AudioFiles [sound].RandomElement ().Play ();~\\
\cellcolor{red} & 0 & \verb~206~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~207~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~208~ & \verb~        Log.Debug ("There are no audio files for: ", sound);~\\
\cellcolor{red} & 0 & \verb~209~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~~\\
\cellcolor{gray} &  & \verb~212~ & \verb~    public override void Update (GameTime time)~\\
\cellcolor{red} & 0 & \verb~213~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~214~ & \verb~      if (Playlist != null) {~\\
\cellcolor{red} & 0 & \verb~215~ & \verb~        Playlist.Update (time);~\\
\cellcolor{red} & 0 & \verb~216~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~217~ & \verb~      base.Update (time);~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~219~ & \verb~~\\
\cellcolor{gray} &  & \verb~220~ & \verb~    protected override void UnloadContent ()~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~222~ & \verb~      Log.Debug ("UnloadContent ()");~\\
\cellcolor{red} & 0 & \verb~223~ & \verb~      Playlist.Stop ();~\\
\cellcolor{red} & 0 & \verb~224~ & \verb~      base.UnloadContent ();~\\
\cellcolor{red} & 0 & \verb~225~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & \verb~    public static float Volume (Sound soundType)~\\
\cellcolor{red} & 0 & \verb~228~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~229~ & \verb~      return VolumeMap [soundType];~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~231~ & \verb~~\\
\cellcolor{gray} &  & \verb~232~ & \verb~    public static void SetVolume (Sound soundType, float volume)~\\
\cellcolor{green} & 1 & \verb~233~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~234~ & \verb~      volume = ValidVolume (volume);~\\
\cellcolor{green} & 1 & \verb~235~ & \verb~      VolumeMap [soundType] = volume;~\\
\cellcolor{green} & 1 & \verb~236~ & \verb~      Options.Default ["volume", soundType.ToString (), 1] = volume;~\\
\cellcolor{green} & 1 & \verb~237~ & \verb~      Log.Debug ("Set Volume (", soundType, "): ", volume);~\\
\cellcolor{green} & 1 & \verb~238~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~239~ & \verb~~\\
\cellcolor{gray} &  & \verb~240~ & \verb~    public static float ValidVolume (float volume)~\\
\cellcolor{green} & 19 & \verb~241~ & \verb~    {~\\
\cellcolor{green} & 19 & \verb~242~ & \verb~      return MathHelper.Clamp (volume, 0.0f, 2.0f);~\\
\cellcolor{green} & 19 & \verb~243~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~244~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~245~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Audio.LoopPlaylist}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Audio.LoopPlaylist\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash LoopPlaylist.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 35\\
\textbf{Coverable lines:} & 35\\
\textbf{Total lines:} & 130\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 0 & 0\\
\hline
\textbf{Shuffle()} & 1 & 0 & 0\\
\hline
\textbf{Start()} & 2 & 0 & 0\\
\hline
\textbf{Stop()} & 2 & 0 & 0\\
\hline
\textbf{Update(...)} & 4 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash LoopPlaylist.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~57~ & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & \verb~namespace Knot3.Audio~\\
\cellcolor{gray} &  & \verb~59~ & \verb~{~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// Diese Klasse repräsentiert eine Playlist, deren Audiodateien der reihe n~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  /// Endlosschleife abgespielt werden.~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  public class LoopPlaylist : IPlaylist~\\
\cellcolor{gray} &  & \verb~65~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    private List<IAudioFile> Sounds;~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    private int index;~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~    public SoundState State { get; private set; }~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// Erstellt eine neue Playlist.~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// <param name='sounds'>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// Die abzuspielenden Audiodateien.~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// </param>~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~    public LoopPlaylist (IEnumerable<IAudioFile> sounds)~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~      Sounds = sounds.ToList ();~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~      index = 0;~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~      State = SoundState.Stopped;~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~      Log.Debug ("Created new playlist (", Sounds.Count, " songs)");~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      foreach (IAudioFile sound in Sounds) {~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~        Log.Debug ("  - ", sound.Name);~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~88~ & \verb~~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    public void Shuffle ()~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~      Sounds = Sounds.Shuffle ().ToList ();~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    /// Starte die Wiedergabe.~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    public void Start ()~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~      if (Sounds.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~        State = SoundState.Playing;~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~        Sounds .At (index).Play ();~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~104~ & \verb~~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    /// Stoppe die Wiedergabe.~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    public void Stop ()~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~      if (Sounds.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~        State = SoundState.Stopped;~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~        Sounds.At (index).Stop ();~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    /// Wird für jeden Frame aufgerufen.~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    public void Update (GameTime time)~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~      if (Sounds.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~        if (State == SoundState.Playing && Sounds.At (index).State != SoundSta~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~          ++index;~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~          Sounds.At (index).Play ();~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~      Sounds.At (index).Update (time);~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~130~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Audio.OggVorbisFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Audio.OggVorbisFile\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash OggVorbisFile.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 54\\
\textbf{Coverable lines:} & 54\\
\textbf{Total lines:} & 142\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 7 & 0 & 0\\
\hline
\textbf{Play()} & 1 & 0 & 0\\
\hline
\textbf{Stop()} & 1 & 0 & 0\\
\hline
\textbf{Update(...)} & 1 & 0 & 0\\
\hline
\textbf{WriteWave(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash OggVorbisFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using OggSharp;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Platform;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~56~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~57~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & \verb~namespace Knot3.Audio~\\
\cellcolor{gray} &  & \verb~62~ & \verb~{~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  public class OggVorbisFile : IAudioFile~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  {~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~    public string Name { get; private set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~    public SoundState State { get { return internalFile.State; } }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    private SoundEffectFile internalFile;~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    public OggVorbisFile (string name, string filepath, Sound soundType)~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~      Name = name;~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      string cachefile = SystemInfo.DecodedMusicCache~\\
\cellcolor{gray} &  & \verb~75~ & \verb~                         + SystemInfo.PathSeparator.ToString ()~\\
\cellcolor{gray} &  & \verb~76~ & \verb~                         + soundType.ToString ()~\\
\cellcolor{gray} &  & \verb~77~ & \verb~                         + "_"~\\
\cellcolor{gray} &  & \verb~78~ & \verb~                         + name.GetHashCode ().ToString ()~\\
\cellcolor{gray} &  & \verb~79~ & \verb~                         + ".wav";~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~      byte[] data;~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~      try {~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~        Log.Debug ("Read from cache: ", cachefile);~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~        data = File.ReadAllBytes (cachefile);~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~      catch (Exception) {~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~        Log.Debug ("Decode: ", name);~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~        OggDecoder decoder = new OggDecoder ();~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~        decoder.Initialize (TitleContainer.OpenStream (filepath));~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        data = decoder.SelectMany (chunk => chunk.Bytes.Take (chunk.Length)).T~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~        using (MemoryStream stream = new MemoryStream ())~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~        using (BinaryWriter writer = new BinaryWriter (stream)) {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~          WriteWave (writer, decoder.Stereo ? 2 : 1, decoder.SampleRate, data)~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~          stream.Position = 0;~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~          data = stream.ToArray ();~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~        File.WriteAllBytes (cachefile, data);~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~      using (MemoryStream stream = new MemoryStream (data)) {~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~        stream.Position = 0;~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~        SoundEffect soundEffect = SoundEffect.FromStream (stream);~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~        internalFile = new SoundEffectFile (name, soundEffect, soundType);~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    public void Play ()~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~      internalFile.Play ();~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    public void Stop ()~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~      internalFile.Stop ();~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    public void Update (GameTime time)~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~      internalFile.Update (time);~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~    private static void WriteWave (BinaryWriter writer, int channels, int rate~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~      writer.Write (new char[4] { 'R', 'I', 'F', 'F' });~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~      writer.Write ((int)(36 + data.Length));~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~      writer.Write (new char[4] { 'W', 'A', 'V', 'E' });~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~      writer.Write (new char[4] { 'f', 'm', 't', ' ' });~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~      writer.Write ((int)16);~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~      writer.Write ((short)1);~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~      writer.Write ((short)channels);~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~      writer.Write ((int)rate);~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~      writer.Write ((int)(rate * ((16 * channels) / 8)));~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~      writer.Write ((short)((16 * channels) / 8));~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~      writer.Write ((short)16);~\\
\cellcolor{gray} &  & \verb~136~ & \verb~~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~      writer.Write (new char[4] { 'd', 'a', 't', 'a' });~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~      writer.Write ((int)data.Length);~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~      writer.Write (data);~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Audio.SoundEffectFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Audio.SoundEffectFile\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash SoundEffectFile.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 24\\
\textbf{Coverable lines:} & 24\\
\textbf{Total lines:} & 113\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{Play()} & 1 & 0 & 0\\
\hline
\textbf{Stop()} & 1 & 0 & 0\\
\hline
\textbf{Update(...)} & 2 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Audio\textbackslash SoundEffectFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~57~ & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & \verb~namespace Knot3.Audio~\\
\cellcolor{gray} &  & \verb~59~ & \verb~{~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// Ein Wrapper um die SoundEffect-Klasse des XNA-Frameworks.~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  public class SoundEffectFile : IAudioFile~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// Der Anzeigename des SoundEffects.~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~    public string Name { get; private set; }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// Gibt an, ob die Wiedergabe läuft oder gestoppt bzw. pausiert ist.~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~    public SoundState State { get { return Instance.State; } }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    public SoundEffect SoundEffect { get; private set; }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    private SoundEffectInstance Instance;~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    private Sound SoundType;~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    private float volume;~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    /// Erstellt eine neue SoundEffect-Datei mit dem angegebenen Anzeigenamen ~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~    public SoundEffectFile (string name, SoundEffect soundEffect, Sound soundT~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~      Name = name;~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~      SoundEffect = soundEffect;~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~      Instance = soundEffect.CreateInstance ();~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~      SoundType = soundType;~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    public void Play ()~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~      Log.Debug ("Play: ", Name);~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~      Instance.Volume = volume = AudioManager.Volume (SoundType);~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      Instance.Play ();~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    public void Stop ()~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~      Log.Debug ("Stop: ", Name);~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~      Instance.Stop ();~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    public void Update (GameTime time)~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~      if (volume != AudioManager.Volume (SoundType)) {~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~        Instance.Volume = volume = AudioManager.Volume (SoundType);~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~112~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.Angles3}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.Angles3\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Angles3.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 69\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 69\\
\textbf{Total lines:} & 223\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{FromDegrees(...)} & 1 & 100 & 100\\
\hline
\textbf{ToDegrees(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 1 & 100 & 100\\
\hline
\textbf{GetHashCode()} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 3 & 100 & 80\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_UnaryNegation(...} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Division(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Division(...)} & 1 & 100 & 100\\
\hline
\textbf{ToString()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Angles3.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Diese Klasse repräsentiert die Rollwinkel der drei Achsen X, Y und Z.~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Sie bietet Möglichkeit vordefinierte Winkelwerte zu verwenden, z.B. stel~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Die Umwandlung zwischen verschiedenen Winkelmaßen wie Grad- und Bogenmaß~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public sealed class Angles3 : IEquatable<Angles3>~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// Der Winkel im Bogenmaß für das Rollen um die X-Achse. Siehe statische ~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// </summary>~\\
\cellcolor{green} & 158 & \verb~67~ & \verb~    public float X { get; set; }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// Der Winkel im Bogenmaß für das Rollen um die Y-Achse. Siehe statische ~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// </summary>~\\
\cellcolor{green} & 154 & \verb~72~ & \verb~    public float Y { get; set; }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// Der Winkel im Bogenmaß für das Rollen um die Z-Achse. Siehe statische ~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// </summary>~\\
\cellcolor{green} & 154 & \verb~77~ & \verb~    public float Z { get; set; }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// Eine statische Eigenschaft mit dem Wert X = 0, Y = 0, Z = 0.~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    public static Angles3 Zero~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    {~\\
\cellcolor{green} & 54 & \verb~84~ & \verb~      get { return new Angles3 (0f, 0f, 0f); }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~88~ & \verb~~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    /// Konstruiert ein neues Angles3-Objekt mit drei gegebenen Winkeln im Bog~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// </summary>~\\
\cellcolor{green} & 91 & \verb~94~ & \verb~    public Angles3 (float x, float y, float z)~\\
\cellcolor{green} & 91 & \verb~95~ & \verb~    {~\\
\cellcolor{green} & 91 & \verb~96~ & \verb~      X = x;~\\
\cellcolor{green} & 91 & \verb~97~ & \verb~      Y = y;~\\
\cellcolor{green} & 91 & \verb~98~ & \verb~      Z = z;~\\
\cellcolor{green} & 91 & \verb~99~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{green} & 5 & \verb~101~ & \verb~    public Angles3 (Vector3 v)~\\
\cellcolor{green} & 5 & \verb~102~ & \verb~    {~\\
\cellcolor{green} & 5 & \verb~103~ & \verb~      X = v.X;~\\
\cellcolor{green} & 5 & \verb~104~ & \verb~      Y = v.Y;~\\
\cellcolor{green} & 5 & \verb~105~ & \verb~      Z = v.Z;~\\
\cellcolor{green} & 5 & \verb~106~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    /// Eine statische Methode, die Grad in Bogenmaß konvertiert.~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    public static Angles3 FromDegrees (float x, float y, float z)~\\
\cellcolor{green} & 46 & \verb~116~ & \verb~    {~\\
\cellcolor{green} & 46 & \verb~117~ & \verb~      return new Angles3 (~\\
\cellcolor{gray} &  & \verb~118~ & \verb~                 MathHelper.ToRadians (x),~\\
\cellcolor{gray} &  & \verb~119~ & \verb~                 MathHelper.ToRadians (y),~\\
\cellcolor{gray} &  & \verb~120~ & \verb~                 MathHelper.ToRadians (z)~\\
\cellcolor{gray} &  & \verb~121~ & \verb~             );~\\
\cellcolor{green} & 46 & \verb~122~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    /// Konvertiert Bogenmaß in Grad.~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    public void ToDegrees (out float x, out float y, out float z)~\\
\cellcolor{green} & 2 & \verb~128~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~129~ & \verb~      x = (int)MathHelper.ToDegrees (X) % 360;~\\
\cellcolor{green} & 2 & \verb~130~ & \verb~      y = (int)MathHelper.ToDegrees (Y) % 360;~\\
\cellcolor{green} & 2 & \verb~131~ & \verb~      z = (int)MathHelper.ToDegrees (Z) % 360;~\\
\cellcolor{green} & 2 & \verb~132~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~133~ & \verb~~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    public override bool Equals (object obj)~\\
\cellcolor{green} & 1 & \verb~135~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~136~ & \verb~      return (obj is Angles3) ? this == (Angles3)obj : false;~\\
\cellcolor{green} & 1 & \verb~137~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~~\\
\cellcolor{gray} &  & \verb~139~ & \verb~    public bool Equals (Angles3 other)~\\
\cellcolor{green} & 12 & \verb~140~ & \verb~    {~\\
\cellcolor{green} & 12 & \verb~141~ & \verb~      return this == other;~\\
\cellcolor{green} & 12 & \verb~142~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{green} & 2 & \verb~145~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~146~ & \verb~      return (int)(this.X + this.Y + this.Z);~\\
\cellcolor{green} & 2 & \verb~147~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~~\\
\cellcolor{gray} &  & \verb~149~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~    #region Operators~\\
\cellcolor{gray} &  & \verb~152~ & \verb~~\\
\cellcolor{gray} &  & \verb~153~ & \verb~    public static bool operator == (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 14 & \verb~154~ & \verb~    {~\\
\cellcolor{green} & 14 & \verb~155~ & \verb~      return value1.X == value2.X~\\
\cellcolor{gray} &  & \verb~156~ & \verb~             && value1.Y == value2.Y~\\
\cellcolor{gray} &  & \verb~157~ & \verb~             && value1.Z == value2.Z;~\\
\cellcolor{green} & 14 & \verb~158~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~    public static bool operator != (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~161~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~162~ & \verb~      return !(value1 == value2);~\\
\cellcolor{green} & 1 & \verb~163~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public static Angles3 operator + (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 6 & \verb~166~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~167~ & \verb~      return new Angles3 (value1.X + value2.X, value1.Y + value2.Y, value1.Z +~\\
\cellcolor{green} & 6 & \verb~168~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~169~ & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & \verb~    public static Angles3 operator - (Angles3 value)~\\
\cellcolor{green} & 1 & \verb~171~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~172~ & \verb~      value = new Angles3 (-value.X, -value.Y, -value.Z);~\\
\cellcolor{green} & 1 & \verb~173~ & \verb~      return value;~\\
\cellcolor{green} & 1 & \verb~174~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~175~ & \verb~~\\
\cellcolor{gray} &  & \verb~176~ & \verb~    public static Angles3 operator - (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~177~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~178~ & \verb~      return new Angles3 (value1.X - value2.X, value1.Y - value2.Y, value1.Z -~\\
\cellcolor{green} & 1 & \verb~179~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~    public static Angles3 operator * (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~182~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~183~ & \verb~      return new Angles3 (value1.X * value2.X, value1.Y * value2.Y, value1.Z *~\\
\cellcolor{green} & 1 & \verb~184~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~185~ & \verb~~\\
\cellcolor{gray} &  & \verb~186~ & \verb~    public static Angles3 operator * (Angles3 value, float scaleFactor)~\\
\cellcolor{green} & 1 & \verb~187~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~188~ & \verb~      return new Angles3 (value.X * scaleFactor, value.Y * scaleFactor, value.~\\
\cellcolor{green} & 1 & \verb~189~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~190~ & \verb~~\\
\cellcolor{gray} &  & \verb~191~ & \verb~    public static Angles3 operator * (float scaleFactor, Angles3 value)~\\
\cellcolor{green} & 1 & \verb~192~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~193~ & \verb~      return new Angles3 (value.X * scaleFactor, value.Y * scaleFactor, value.~\\
\cellcolor{green} & 1 & \verb~194~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~195~ & \verb~~\\
\cellcolor{gray} &  & \verb~196~ & \verb~    public static Angles3 operator / (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~197~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~198~ & \verb~      return new Angles3 (value1.X / value2.X, value1.Y / value2.Y, value1.Z /~\\
\cellcolor{green} & 1 & \verb~199~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~200~ & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & \verb~    public static Angles3 operator / (Angles3 value, float divider)~\\
\cellcolor{green} & 1 & \verb~202~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~203~ & \verb~      float scaleFactor = 1 / divider;~\\
\cellcolor{green} & 1 & \verb~204~ & \verb~      return new Angles3 (value.X * scaleFactor, value.Y * scaleFactor, value.~\\
\cellcolor{green} & 1 & \verb~205~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~206~ & \verb~~\\
\cellcolor{gray} &  & \verb~207~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 1 & \verb~208~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~209~ & \verb~      float x, y, z;~\\
\cellcolor{green} & 1 & \verb~210~ & \verb~      ToDegrees (out x, out y, out z);~\\
\cellcolor{gray} &  & \verb~211~ & \verb~~\\
\cellcolor{green} & 1 & \verb~212~ & \verb~      return   "Angles3 ("~\\
\cellcolor{gray} &  & \verb~213~ & \verb~               + x.ToString ()~\\
\cellcolor{gray} &  & \verb~214~ & \verb~               + ","~\\
\cellcolor{gray} &  & \verb~215~ & \verb~               + y.ToString ()~\\
\cellcolor{gray} &  & \verb~216~ & \verb~               + ","~\\
\cellcolor{gray} &  & \verb~217~ & \verb~               + z.ToString ()~\\
\cellcolor{gray} &  & \verb~218~ & \verb~               + ")";~\\
\cellcolor{green} & 1 & \verb~219~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~220~ & \verb~~\\
\cellcolor{gray} &  & \verb~221~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~222~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~223~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.BooleanOptionInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.BooleanOptionInfo\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash BooleanOptionInfo.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 10\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 96\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 0 & 0\\
\hline
\textbf{.cctor()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash BooleanOptionInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Diese Klasse repräsentiert eine Option, welche die Werte \glqq Wahr\grqq~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public sealed class BooleanOptionInfo : DistinctOptionInfo~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurückgibt.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    public new bool Value~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~        return base.Value == ConfigFile.True ? true : false;~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~        base.Value = value ? ConfigFile.True : ConfigFile.False;~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    public new static string[] ValidValues = new string[] {~\\
\cellcolor{gray} &  & \verb~76~ & \verb~      ConfigFile.True,~\\
\cellcolor{gray} &  & \verb~77~ & \verb~      ConfigFile.False~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    };~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// Erstellt eine neue Option, welche die Werte \glqq Wahr\grqq oder \glqq~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// angegebenen Abschnitt der angegebenen Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// [base=section, name, defaultValue?ConfigFile.True:ConfigFile.False, Va~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~    public BooleanOptionInfo (string section, string name, bool defaultValue, ~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    : base (section, name, defaultValue?ConfigFile.True:ConfigFile.False, Vali~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~95~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.Camera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.Camera\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Camera.cs}\end{minipage} \\
\textbf{Coverage:} & 61.9\%\\
\textbf{Covered lines:} & 83\\
\textbf{Uncovered lines:} & 51\\
\textbf{Coverable lines:} & 134\\
\textbf{Total lines:} & 379\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 100\\
\hline
\textbf{Update(...)} & 1 & 0 & 0\\
\hline
\textbf{UpdateMatrices(...)} & 1 & 100 & 100\\
\hline
\textbf{GetMouseRay(...)} & 1 & 0 & 0\\
\hline
\textbf{ResetCamera()} & 1 & 100 & 100\\
\hline
\textbf{StartSmoothMove(...)} & 2 & 0 & 0\\
\hline
\textbf{UpdateSmoothMove(...} & 2 & 0 & 0\\
\hline
\textbf{To3D(...)} & 2 & 100 & 100\\
\hline
\textbf{To2D(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Camera.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Jede Instanz der World-Klasse hält eine für diese Spielwelt verwendete K~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Die Hauptfunktion der Kamera-Klasse ist das Berechnen der drei Matrizen,~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// und Skalierung von 3D-Objekten in einer bestimmten Spielwelt benötigt we~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// Um diese Matrizen zu berechnen, benötigt die Kamera unter Anderem Inform~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// das aktuelle Kamera-Ziel und das Field of View.~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  public sealed class Camera : GameScreenComponent~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    private Vector3 _position;~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// Die Position der Kamera.~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    public Vector3 Position~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    {~\\
\cellcolor{green} & 75 & \verb~74~ & \verb~      get { return _position; }~\\
\cellcolor{green} & 16 & \verb~75~ & \verb~      set {~\\
\cellcolor{green} & 16 & \verb~76~ & \verb~        OnViewChanged ();~\\
\cellcolor{green} & 16 & \verb~77~ & \verb~        if ((value.X.Abs () <= MaxPositionDistance && value.Y.Abs () <= MaxPos~\\
\cellcolor{green} & 16 & \verb~78~ & \verb~                && value.Z.Abs () <= MaxPositionDistance) || MaxPositionDistan~\\
\cellcolor{green} & 16 & \verb~79~ & \verb~          _position = value;~\\
\cellcolor{green} & 16 & \verb~80~ & \verb~        }~\\
\cellcolor{green} & 16 & \verb~81~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    private Vector3 _target;~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// Das Ziel der Kamera.~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    public Vector3 Target~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    {~\\
\cellcolor{green} & 81 & \verb~91~ & \verb~      get { return _target; }~\\
\cellcolor{green} & 12 & \verb~92~ & \verb~      set {~\\
\cellcolor{green} & 12 & \verb~93~ & \verb~        OnViewChanged ();~\\
\cellcolor{green} & 12 & \verb~94~ & \verb~        _target = value;~\\
\cellcolor{green} & 12 & \verb~95~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    private float _foV;~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// Das Sichtfeld.~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    public float FoV~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    {~\\
\cellcolor{green} & 36 & \verb~105~ & \verb~      get { return _foV; }~\\
\cellcolor{green} & 11 & \verb~106~ & \verb~      set {~\\
\cellcolor{green} & 11 & \verb~107~ & \verb~        _foV = MathHelper.Clamp (value, 10, 70);~\\
\cellcolor{green} & 11 & \verb~108~ & \verb~        OnViewChanged ();~\\
\cellcolor{green} & 11 & \verb~109~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    /// Die View-Matrix wird über die statische Methode CreateLookAt der Klass~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    /// mit Matrix.CreateLookAt (Position, Target, Vector3.Up) berechnet.~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    /// </summary>~\\
\cellcolor{green} & 23 & \verb~116~ & \verb~    public Matrix ViewMatrix { get; private set; }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    /// Die World-Matrix wird mit Matrix.CreateFromYawPitchRoll und den drei R~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    /// </summary>~\\
\cellcolor{green} & 12 & \verb~121~ & \verb~    public Matrix WorldMatrix { get; private set; }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~124~ & \verb~    /// Die Projektionsmatrix wird über die statische XNA-Methode Matrix.Creat~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    /// </summary>~\\
\cellcolor{green} & 23 & \verb~126~ & \verb~    public Matrix ProjectionMatrix { get; private set; }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~129~ & \verb~    /// Berechnet ein Bounding-Frustum, das benötigt wird, um festzustellen, o~\\
\cellcolor{gray} &  & \verb~130~ & \verb~    /// </summary>~\\
\cellcolor{green} & 9 & \verb~131~ & \verb~    public BoundingFrustum ViewFrustum { get; private set; }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    /// Eine Referenz auf die Spielwelt, für welche die Kamera zuständig ist.~\\
\cellcolor{gray} &  & \verb~135~ & \verb~    /// </summary>~\\
\cellcolor{green} & 29 & \verb~136~ & \verb~    private World World { get; set; }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~139~ & \verb~    /// Die Rotationswinkel.~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    /// </summary>~\\
\cellcolor{green} & 34 & \verb~141~ & \verb~    public Angles3 Rotation { get; set; }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~~\\
\cellcolor{green} & 16 & \verb~143~ & \verb~    public Vector3 UpVector { get; private set; }~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{green} & 56 & \verb~145~ & \verb~    public float MaxPositionDistance { get; set; }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{green} & 47 & \verb~147~ & \verb~    public Action OnViewChanged = () => {};~\\
\cellcolor{gray} &  & \verb~148~ & \verb~    private float aspectRatio;~\\
\cellcolor{gray} &  & \verb~149~ & \verb~    private float nearPlane;~\\
\cellcolor{gray} &  & \verb~150~ & \verb~    private float farPlane;~\\
\cellcolor{green} & 8 & \verb~151~ & \verb~    private Vector3 defaultPosition = new Vector3 (400, 400, 700);~\\
\cellcolor{gray} &  & \verb~152~ & \verb~~\\
\cellcolor{gray} &  & \verb~153~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~154~ & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~156~ & \verb~~\\
\cellcolor{gray} &  & \verb~157~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~158~ & \verb~    /// Erstellt eine neue Kamera in einem bestimmten IGameScreen für eine bes~\\
\cellcolor{gray} &  & \verb~159~ & \verb~    /// </summary>~\\
\cellcolor{green} & 8 & \verb~160~ & \verb~    public Camera (IGameScreen screen, World world)~\\
\cellcolor{gray} &  & \verb~161~ & \verb~    : base (screen, DisplayLayer.None)~\\
\cellcolor{green} & 8 & \verb~162~ & \verb~    {~\\
\cellcolor{green} & 8 & \verb~163~ & \verb~      World = world;~\\
\cellcolor{green} & 8 & \verb~164~ & \verb~      Position = defaultPosition;~\\
\cellcolor{green} & 8 & \verb~165~ & \verb~      Target = Vector3.Zero;~\\
\cellcolor{green} & 8 & \verb~166~ & \verb~      UpVector = Vector3.Up;~\\
\cellcolor{green} & 8 & \verb~167~ & \verb~      Rotation = Angles3.Zero;~\\
\cellcolor{green} & 8 & \verb~168~ & \verb~      MaxPositionDistance = 5000;~\\
\cellcolor{gray} &  & \verb~169~ & \verb~~\\
\cellcolor{green} & 8 & \verb~170~ & \verb~      FoV = 60;~\\
\cellcolor{green} & 8 & \verb~171~ & \verb~      nearPlane = 0.5f;~\\
\cellcolor{green} & 8 & \verb~172~ & \verb~      farPlane = 15000.0f;~\\
\cellcolor{gray} &  & \verb~173~ & \verb~~\\
\cellcolor{green} & 8 & \verb~174~ & \verb~      UpdateMatrices (null);~\\
\cellcolor{green} & 8 & \verb~175~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~178~ & \verb~~\\
\cellcolor{gray} &  & \verb~179~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~182~ & \verb~    /// Die Blickrichtung.~\\
\cellcolor{gray} &  & \verb~183~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~184~ & \verb~    public Vector3 PositionToTargetDirection~\\
\cellcolor{gray} &  & \verb~185~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~186~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~        return Vector3.Normalize (Target - Position);~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~189~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~190~ & \verb~~\\
\cellcolor{gray} &  & \verb~191~ & \verb~    public Vector3 PositionToArcballTargetDirection~\\
\cellcolor{gray} &  & \verb~192~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~        return Vector3.Normalize (ArcballTarget - Position);~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~199~ & \verb~    /// Der Abstand zwischen der Kamera und dem Kamera-Ziel.~\\
\cellcolor{gray} &  & \verb~200~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~201~ & \verb~    public float PositionToTargetDistance~\\
\cellcolor{gray} &  & \verb~202~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~203~ & \verb~      get {~\\
\cellcolor{green} & 4 & \verb~204~ & \verb~        return Position.DistanceTo (Target);~\\
\cellcolor{green} & 4 & \verb~205~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~206~ & \verb~      set {~\\
\cellcolor{green} & 4 & \verb~207~ & \verb~        Position = Position.SetDistanceTo (Target, value);~\\
\cellcolor{green} & 4 & \verb~208~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~209~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~210~ & \verb~~\\
\cellcolor{gray} &  & \verb~211~ & \verb~    public float PositionToArcballTargetDistance~\\
\cellcolor{gray} &  & \verb~212~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~213~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~214~ & \verb~        return Position.DistanceTo (ArcballTarget);~\\
\cellcolor{red} & 0 & \verb~215~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~216~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~217~ & \verb~        Position = Position.SetDistanceTo (ArcballTarget, value);~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~219~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~220~ & \verb~~\\
\cellcolor{gray} &  & \verb~221~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~222~ & \verb~    /// Wird für jeden Frame aufgerufen.~\\
\cellcolor{gray} &  & \verb~223~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~224~ & \verb~    public override void Update (GameTime time)~\\
\cellcolor{red} & 0 & \verb~225~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~226~ & \verb~      // Setze den Viewport auf den der aktuellen Spielwelt~\\
\cellcolor{red} & 0 & \verb~227~ & \verb~      Viewport original = Screen.Viewport;~\\
\cellcolor{red} & 0 & \verb~228~ & \verb~      Screen.Viewport = World.Viewport;~\\
\cellcolor{gray} &  & \verb~229~ & \verb~~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~      UpdateMatrices (time);~\\
\cellcolor{red} & 0 & \verb~231~ & \verb~      UpdateSmoothMove (time);~\\
\cellcolor{gray} &  & \verb~232~ & \verb~~\\
\cellcolor{gray} &  & \verb~233~ & \verb~      // Setze den Viewport wieder auf den ganzen Screen~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~      Screen.Viewport = original;~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~236~ & \verb~~\\
\cellcolor{gray} &  & \verb~237~ & \verb~    private void UpdateMatrices (GameTime time)~\\
\cellcolor{green} & 8 & \verb~238~ & \verb~    {~\\
\cellcolor{green} & 8 & \verb~239~ & \verb~      aspectRatio = Screen.Viewport.AspectRatio;~\\
\cellcolor{green} & 8 & \verb~240~ & \verb~      farPlane = MaxPositionDistance * 4;~\\
\cellcolor{green} & 8 & \verb~241~ & \verb~      ViewMatrix = Matrix.CreateLookAt (Position, Target, UpVector);~\\
\cellcolor{green} & 8 & \verb~242~ & \verb~      WorldMatrix = Matrix.CreateFromYawPitchRoll (Rotation.Y, Rotation.X, Rot~\\
\cellcolor{green} & 8 & \verb~243~ & \verb~      ProjectionMatrix = Matrix.CreatePerspectiveFieldOfView (MathHelper.ToRad~\\
\cellcolor{green} & 8 & \verb~244~ & \verb~      ViewFrustum = new BoundingFrustum (ViewMatrix * ProjectionMatrix);~\\
\cellcolor{green} & 8 & \verb~245~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~246~ & \verb~~\\
\cellcolor{gray} &  & \verb~247~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~248~ & \verb~    /// Berechnet einen Strahl für die angegebenene 2D-Mausposition.~\\
\cellcolor{gray} &  & \verb~249~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~250~ & \verb~    public Ray GetMouseRay (Vector2 mousePosition)~\\
\cellcolor{red} & 0 & \verb~251~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~252~ & \verb~      Viewport viewport = World.Viewport;~\\
\cellcolor{gray} &  & \verb~253~ & \verb~~\\
\cellcolor{red} & 0 & \verb~254~ & \verb~      Vector3 nearPoint = new Vector3 (mousePosition, 0);~\\
\cellcolor{red} & 0 & \verb~255~ & \verb~      Vector3 farPoint = new Vector3 (mousePosition, 1);~\\
\cellcolor{gray} &  & \verb~256~ & \verb~~\\
\cellcolor{red} & 0 & \verb~257~ & \verb~      nearPoint = viewport.Unproject (nearPoint, ProjectionMatrix, ViewMatrix,~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~      farPoint = viewport.Unproject (farPoint, ProjectionMatrix, ViewMatrix, M~\\
\cellcolor{gray} &  & \verb~259~ & \verb~~\\
\cellcolor{red} & 0 & \verb~260~ & \verb~      Vector3 direction = farPoint - nearPoint;~\\
\cellcolor{red} & 0 & \verb~261~ & \verb~      direction.Normalize ();~\\
\cellcolor{gray} &  & \verb~262~ & \verb~~\\
\cellcolor{red} & 0 & \verb~263~ & \verb~      return new Ray (nearPoint, direction);~\\
\cellcolor{red} & 0 & \verb~264~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~265~ & \verb~~\\
\cellcolor{gray} &  & \verb~266~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~267~ & \verb~    /// Eine Position, um die rotiert werden soll, wenn der User die rechte Ma~\\
\cellcolor{gray} &  & \verb~268~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~269~ & \verb~    public Vector3 ArcballTarget~\\
\cellcolor{gray} &  & \verb~270~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~271~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~272~ & \verb~        if (World.SelectedObject != null) {~\\
\cellcolor{red} & 0 & \verb~273~ & \verb~          return World.SelectedObject.Center ();~\\
\cellcolor{gray} &  & \verb~274~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~275~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~276~ & \verb~          return Vector3.Zero;~\\
\cellcolor{gray} &  & \verb~277~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~278~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~279~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~280~ & \verb~~\\
\cellcolor{gray} &  & \verb~281~ & \verb~    public void ResetCamera ()~\\
\cellcolor{green} & 2 & \verb~282~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~283~ & \verb~      Position = defaultPosition;~\\
\cellcolor{green} & 2 & \verb~284~ & \verb~      Target = new Vector3 (0, 0, 0);~\\
\cellcolor{green} & 2 & \verb~285~ & \verb~      Rotation = Angles3.Zero;~\\
\cellcolor{green} & 2 & \verb~286~ & \verb~      FoV = 45;~\\
\cellcolor{green} & 2 & \verb~287~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~288~ & \verb~~\\
\cellcolor{green} & 8 & \verb~289~ & \verb~    private Vector3? smoothTarget = null;~\\
\cellcolor{green} & 8 & \verb~290~ & \verb~    private float smoothDistance = 0f;~\\
\cellcolor{green} & 8 & \verb~291~ & \verb~    private float smoothProgress = 0f;~\\
\cellcolor{gray} &  & \verb~292~ & \verb~~\\
\cellcolor{gray} &  & \verb~293~ & \verb~    public void StartSmoothMove (Vector3 target, GameTime time)~\\
\cellcolor{red} & 0 & \verb~294~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~295~ & \verb~      if (!InSmoothMove) {~\\
\cellcolor{red} & 0 & \verb~296~ & \verb~        smoothTarget = target;~\\
\cellcolor{red} & 0 & \verb~297~ & \verb~        smoothDistance = Math.Abs (Target.DistanceTo (target));~\\
\cellcolor{red} & 0 & \verb~298~ & \verb~        smoothProgress = 0f;~\\
\cellcolor{red} & 0 & \verb~299~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~300~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~301~ & \verb~~\\
\cellcolor{red} & 0 & \verb~302~ & \verb~    public bool InSmoothMove { get { return smoothTarget.HasValue && smoothPro~\\
\cellcolor{gray} &  & \verb~303~ & \verb~~\\
\cellcolor{gray} &  & \verb~304~ & \verb~    private void UpdateSmoothMove (GameTime time)~\\
\cellcolor{red} & 0 & \verb~305~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~306~ & \verb~      if (InSmoothMove) {~\\
\cellcolor{red} & 0 & \verb~307~ & \verb~        float distance = MathHelper.SmoothStep (0, smoothDistance, smoothProgr~\\
\cellcolor{gray} &  & \verb~308~ & \verb~~\\
\cellcolor{red} & 0 & \verb~309~ & \verb~        smoothProgress += 0.05f;~\\
\cellcolor{gray} &  & \verb~310~ & \verb~~\\
\cellcolor{gray} &  & \verb~311~ & \verb~        //Log.Debug ("distance = ", distance);~\\
\cellcolor{red} & 0 & \verb~312~ & \verb~        Target = Target.SetDistanceTo (~\\
\cellcolor{gray} &  & \verb~313~ & \verb~                     target: smoothTarget.Value,~\\
\cellcolor{gray} &  & \verb~314~ & \verb~                     distance: Math.Max (0, smoothDistance - distance)~\\
\cellcolor{gray} &  & \verb~315~ & \verb~                 );~\\
\cellcolor{red} & 0 & \verb~316~ & \verb~        World.Redraw = true;~\\
\cellcolor{red} & 0 & \verb~317~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~318~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~319~ & \verb~~\\
\cellcolor{gray} &  & \verb~320~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~321~ & \verb~    /// Berechne aus einer 2D-Positon (z.b. Mausposition) die entsprechende Po~\\
\cellcolor{gray} &  & \verb~322~ & \verb~    /// Für die fehlende dritte Koordinate wird eine Angabe einer weiteren 3D-~\\
\cellcolor{gray} &  & \verb~323~ & \verb~    /// mit der die 3D-(Maus-)Position auf der selben Ebene liegen soll.~\\
\cellcolor{gray} &  & \verb~324~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~325~ & \verb~    public Vector3 To3D (Vector2 position, Vector3 nearTo)~\\
\cellcolor{green} & 2 & \verb~326~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~327~ & \verb~      if (Options.Default ["debug", "unproject", "SelectedObject"] == "NearFar~\\
\cellcolor{green} & 1 & \verb~328~ & \verb~        Vector3 nearScreenPoint = new Vector3 (position.X, position.Y, 0);~\\
\cellcolor{green} & 1 & \verb~329~ & \verb~        Vector3 farScreenPoint = new Vector3 (position.X, position.Y, 1);~\\
\cellcolor{green} & 1 & \verb~330~ & \verb~        Vector3 nearWorldPoint = World.Viewport.Unproject (~\\
\cellcolor{gray} &  & \verb~331~ & \verb~                                     source: nearScreenPoint,~\\
\cellcolor{gray} &  & \verb~332~ & \verb~                                     projection: World.Camera.ProjectionMatrix~\\
\cellcolor{gray} &  & \verb~333~ & \verb~                                     view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~334~ & \verb~                                     world: Matrix.Identity~\\
\cellcolor{gray} &  & \verb~335~ & \verb~                                 );~\\
\cellcolor{green} & 1 & \verb~336~ & \verb~        Vector3 farWorldPoint = World.Viewport.Unproject (~\\
\cellcolor{gray} &  & \verb~337~ & \verb~                                    source: farScreenPoint,~\\
\cellcolor{gray} &  & \verb~338~ & \verb~                                    projection: World.Camera.ProjectionMatrix,~\\
\cellcolor{gray} &  & \verb~339~ & \verb~                                    view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~340~ & \verb~                                    world: Matrix.Identity~\\
\cellcolor{gray} &  & \verb~341~ & \verb~                                );~\\
\cellcolor{gray} &  & \verb~342~ & \verb~~\\
\cellcolor{green} & 1 & \verb~343~ & \verb~        Vector3 direction = farWorldPoint - nearWorldPoint;~\\
\cellcolor{gray} &  & \verb~344~ & \verb~~\\
\cellcolor{green} & 1 & \verb~345~ & \verb~        float zFactor = -nearWorldPoint.Y / direction.Y;~\\
\cellcolor{green} & 1 & \verb~346~ & \verb~        Vector3 zeroWorldPoint = nearWorldPoint + direction * zFactor;~\\
\cellcolor{green} & 1 & \verb~347~ & \verb~        return zeroWorldPoint;~\\
\cellcolor{gray} &  & \verb~348~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~349~ & \verb~      else {~\\
\cellcolor{green} & 1 & \verb~350~ & \verb~        Vector3 screenLocation = World.Viewport.Project (~\\
\cellcolor{gray} &  & \verb~351~ & \verb~                                     source: nearTo,~\\
\cellcolor{gray} &  & \verb~352~ & \verb~                                     projection: World.Camera.ProjectionMatrix~\\
\cellcolor{gray} &  & \verb~353~ & \verb~                                     view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~354~ & \verb~                                     world: World.Camera.WorldMatrix~\\
\cellcolor{gray} &  & \verb~355~ & \verb~                                 );~\\
\cellcolor{green} & 1 & \verb~356~ & \verb~        Vector3 currentMousePosition = World.Viewport.Unproject (~\\
\cellcolor{gray} &  & \verb~357~ & \verb~                                           source: new Vector3 (position, scre~\\
\cellcolor{gray} &  & \verb~358~ & \verb~                                           projection: World.Camera.Projection~\\
\cellcolor{gray} &  & \verb~359~ & \verb~                                           view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~360~ & \verb~                                           world: Matrix.Identity~\\
\cellcolor{gray} &  & \verb~361~ & \verb~                                       );~\\
\cellcolor{green} & 1 & \verb~362~ & \verb~        return currentMousePosition;~\\
\cellcolor{gray} &  & \verb~363~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~364~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~365~ & \verb~~\\
\cellcolor{gray} &  & \verb~366~ & \verb~    public Vector2 To2D (Vector3 position)~\\
\cellcolor{green} & 2 & \verb~367~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~368~ & \verb~      Vector3 screenLocation = World.Viewport.Project (~\\
\cellcolor{gray} &  & \verb~369~ & \verb~                                   source: position,~\\
\cellcolor{gray} &  & \verb~370~ & \verb~                                   projection: World.Camera.ProjectionMatrix,~\\
\cellcolor{gray} &  & \verb~371~ & \verb~                                   view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~372~ & \verb~                                   world: World.Camera.WorldMatrix~\\
\cellcolor{gray} &  & \verb~373~ & \verb~                               );~\\
\cellcolor{green} & 2 & \verb~374~ & \verb~      return new Vector2 (screenLocation.X, screenLocation.Y);~\\
\cellcolor{green} & 2 & \verb~375~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~376~ & \verb~~\\
\cellcolor{gray} &  & \verb~377~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~378~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~379~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.ConfigFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.ConfigFile\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash ConfigFile.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 55\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 55\\
\textbf{Total lines:} & 187\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 66.67\\
\hline
\textbf{SetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{GetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{SetOption(...)} & 2 & 100 & 100\\
\hline
\textbf{GetOption(...)} & 4 & 100 & 80\\
\hline
\textbf{SetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{GetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{floatToString(...)} & 1 & 100 & 100\\
\hline
\textbf{stringToFloat(...)} & 2 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash ConfigFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Repräsentiert eine Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public sealed class ConfigFile~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// Die Repräsentation des Wahrheitswerts "wahr" als String in einer Einst~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// </summary>~\\
\cellcolor{green} & 435 & \verb~67~ & \verb~    public static string True { get { return "true"; } }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// Die Repräsentation des Wahrheitswerts "falsch" als String in einer Ein~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// </summary>~\\
\cellcolor{green} & 465 & \verb~72~ & \verb~    public static string False { get { return "false"; } }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    private string Filename;~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    private IniFile ini;~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{green} & 3 & \verb~81~ & \verb~    public ConfigFile (string filename)~\\
\cellcolor{green} & 3 & \verb~82~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~83~ & \verb~      // load ini file~\\
\cellcolor{green} & 3 & \verb~84~ & \verb~      Filename = filename;~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~      // create a new ini parser~\\
\cellcolor{green} & 6 & \verb~87~ & \verb~      using (StreamWriter w = File.AppendText (Filename)) {~\\
\cellcolor{green} & 3 & \verb~88~ & \verb~      }~\\
\cellcolor{green} & 3 & \verb~89~ & \verb~      ini = new IniFile (Filename);~\\
\cellcolor{green} & 3 & \verb~90~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// Setzt den Wert der Option mit dem angegebenen Namen in den angegebenen~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    public void SetOption (string section, string option, string _value)~\\
\cellcolor{green} & 304 & \verb~100~ & \verb~    {~\\
\cellcolor{green} & 304 & \verb~101~ & \verb~      ini [section, option] = _value;~\\
\cellcolor{green} & 304 & \verb~102~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    /// Gibt den aktuell in der Datei vorhandenen Wert für die angegebene Opti~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    public string GetOption (string section, string option, string defaultValu~\\
\cellcolor{green} & 525 & \verb~108~ & \verb~    {~\\
\cellcolor{green} & 525 & \verb~109~ & \verb~      return ini [section, option, defaultValue];~\\
\cellcolor{green} & 525 & \verb~110~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    /// Setzt den Wert der Option mit dem angegebenen Namen in den angegebenen~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    public void SetOption (string section, string option, bool _value)~\\
\cellcolor{green} & 100 & \verb~116~ & \verb~    {~\\
\cellcolor{green} & 100 & \verb~117~ & \verb~      SetOption (section, option, _value ? True : False);~\\
\cellcolor{green} & 100 & \verb~118~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~119~ & \verb~~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    /// Gibt den aktuell in der Datei vorhandenen Wert für die angegebene Opti~\\
\cellcolor{gray} &  & \verb~122~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    public bool GetOption (string section, string option, bool defaultValue)~\\
\cellcolor{green} & 100 & \verb~124~ & \verb~    {~\\
\cellcolor{green} & 100 & \verb~125~ & \verb~      return GetOption (section, option, defaultValue ? True : False) == True ~\\
\cellcolor{green} & 100 & \verb~126~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    public void SetOption (string section, string option, float _value)~\\
\cellcolor{green} & 101 & \verb~129~ & \verb~    {~\\
\cellcolor{green} & 101 & \verb~130~ & \verb~      SetOption (section, option, floatToString (_value));~\\
\cellcolor{green} & 101 & \verb~131~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    public float GetOption (string section, string option, float defaultValue)~\\
\cellcolor{green} & 218 & \verb~134~ & \verb~    {~\\
\cellcolor{green} & 218 & \verb~135~ & \verb~      return stringToFloat (GetOption (section, option, floatToString (default~\\
\cellcolor{green} & 218 & \verb~136~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    private string floatToString (float f)~\\
\cellcolor{green} & 319 & \verb~139~ & \verb~    {~\\
\cellcolor{green} & 319 & \verb~140~ & \verb~      return String.Empty + ((int) (f * 1000)).ToString ();~\\
\cellcolor{green} & 319 & \verb~141~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & \verb~    private float stringToFloat (string s)~\\
\cellcolor{green} & 218 & \verb~144~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~145~ & \verb~      int i;~\\
\cellcolor{green} & 218 & \verb~146~ & \verb~      bool result = Int32.TryParse (s, out i);~\\
\cellcolor{green} & 336 & \verb~147~ & \verb~      if (true == result) {~\\
\cellcolor{green} & 118 & \verb~148~ & \verb~        return ((float)i) / 1000f;~\\
\cellcolor{gray} &  & \verb~149~ & \verb~      }~\\
\cellcolor{green} & 100 & \verb~150~ & \verb~      else {~\\
\cellcolor{green} & 100 & \verb~151~ & \verb~        return 0;~\\
\cellcolor{gray} &  & \verb~152~ & \verb~      }~\\
\cellcolor{green} & 218 & \verb~153~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & \verb~    public bool this [string section, string option, bool defaultValue = false~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    {~\\
\cellcolor{green} & 100 & \verb~157~ & \verb~      get {~\\
\cellcolor{green} & 100 & \verb~158~ & \verb~        return GetOption (section, option, defaultValue);~\\
\cellcolor{green} & 100 & \verb~159~ & \verb~      }~\\
\cellcolor{green} & 100 & \verb~160~ & \verb~      set {~\\
\cellcolor{green} & 100 & \verb~161~ & \verb~        SetOption (section, option, value);~\\
\cellcolor{green} & 100 & \verb~162~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~163~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public float this [string section, string option, float defaultValue = 0f]~\\
\cellcolor{gray} &  & \verb~166~ & \verb~    {~\\
\cellcolor{green} & 218 & \verb~167~ & \verb~      get {~\\
\cellcolor{green} & 218 & \verb~168~ & \verb~        return GetOption (section, option, defaultValue);~\\
\cellcolor{green} & 218 & \verb~169~ & \verb~      }~\\
\cellcolor{green} & 101 & \verb~170~ & \verb~      set {~\\
\cellcolor{green} & 101 & \verb~171~ & \verb~        SetOption (section, option, value);~\\
\cellcolor{green} & 101 & \verb~172~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~173~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~174~ & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & \verb~    public string this [string section, string option, string defaultValue = n~\\
\cellcolor{gray} &  & \verb~176~ & \verb~    {~\\
\cellcolor{green} & 207 & \verb~177~ & \verb~      get {~\\
\cellcolor{green} & 207 & \verb~178~ & \verb~        return GetOption (section, option, defaultValue);~\\
\cellcolor{green} & 207 & \verb~179~ & \verb~      }~\\
\cellcolor{green} & 103 & \verb~180~ & \verb~      set {~\\
\cellcolor{green} & 103 & \verb~181~ & \verb~        SetOption (section, option, value);~\\
\cellcolor{green} & 103 & \verb~182~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~183~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~184~ & \verb~~\\
\cellcolor{gray} &  & \verb~185~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~186~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~187~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.DisplayLayer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.DisplayLayer\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash DisplayLayer.cs}\end{minipage} \\
\textbf{Coverage:} & 98.3\%\\
\textbf{Covered lines:} & 58\\
\textbf{Uncovered lines:} & 1\\
\textbf{Coverable lines:} & 59\\
\textbf{Total lines:} & 204\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{ToString()} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 88.89 & 71.43\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{GetHashCode()} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash DisplayLayer.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Die Zeichenreihenfolge der Elemente der grafischen Benutzeroberfläche.~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public class DisplayLayer : IEquatable<DisplayLayer>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Enumeration Values~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Steht für die hinterste Ebene bei der Zeichenreihenfolge.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~    public static readonly DisplayLayer None = new DisplayLayer (0, "None");~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Steht für eine Ebene hinter der Spielwelt, z.B. um~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// Hintergrundbilder darzustellen.~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~70~ & \verb~    public static readonly DisplayLayer Background = new DisplayLayer (10, "Ba~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// Steht für die Ebene in der die Spielwelt dargestellt wird.~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~74~ & \verb~    public static readonly DisplayLayer GameWorld = new DisplayLayer (20, "Gam~\\
\cellcolor{green} & 1 & \verb~75~ & \verb~    public static readonly DisplayLayer ScreenUI = new DisplayLayer (30, "Scre~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    /// Steht für die Ebene in der die Dialoge dargestellt werden.~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    /// Dialoge werden vor der Spielwelt gezeichnet, damit der Spieler damit i~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~80~ & \verb~    public static readonly DisplayLayer Dialog = new DisplayLayer (50, "Dialog~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    /// Steht für die Ebene in der Menüs gezeichnet werden. Menüs werden inner~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~84~ & \verb~    public static readonly DisplayLayer Menu = new DisplayLayer (10, "Menu");~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// Steht für die Ebene in der Menüeinträge gezeichnet werden. Menüeinträg~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~88~ & \verb~    public static readonly DisplayLayer MenuItem = new DisplayLayer (20, "Menu~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    /// Zum Anzeigen zusätzlicher Informationen bei der (Weiter-)Entwicklung o~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~92~ & \verb~    public static readonly DisplayLayer Overlay = new DisplayLayer (300, "Over~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// Die Maus ist das Hauptinteraktionswerkzeug, welches der Spieler~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    /// ständig verwendet. Daher muss die Maus bei der Interaktion immer~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// im Vordergrund sein. Cursor steht für die vorderste Ebene.~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~98~ & \verb~    public static readonly DisplayLayer Cursor = new DisplayLayer (500, "Curso~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{green} & 1 & \verb~100~ & \verb~    public static readonly DisplayLayer[] Values = {~\\
\cellcolor{gray} &  & \verb~101~ & \verb~      None, Background, GameWorld, ScreenUI, Dialog, Menu, MenuItem, Overlay, ~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    };~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    #region Static Attributes~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{green} & 1825 & \verb~112~ & \verb~    public int Index { get; private set; }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~~\\
\cellcolor{green} & 1001 & \verb~114~ & \verb~    public string Description { get; private set; }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~119~ & \verb~~\\
\cellcolor{green} & 18 & \verb~120~ & \verb~    private DisplayLayer (int index, string desciption)~\\
\cellcolor{green} & 18 & \verb~121~ & \verb~    {~\\
\cellcolor{green} & 18 & \verb~122~ & \verb~      Index = index;~\\
\cellcolor{green} & 18 & \verb~123~ & \verb~      Description = desciption;~\\
\cellcolor{green} & 18 & \verb~124~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~125~ & \verb~~\\
\cellcolor{green} & 324 & \verb~126~ & \verb~    private DisplayLayer (DisplayLayer layer1, DisplayLayer layer2)~\\
\cellcolor{green} & 324 & \verb~127~ & \verb~    {~\\
\cellcolor{green} & 324 & \verb~128~ & \verb~      Index = layer1.Index + layer2.Index;~\\
\cellcolor{green} & 324 & \verb~129~ & \verb~      Description = layer1.Description + "+" + layer2.Description;~\\
\cellcolor{green} & 324 & \verb~130~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{gray} &  & \verb~132~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~133~ & \verb~~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    #region Methods and Operators~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 1 & \verb~137~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~138~ & \verb~      return Description;~\\
\cellcolor{green} & 1 & \verb~139~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~140~ & \verb~~\\
\cellcolor{gray} &  & \verb~141~ & \verb~    public static DisplayLayer operator + (DisplayLayer layer1, DisplayLayer l~\\
\cellcolor{green} & 243 & \verb~142~ & \verb~    {~\\
\cellcolor{green} & 243 & \verb~143~ & \verb~      return new DisplayLayer (layer1, layer2);~\\
\cellcolor{green} & 243 & \verb~144~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & \verb~    public static DisplayLayer operator + (DisplayLayer layer, Widget widget)~\\
\cellcolor{green} & 81 & \verb~147~ & \verb~    {~\\
\cellcolor{green} & 81 & \verb~148~ & \verb~      return new DisplayLayer (widget.Index, layer);~\\
\cellcolor{green} & 81 & \verb~149~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~    public static DisplayLayer operator * (DisplayLayer layer, int i)~\\
\cellcolor{green} & 9 & \verb~152~ & \verb~    {~\\
\cellcolor{green} & 9 & \verb~153~ & \verb~      return new DisplayLayer (layer.Index * i, "(" + layer + "*" + i + ")");~\\
\cellcolor{green} & 9 & \verb~154~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    public static bool operator == (DisplayLayer a, DisplayLayer b)~\\
\cellcolor{green} & 27 & \verb~157~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~158~ & \verb~      // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 36 & \verb~159~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 9 & \verb~160~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~161~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~162~ & \verb~~\\
\cellcolor{gray} &  & \verb~163~ & \verb~      // If one is null, but not both, return false.~\\
\cellcolor{green} & 36 & \verb~164~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 18 & \verb~165~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~166~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~167~ & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & \verb~      // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~      return a.Index == b.Index;~\\
\cellcolor{green} & 27 & \verb~170~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~171~ & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & \verb~    public static bool operator != (DisplayLayer d1, DisplayLayer d2)~\\
\cellcolor{green} & 27 & \verb~173~ & \verb~    {~\\
\cellcolor{green} & 27 & \verb~174~ & \verb~      return !(d1 == d2);~\\
\cellcolor{green} & 27 & \verb~175~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~    public bool Equals (DisplayLayer other)~\\
\cellcolor{green} & 27 & \verb~178~ & \verb~    {~\\
\cellcolor{green} & 27 & \verb~179~ & \verb~      return other != null && Index == other.Index;~\\
\cellcolor{green} & 27 & \verb~180~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~181~ & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & \verb~    public override bool Equals (object other)~\\
\cellcolor{green} & 9 & \verb~183~ & \verb~    {~\\
\cellcolor{green} & 9 & \verb~184~ & \verb~      return other != null && Equals (other as DisplayLayer);~\\
\cellcolor{green} & 9 & \verb~185~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{gray} &  & \verb~187~ & \verb~    public static implicit operator string (DisplayLayer layer)~\\
\cellcolor{green} & 9 & \verb~188~ & \verb~    {~\\
\cellcolor{green} & 9 & \verb~189~ & \verb~      return layer.Description;~\\
\cellcolor{green} & 9 & \verb~190~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & \verb~    public static implicit operator int (DisplayLayer layer)~\\
\cellcolor{green} & 601 & \verb~193~ & \verb~    {~\\
\cellcolor{green} & 601 & \verb~194~ & \verb~      return layer.Index;~\\
\cellcolor{green} & 601 & \verb~195~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{green} & 1 & \verb~198~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~199~ & \verb~      return Description.GetHashCode ();~\\
\cellcolor{green} & 1 & \verb~200~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~201~ & \verb~~\\
\cellcolor{gray} &  & \verb~202~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~203~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~204~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.DistinctOptionInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.DistinctOptionInfo\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash DistinctOptionInfo.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 22\\
\textbf{Coverable lines:} & 22\\
\textbf{Total lines:} & 111\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 3 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash DistinctOptionInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Diese Klasse repräsentiert eine Option, die einen Wert aus einer distink~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public class DistinctOptionInfo : OptionInfo~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Eine Menge von Texten, welche die für die Option gültigen Werte beschr~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~    public HashSet<string> ValidValues { get; private set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~    public virtual Dictionary<string,string> DisplayValidValues { get; private~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurück gibt.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    public override string Value~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~        return base.Value;~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~        if (ValidValues.Contains (value)) {~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~          base.Value = value;~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~          base.Value = DefaultValue;~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    public virtual string DisplayValue~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~        return Value;~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// Erstellt eine neue Option, die einen der angegebenen Werte aus validVa~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// angegebenen Abschnitt der angegebenen Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// [base=section, name, defaultValue, configFile]~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    public DistinctOptionInfo (string section, string name, string defaultValu~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    : base (section, name, defaultValue, configFile)~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~      ValidValues = new HashSet<string> (validValues);~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~      ValidValues.Add (defaultValue);~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~      DisplayValidValues = new Dictionary<string,string> (ValidValues.ToDictio~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~108~ & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~110~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.DrawableGameScreenComponent}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.DrawableGameScreenComponent\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{scal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash DrawableGameScreenComponent.cs}\end{minipage} \\
\textbf{Coverage:} & 84.6\%\\
\textbf{Covered lines:} & 11\\
\textbf{Uncovered lines:} & 2\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 111\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{MoveNext()} & 2 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{scal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash DrawableGameScreenComponent.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Eine zeichenbare Spielkomponente, die in einem angegebenen Spielzustand ~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public abstract class DrawableGameScreenComponent : DrawableGameComponent, I~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Der zugewiesene Spielzustand.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{green} & 104 & \verb~65~ & \verb~    public IGameScreen Screen { get; set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    private DisplayLayer _index;~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// Die Zeichen- und Eingabepriorität.~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    public DisplayLayer Index~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    {~\\
\cellcolor{green} & 243 & \verb~74~ & \verb~      get { return _index; }~\\
\cellcolor{green} & 88 & \verb~75~ & \verb~      set {~\\
\cellcolor{green} & 88 & \verb~76~ & \verb~        _index = value;~\\
\cellcolor{green} & 88 & \verb~77~ & \verb~        DrawOrder = (int)value;~\\
\cellcolor{green} & 88 & \verb~78~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// Erzeugt eine neue Instanz eines DrawableGameScreenComponent-Objekts un~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// index bezeichnet die Zeichenebene, auf welche die Komponente zu zeichn~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// </summary>~\\
\cellcolor{green} & 88 & \verb~89~ & \verb~    public DrawableGameScreenComponent (IGameScreen screen, DisplayLayer index~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    : base (screen.Game)~\\
\cellcolor{green} & 88 & \verb~91~ & \verb~    {~\\
\cellcolor{green} & 88 & \verb~92~ & \verb~      this.Screen = screen;~\\
\cellcolor{green} & 88 & \verb~93~ & \verb~      this.Index = index;~\\
\cellcolor{green} & 88 & \verb~94~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// Gibt Spielkomponenten zurück, die in dieser Spielkomponente enthalten ~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// [returntype=IEnumerable<IGameScreenComponent>]~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    public virtual IEnumerable<IGameScreenComponent> SubComponents (GameTime G~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~      yield break;~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~108~ & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~110~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.FloatOptionInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.FloatOptionInfo\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash FloatOptionInfo.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 25\\
\textbf{Coverable lines:} & 25\\
\textbf{Total lines:} & 120\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{convertToString(...)} & 1 & 0 & 0\\
\hline
\textbf{stringToFloat(...)} & 2 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash FloatOptionInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Diese Klasse repräsentiert eine Option, welche die Werte \glqq Wahr\grqq~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public sealed class FloatOptionInfo : DistinctOptionInfo~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurückgibt.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    public new float Value~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~        return stringToFloat (base.Value);~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~        base.Value = convertToString (value);~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    public override string DisplayValue~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~        return String.Empty + stringToFloat (base.Value);~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    public override Dictionary<string,string> DisplayValidValues~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~        return new Dictionary<string, string>(base.ValidValues.ToDictionary (s~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~88~ & \verb~~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// Erstellt eine neue Option, welche die Werte \glqq Wahr\grqq oder \glqq~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    /// angegebenen Abschnitt der angegebenen Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// [base=section, name, defaultValue?ConfigFile.True:ConfigFile.False, Va~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~    public FloatOptionInfo (string section, string name, float defaultValue, I~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    : base (section, name, convertToString ( defaultValue),validValues.Select ~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    private static string convertToString (float f)~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~      return (String.Empty + (int)(f * 1000f));~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    private static float stringToFloat (string s)~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~109~ & \verb~      int i;~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~      bool result = Int32.TryParse (s, out i);~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~      if (true == result) {~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~        return ((float)i) / 1000f;~\\
\cellcolor{gray} &  & \verb~113~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~        return 0;~\\
\cellcolor{gray} &  & \verb~116~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~119~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~120~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.GameScreenComponent}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.GameScreenComponent\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash GameScreenComponent.cs}\end{minipage} \\
\textbf{Coverage:} & 77.7\%\\
\textbf{Covered lines:} & 7\\
\textbf{Uncovered lines:} & 2\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 101\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{MoveNext()} & 2 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash GameScreenComponent.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Eine Spielkomponente, die in einem IGameScreen verwendet wird und eine b~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public abstract class GameScreenComponent : GameComponent, IGameScreenCompon~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Die Zeichen- und Eingabepriorität.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{green} & 23 & \verb~65~ & \verb~    public DisplayLayer Index { get; set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// Der zugewiesene Spielzustand.~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// </summary>~\\
\cellcolor{green} & 31 & \verb~70~ & \verb~    public IGameScreen Screen { get; set; }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~75~ & \verb~~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    /// Erzeugt eine neue Instanz eines IGameScreenComponent-Objekts und initi~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    /// </summary>~\\
\cellcolor{green} & 23 & \verb~79~ & \verb~    public GameScreenComponent (IGameScreen screen, DisplayLayer index)~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    : base (screen.Game)~\\
\cellcolor{green} & 23 & \verb~81~ & \verb~    {~\\
\cellcolor{green} & 23 & \verb~82~ & \verb~      this.Screen = screen;~\\
\cellcolor{green} & 23 & \verb~83~ & \verb~      this.Index = index;~\\
\cellcolor{green} & 23 & \verb~84~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// Gibt Spielkomponenten zurück, die in dieser Spielkomponente enthalten ~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    /// [returntype=IEnumerable<IGameScreenComponent>]~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    public virtual IEnumerable<IGameScreenComponent> SubComponents (GameTime G~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~      yield break;~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~100~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~101~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.KeyOptionInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.KeyOptionInfo\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash KeyOptionInfo.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 10\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 86\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{.cctor()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash KeyOptionInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  public class KeyOptionInfo : DistinctOptionInfo~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~58~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~59~ & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurückgibt.~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    public new Keys Value~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~        return base.Value.ToEnumValue<Keys> ();~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~        base.Value = value.ToEnumDescription<Keys> ();~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~    public new static IEnumerable<string> ValidValues = typeof (Keys).ToEnumVa~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~    public KeyOptionInfo (string section, string name, Keys defaultValue, Conf~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    : base (section, name, defaultValue.ToEnumDescription<Keys> (), ValidValue~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~85~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.Localizer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.Localizer\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Localizer.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 82\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{Localize(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Localizer.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~54~ & \verb~{~\\
\cellcolor{gray} &  & \verb~55~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// Eine statische Klasse, die Bezeichner in lokalisierten Text umsetzen kan~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public static class Localizer~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// Die Datei, welche Informationen für die Lokalisierung enthält.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~    private static ConfigFile localization { get; set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// Liefert zu dem übergebenen Bezeichner den zugehörigen Text aus der Lok~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// aktuellen Sprache zurück, die dabei aus der Einstellungsdatei des Spie~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    public static string Localize (string text)~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      throw new System.NotImplementedException ();~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~81~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.OptionInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.OptionInfo\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash OptionInfo.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 18\\
\textbf{Coverable lines:} & 18\\
\textbf{Total lines:} & 115\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash OptionInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Enthält Informationen über einen Eintrag in einer Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public class OptionInfo~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// Die Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    private ConfigFile configFile;~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Der Abschnitt der Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    public string Section { get; private set; }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// Der Name der Option.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~    public string Name { get; private set; }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// Der Standardwert der Option.~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~    public string DefaultValue { get; private set; }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// Der Wert der Option.~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    public virtual string Value~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~        Log.Debug ("OptionInfo: ", Section, ".", Name, " => ", configFile [Sec~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        return configFile [Section, Name, DefaultValue];~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~        Log.Debug ("OptionInfo: ", Section, ".", Name, " <= ", value);~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~        configFile [Section, Name, DefaultValue] = value;~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~101~ & \verb~~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    /// Erstellt ein neues OptionsInfo-Objekt aus den übergegebenen Werten.~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~    public OptionInfo (string section, string name, string defaultValue, Confi~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~      Section = section;~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~      Name = name;~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~      DefaultValue = defaultValue;~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~      this.configFile = configFile != null ? configFile : Options.Default;~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~112~ & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~114~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.Options}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.Options\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Options.cs}\end{minipage} \\
\textbf{Coverage:} & 81.2\%\\
\textbf{Covered lines:} & 13\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 16\\
\textbf{Total lines:} & 98\\
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash Options.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Platform;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Eine statische Klasse, die eine Referenz auf die zentrale Einstellungsda~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public static class Options~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// Die zentrale Einstellungsdatei des Spiels.~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    public static ConfigFile Default~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    {~\\
\cellcolor{green} & 25 & \verb~69~ & \verb~      get {~\\
\cellcolor{green} & 26 & \verb~70~ & \verb~        if (_default == null) {~\\
\cellcolor{green} & 1 & \verb~71~ & \verb~          _default = new ConfigFile (SystemInfo.SettingsDirectory + SystemInfo~\\
\cellcolor{green} & 1 & \verb~72~ & \verb~        }~\\
\cellcolor{green} & 25 & \verb~73~ & \verb~        return _default;~\\
\cellcolor{green} & 25 & \verb~74~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~        _default = value;~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    private static ConfigFile _default;~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    public static ConfigFile Models~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~84~ & \verb~      get {~\\
\cellcolor{green} & 5 & \verb~85~ & \verb~        if (_models == null) {~\\
\cellcolor{green} & 1 & \verb~86~ & \verb~          String seperatorString = SystemInfo.PathSeparator.ToString ();~\\
\cellcolor{green} & 1 & \verb~87~ & \verb~          _models = new ConfigFile (SystemInfo.BaseDirectory + seperatorString~\\
\cellcolor{gray} &  & \verb~88~ & \verb~                                    + "Content" + seperatorString + "models.in~\\
\cellcolor{green} & 1 & \verb~89~ & \verb~        }~\\
\cellcolor{green} & 4 & \verb~90~ & \verb~        return _models;~\\
\cellcolor{green} & 4 & \verb~91~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    private static ConfigFile _models;~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~97~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Core.World}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Core.World\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash World.cs}\end{minipage} \\
\textbf{Coverage:} & 13.5\%\\
\textbf{Covered lines:} & 23\\
\textbf{Uncovered lines:} & 147\\
\textbf{Coverable lines:} & 170\\
\textbf{Total lines:} & 380\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 5 & 80 & 66.67\\
\hline
\textbf{.ctor(...)} & 2 & 0 & 0\\
\hline
\textbf{DefaultEffect(...)} & 1 & 0 & 0\\
\hline
\textbf{Add(...)} & 2 & 0 & 0\\
\hline
\textbf{Remove(...)} & 2 & 0 & 0\\
\hline
\textbf{Update(...)} & 4 & 0 & 0\\
\hline
\textbf{Draw(...)} & 3 & 0 & 0\\
\hline
\textbf{System.Collections.I} & 1 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 8 & 0 & 0\\
\hline
\textbf{MoveNext()} & 7 & 0 & 0\\
\hline
\textbf{MoveNext()} & 9 & 0 & 0\\
\hline
\textbf{MoveNext()} & 9 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Core\textbackslash World.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Core~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Repräsentiert eine Spielwelt, in der sich 3D-Modelle befinden und gezeic~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public sealed class World : DrawableGameScreenComponent, IEnumerable<IGameOb~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// Die Kamera dieser Spielwelt.~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    public Camera Camera~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    {~\\
\cellcolor{green} & 15 & \verb~68~ & \verb~      get {~\\
\cellcolor{green} & 15 & \verb~69~ & \verb~        return _camera;~\\
\cellcolor{green} & 15 & \verb~70~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~        _camera = value;~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~        useInternalCamera = false;~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    private Camera _camera;~\\
\cellcolor{green} & 4 & \verb~78~ & \verb~    private bool useInternalCamera = true;~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// Die Liste von Spielobjekten.~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~83~ & \verb~    public HashSet<IGameObject> Objects { get; set; }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    private IGameObject _selectedObject;~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// Das aktuell ausgewählte Spielobjekt.~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    public IGameObject SelectedObject~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~        return _selectedObject;~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~        if (_selectedObject != value) {~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~          _selectedObject = value;~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~          SelectionChanged (_selectedObject);~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~          Redraw = true;~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    public float SelectedObjectDistance~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~        if (SelectedObject != null) {~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~          Vector3 toTarget = SelectedObject.Center () - Camera.Position;~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~          return toTarget.Length ();~\\
\cellcolor{gray} &  & \verb~110~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~          return 0;~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// Der aktuell angewendete Rendereffekt.~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~120~ & \verb~    public IRenderEffect CurrentEffect { get; set; }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    /// Wird ausgelöst, wenn das selektierte Spielobjekt geändert wurde.~\\
\cellcolor{gray} &  & \verb~124~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~125~ & \verb~    public Action<IGameObject> SelectionChanged = (o) => {};~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    /// Gibt an, ob die Spielwelt im folgenden Frame neugezeichnet wird~\\
\cellcolor{gray} &  & \verb~129~ & \verb~    /// oder nur der letzte Frame wiedergegeben wird.~\\
\cellcolor{gray} &  & \verb~130~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~    public bool Redraw { get; set; }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    /// Wird ausgelöst, wenn die Spielwelt neu gezeichnet wird.~\\
\cellcolor{gray} &  & \verb~135~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~136~ & \verb~    public Action OnRedraw = () => {};~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~139~ & \verb~    /// Die Ausmaße der Welt auf dem Screen.~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~141~ & \verb~    public Bounds Bounds { get; private set; }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~148~ & \verb~    /// Erstellt eine neue Spielwelt im angegebenen Spielzustand.~\\
\cellcolor{gray} &  & \verb~149~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~150~ & \verb~    public World (IGameScreen screen, DisplayLayer drawIndex, IRenderEffect ef~\\
\cellcolor{gray} &  & \verb~151~ & \verb~    : base (screen, drawIndex)~\\
\cellcolor{green} & 4 & \verb~152~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~153~ & \verb~      // die Kamera für diese Spielwelt~\\
\cellcolor{green} & 4 & \verb~154~ & \verb~      _camera = new Camera (screen, this);~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~      // die Liste der Spielobjekte~\\
\cellcolor{green} & 4 & \verb~157~ & \verb~      Objects = new HashSet<IGameObject> ();~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{green} & 4 & \verb~159~ & \verb~      CurrentEffect = effect;~\\
\cellcolor{gray} &  & \verb~160~ & \verb~~\\
\cellcolor{gray} &  & \verb~161~ & \verb~      // Die relative Standard-Position und Größe~\\
\cellcolor{green} & 4 & \verb~162~ & \verb~      Bounds = bounds;~\\
\cellcolor{gray} &  & \verb~163~ & \verb~~\\
\cellcolor{green} & 4 & \verb~164~ & \verb~      if (Screen.Game != null) {~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~        Screen.Game.FullScreenChanged += () => viewportCache.Clear ();~\\
\cellcolor{red} & 0 & \verb~166~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~167~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~168~ & \verb~~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~    public World (IGameScreen screen, DisplayLayer drawIndex, Bounds bounds)~\\
\cellcolor{gray} &  & \verb~170~ & \verb~    : this (screen, drawIndex, DefaultEffect (screen), bounds)~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~      RenderEffectLibrary.RenderEffectChanged += (newEffectName, time) => {~\\
\cellcolor{red} & 0 & \verb~173~ & \verb~        CurrentEffect = RenderEffectLibrary.CreateEffect (screen: screen, name~\\
\cellcolor{gray} &  & \verb~174~ & \verb~      };~\\
\cellcolor{red} & 0 & \verb~175~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~    private static IRenderEffect DefaultEffect (IGameScreen screen)~\\
\cellcolor{red} & 0 & \verb~178~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~179~ & \verb~      // suche den eingestellten Standardeffekt heraus~\\
\cellcolor{red} & 0 & \verb~180~ & \verb~      string effectName = Options.Default ["video", "knot-shader", "default"];~\\
\cellcolor{red} & 0 & \verb~181~ & \verb~      IRenderEffect effect = RenderEffectLibrary.CreateEffect (screen: screen,~\\
\cellcolor{red} & 0 & \verb~182~ & \verb~      return effect;~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~184~ & \verb~~\\
\cellcolor{gray} &  & \verb~185~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{gray} &  & \verb~187~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~188~ & \verb~~\\
\cellcolor{gray} &  & \verb~189~ & \verb~    public void Add (IGameObject obj)~\\
\cellcolor{red} & 0 & \verb~190~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~      if (obj != null) {~\\
\cellcolor{red} & 0 & \verb~192~ & \verb~        Objects.Add (obj);~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~        obj.World = this;~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~      Redraw = true;~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & \verb~    public void Remove (IGameObject obj)~\\
\cellcolor{red} & 0 & \verb~199~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~200~ & \verb~      if (obj != null) {~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~        Objects.Remove (obj);~\\
\cellcolor{red} & 0 & \verb~202~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~203~ & \verb~      Redraw = true;~\\
\cellcolor{red} & 0 & \verb~204~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~207~ & \verb~    /// Ruft auf allen Spielobjekten die Update ()-Methode auf.~\\
\cellcolor{gray} &  & \verb~208~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~209~ & \verb~    public override void Update (GameTime time)~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~211~ & \verb~      if (!Options.Default ["video", "selectiveRendering", false]) {~\\
\cellcolor{red} & 0 & \verb~212~ & \verb~        Redraw = true;~\\
\cellcolor{red} & 0 & \verb~213~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~214~ & \verb~      if (Screen.PostProcessingEffect is FadeEffect) {~\\
\cellcolor{red} & 0 & \verb~215~ & \verb~        Redraw = true;~\\
\cellcolor{red} & 0 & \verb~216~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~217~ & \verb~~\\
\cellcolor{gray} &  & \verb~218~ & \verb~      // run the update method on all game objects~\\
\cellcolor{red} & 0 & \verb~219~ & \verb~      foreach (IGameObject obj in Objects) {~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~        obj.Update (time);~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~222~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~223~ & \verb~~\\
\cellcolor{green} & 4 & \verb~224~ & \verb~    private Dictionary<Point,Dictionary<Vector4, Viewport>> viewportCache~\\
\cellcolor{gray} &  & \verb~225~ & \verb~        = new Dictionary<Point,Dictionary<Vector4, Viewport>> ();~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & \verb~    public Viewport Viewport~\\
\cellcolor{gray} &  & \verb~228~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~229~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~230~ & \verb~        // when we have a graphics device~\\
\cellcolor{green} & 6 & \verb~231~ & \verb~        if (Screen.Device != null) {~\\
\cellcolor{red} & 0 & \verb~232~ & \verb~          PresentationParameters pp = Screen.Device.PresentationParameters;~\\
\cellcolor{red} & 0 & \verb~233~ & \verb~          Point resolution = new Point (pp.BackBufferWidth, pp.BackBufferHeigh~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~          Vector4 key = Bounds.Vector4;~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~          if (!viewportCache.ContainsKey (resolution)) {~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~            viewportCache [resolution] = new Dictionary<Vector4, Viewport> ();~\\
\cellcolor{red} & 0 & \verb~237~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~238~ & \verb~          if (!viewportCache [resolution].ContainsKey (key)) {~\\
\cellcolor{red} & 0 & \verb~239~ & \verb~            Rectangle subScreen = Bounds.Rectangle;~\\
\cellcolor{red} & 0 & \verb~240~ & \verb~            viewportCache [resolution] [key] = new Viewport (subScreen.X, subS~\\
\cellcolor{gray} &  & \verb~241~ & \verb~              MinDepth = 0,~\\
\cellcolor{gray} &  & \verb~242~ & \verb~              MaxDepth = 1~\\
\cellcolor{gray} &  & \verb~243~ & \verb~            };~\\
\cellcolor{red} & 0 & \verb~244~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~245~ & \verb~          return viewportCache [resolution] [key];~\\
\cellcolor{gray} &  & \verb~246~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~247~ & \verb~        // for unit tests~\\
\cellcolor{green} & 6 & \verb~248~ & \verb~        else {~\\
\cellcolor{green} & 6 & \verb~249~ & \verb~          return Screen.Viewport;~\\
\cellcolor{gray} &  & \verb~250~ & \verb~        }~\\
\cellcolor{green} & 6 & \verb~251~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~252~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~253~ & \verb~~\\
\cellcolor{gray} &  & \verb~254~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~255~ & \verb~    /// Ruft auf allen Spielobjekten die Draw ()-Methode auf.~\\
\cellcolor{gray} &  & \verb~256~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~257~ & \verb~    public override void Draw (GameTime time)~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~259~ & \verb~      if (Redraw) {~\\
\cellcolor{red} & 0 & \verb~260~ & \verb~        OnRedraw ();~\\
\cellcolor{red} & 0 & \verb~261~ & \verb~        Redraw = false;~\\
\cellcolor{gray} &  & \verb~262~ & \verb~~\\
\cellcolor{gray} &  & \verb~263~ & \verb~        //Screen.BackgroundColor = CurrentEffect is CelShadingEffect ? Color.C~\\
\cellcolor{gray} &  & \verb~264~ & \verb~~\\
\cellcolor{gray} &  & \verb~265~ & \verb~        // begin the knot render effect~\\
\cellcolor{red} & 0 & \verb~266~ & \verb~        CurrentEffect.Begin (time);~\\
\cellcolor{gray} &  & \verb~267~ & \verb~~\\
\cellcolor{red} & 0 & \verb~268~ & \verb~        foreach (IGameObject obj in Objects) {~\\
\cellcolor{red} & 0 & \verb~269~ & \verb~          obj.World = this;~\\
\cellcolor{red} & 0 & \verb~270~ & \verb~          obj.Draw (time);~\\
\cellcolor{red} & 0 & \verb~271~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~272~ & \verb~~\\
\cellcolor{gray} &  & \verb~273~ & \verb~        // end of the knot render effect~\\
\cellcolor{red} & 0 & \verb~274~ & \verb~        CurrentEffect.End (time);~\\
\cellcolor{red} & 0 & \verb~275~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~276~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~277~ & \verb~        CurrentEffect.DrawLastFrame (time);~\\
\cellcolor{red} & 0 & \verb~278~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~279~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~280~ & \verb~~\\
\cellcolor{gray} &  & \verb~281~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~282~ & \verb~    /// Liefert einen Enumerator über die Spielobjekte dieser Spielwelt.~\\
\cellcolor{gray} &  & \verb~283~ & \verb~    /// [returntype=IEnumerator<IGameObject>]~\\
\cellcolor{gray} &  & \verb~284~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~285~ & \verb~    public IEnumerator<IGameObject> GetEnumerator ()~\\
\cellcolor{red} & 0 & \verb~286~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~287~ & \verb~      foreach (IGameObject obj in flat (Objects)) {~\\
\cellcolor{red} & 0 & \verb~288~ & \verb~        yield return obj;~\\
\cellcolor{red} & 0 & \verb~289~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~290~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~291~ & \verb~~\\
\cellcolor{gray} &  & \verb~292~ & \verb~    private IEnumerable<IGameObject> flat (IEnumerable<IGameObject> enumerable~\\
\cellcolor{red} & 0 & \verb~293~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~294~ & \verb~      foreach (IGameObject obj in enumerable) {~\\
\cellcolor{red} & 0 & \verb~295~ & \verb~        if (obj is IEnumerable<IGameObject>) {~\\
\cellcolor{red} & 0 & \verb~296~ & \verb~          foreach (IGameObject subobj in flat (obj as IEnumerable<IGameObject>~\\
\cellcolor{red} & 0 & \verb~297~ & \verb~            yield return subobj;~\\
\cellcolor{red} & 0 & \verb~298~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~299~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~300~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~301~ & \verb~          yield return obj;~\\
\cellcolor{red} & 0 & \verb~302~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~303~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~304~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~305~ & \verb~    // Explicit interface implementation for nongeneric interface~\\
\cellcolor{gray} &  & \verb~306~ & \verb~    IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{red} & 0 & \verb~307~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~308~ & \verb~      return GetEnumerator (); // Just return the generic version~\\
\cellcolor{red} & 0 & \verb~309~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~310~ & \verb~~\\
\cellcolor{gray} &  & \verb~311~ & \verb~    public override IEnumerable<IGameScreenComponent> SubComponents (GameTime ~\\
\cellcolor{red} & 0 & \verb~312~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~313~ & \verb~      foreach (DrawableGameScreenComponent component in base.SubComponents (ti~\\
\cellcolor{red} & 0 & \verb~314~ & \verb~        yield return component;~\\
\cellcolor{red} & 0 & \verb~315~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~316~ & \verb~      if (useInternalCamera) {~\\
\cellcolor{red} & 0 & \verb~317~ & \verb~        yield return Camera;~\\
\cellcolor{red} & 0 & \verb~318~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~319~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~320~ & \verb~~\\
\cellcolor{gray} &  & \verb~321~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~322~ & \verb~    /// Gibt einen Iterator über alle Spielobjekte zurück, der so sortiert ist~\\
\cellcolor{gray} &  & \verb~323~ & \verb~    /// Spielobjekte, die der angegebenen 2D-Position am nächsten sind, am Anf~\\
\cellcolor{gray} &  & \verb~324~ & \verb~    /// Dazu wird die 2D-Position in eine 3D-Position konvertiert.~\\
\cellcolor{gray} &  & \verb~325~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~326~ & \verb~    public IEnumerable<IGameObject> FindNearestObjects (Vector2 nearTo)~\\
\cellcolor{red} & 0 & \verb~327~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~328~ & \verb~      Dictionary<float, IGameObject> distances = new Dictionary<float, IGameOb~\\
\cellcolor{red} & 0 & \verb~329~ & \verb~      foreach (IGameObject obj in this) {~\\
\cellcolor{red} & 0 & \verb~330~ & \verb~        if (obj.Info.IsSelectable) {~\\
\cellcolor{gray} &  & \verb~331~ & \verb~          // Berechne aus der angegebenen 2D-Position eine 3D-Position~\\
\cellcolor{red} & 0 & \verb~332~ & \verb~          Vector3 position3D = Camera.To3D (~\\
\cellcolor{gray} &  & \verb~333~ & \verb~                                   position: nearTo,~\\
\cellcolor{gray} &  & \verb~334~ & \verb~                                   nearTo: obj.Center ()~\\
\cellcolor{gray} &  & \verb~335~ & \verb~                               );~\\
\cellcolor{gray} &  & \verb~336~ & \verb~          // Berechne die Distanz zwischen 3D-Mausposition und dem Spielobjekt~\\
\cellcolor{red} & 0 & \verb~337~ & \verb~          float distance = Math.Abs ((position3D - obj.Center ()).Length ());~\\
\cellcolor{red} & 0 & \verb~338~ & \verb~          distances [distance] = obj;~\\
\cellcolor{red} & 0 & \verb~339~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~340~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~341~ & \verb~      if (distances.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~342~ & \verb~        IEnumerable<float> sorted = distances.Keys.OrderBy (k => k);~\\
\cellcolor{red} & 0 & \verb~343~ & \verb~        foreach (float where in sorted) {~\\
\cellcolor{red} & 0 & \verb~344~ & \verb~          yield return distances [where];~\\
\cellcolor{gray} &  & \verb~345~ & \verb~          // Log.Debug ("where=", where, " = ", distances [where].Center ());~\\
\cellcolor{red} & 0 & \verb~346~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~347~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~348~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~349~ & \verb~        yield break;~\\
\cellcolor{gray} &  & \verb~350~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~351~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~352~ & \verb~~\\
\cellcolor{gray} &  & \verb~353~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~354~ & \verb~    /// Gibt einen Iterator über alle Spielobjekte zurück, der so sortiert ist~\\
\cellcolor{gray} &  & \verb~355~ & \verb~    /// Spielobjekte, die der angegebenen 3D-Position am nächsten sind, am Anf~\\
\cellcolor{gray} &  & \verb~356~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~357~ & \verb~    public IEnumerable<IGameObject> FindNearestObjects (Vector3 nearTo)~\\
\cellcolor{red} & 0 & \verb~358~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~359~ & \verb~      Dictionary<float, IGameObject> distances = new Dictionary<float, IGameOb~\\
\cellcolor{red} & 0 & \verb~360~ & \verb~      foreach (IGameObject obj in this) {~\\
\cellcolor{red} & 0 & \verb~361~ & \verb~        if (obj.Info.IsSelectable) {~\\
\cellcolor{gray} &  & \verb~362~ & \verb~          // Berechne die Distanz zwischen 3D-Mausposition und dem Spielobjekt~\\
\cellcolor{red} & 0 & \verb~363~ & \verb~          float distance = Math.Abs ((nearTo - obj.Center ()).Length ());~\\
\cellcolor{red} & 0 & \verb~364~ & \verb~          distances [distance] = obj;~\\
\cellcolor{red} & 0 & \verb~365~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~366~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~367~ & \verb~      if (distances.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~368~ & \verb~        IEnumerable<float> sorted = distances.Keys.OrderBy (k => k);~\\
\cellcolor{red} & 0 & \verb~369~ & \verb~        foreach (float where in sorted) {~\\
\cellcolor{red} & 0 & \verb~370~ & \verb~          yield return distances [where];~\\
\cellcolor{red} & 0 & \verb~371~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~372~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~373~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~374~ & \verb~        yield break;~\\
\cellcolor{gray} &  & \verb~375~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~376~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~377~ & \verb~~\\
\cellcolor{gray} &  & \verb~378~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~379~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~380~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.Challenge}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.Challenge\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Challenge.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 20\\
\textbf{Coverable lines:} & 20\\
\textbf{Total lines:} & 135\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{AddToHighscore(...)} & 1 & 0 & 0\\
\hline
\textbf{Save()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Challenge.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Ein Objekt dieser Klasse repräsentiert eine Challenge.~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public sealed class Challenge~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// Der Ausgangsknoten, den der Spieler in den Referenzknoten transformier~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~    public Knot Start { get; private set; }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Der Referenzknoten, in den der Spieler den Ausgangsknoten transformier~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    public Knot Target { get; private set; }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// Eine sortierte Bestenliste.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~    private SortedList<int, string> highscore { get; set; }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// Ein öffentlicher Enumerator, der die Bestenliste unabhängig von der da~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~    public IEnumerable<KeyValuePair<string, int>> Highscore { get { return Met~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// Die Metadaten der Challenge.~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~    public ChallengeMetaData MetaData { get; private set; }~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    /// Der Name der Challenge.~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    public string Name~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~      get { return MetaData.Name; }~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~      set { MetaData.Name = value; }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// Erstellt ein Challenge-Objekt aus einem gegebenen Challenge-Metadaten-~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    /// Erstellt ein Challenge-Objekt aus einer gegebenen Challenge-Datei.~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~    public Challenge (ChallengeMetaData meta, Knot start, Knot target)~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~      MetaData = meta;~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~      Start = start;~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~      Target = target;~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~113~ & \verb~~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    /// Fügt eine neue Bestzeit eines bestimmten Spielers in die Bestenliste e~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    public void AddToHighscore (string name, int time)~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~      MetaData.AddToHighscore (name, time);~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~      Save ();~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    /// Speichert die Challenge.~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    public void Save ()~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~      MetaData.Format.Save (this);~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~134~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.ChallengeFileIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.ChallengeFileIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash ChallengeFileIO.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 95\\
\textbf{Coverable lines:} & 95\\
\textbf{Total lines:} & 261\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 1 & 0 & 0\\
\hline
\textbf{Save(...)} & 2 & 0 & 0\\
\hline
\textbf{Load(...)} & 9 & 0 & 0\\
\hline
\textbf{LoadMetaData(...)} & 11 & 0 & 0\\
\hline
\textbf{MoveNext()} & 8 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 7 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash ChallengeFileIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Ionic.Zip;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~60~ & \verb~{~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  /// Implementiert das Speicherformat für Challenges.~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  public sealed class ChallengeFileIO : IChallengeIO~\\
\cellcolor{gray} &  & \verb~65~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Die für eine Knoten-Datei gültigen Dateiendungen.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    public IEnumerable<string> FileExtensions~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~        yield return ".challenge";~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~        yield return ".chl";~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~        yield return ".chn";~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~        yield return ".chg";~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~        yield return ".chlng";~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// Erstellt ein ChallengeFileIO-Objekt.~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~    public ChallengeFileIO ()~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// Speichert eine Challenge in dem Dateinamen, der in dem Challenge-Objek~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    public void Save (Challenge challenge)~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~      using (ZipFile zip = new ZipFile ()) {~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        // Namen~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~        zip.AddEntry ("name.txt", challenge.Name);~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        // Startknoten~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~        KnotStringIO parser = new KnotStringIO (challenge.Start);~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~        zip.AddEntry ("start.knot", parser.Content);~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        // Zielknoten~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~        parser = new KnotStringIO (challenge.Target);~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~        zip.AddEntry ("target.knot", parser.Content);~\\
\cellcolor{gray} &  & \verb~111~ & \verb~        // Highscore~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~        zip.AddEntry ("highscore.txt", string.Join ("\n", printHighscore (chal~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        // ZIP-Datei speichern~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~        zip.Save (challenge.MetaData.Filename);~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    /// Lädt eine Challenge aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    public Challenge Load (string filename)~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~      ChallengeMetaData meta = LoadMetaData (filename: filename);~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~      Knot start = null;~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~      Knot target = null;~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~      using (ZipFile zip = ZipFile.Read (filename)) {~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~        foreach (ZipEntry entry in zip) {~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~          string content = entry.ReadContent ();~\\
\cellcolor{gray} &  & \verb~130~ & \verb~~\\
\cellcolor{gray} &  & \verb~131~ & \verb~          // für die Datei mit dem Startknoten~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~          if (entry.FileName.ToLower ().Contains ("start")) {~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~            start = new Knot (~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~                new KnotMetaData (parser.Name, () => parser.CountEdges, null, ~\\
\cellcolor{gray} &  & \verb~136~ & \verb~                parser.Edges~\\
\cellcolor{gray} &  & \verb~137~ & \verb~            );~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~          // für die Datei mit dem Zielknoten~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~          else if (entry.FileName.ToLower ().Contains ("target")) {~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~            target = new Knot (~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~                new KnotMetaData (parser.Name, () => parser.CountEdges, null, ~\\
\cellcolor{gray} &  & \verb~145~ & \verb~                parser.Edges~\\
\cellcolor{gray} &  & \verb~146~ & \verb~            );~\\
\cellcolor{red} & 0 & \verb~147~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{red} & 0 & \verb~151~ & \verb~      if (meta != null && start != null && target != null) {~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~        return new Challenge (meta, start, target);~\\
\cellcolor{gray} &  & \verb~153~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~155~ & \verb~        throw new IOException (~\\
\cellcolor{gray} &  & \verb~156~ & \verb~            "Error! Invalid challenge file: " + filename~\\
\cellcolor{gray} &  & \verb~157~ & \verb~            + " (meta=" + meta + ",start=" + start + ",target=" + target + ")"~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~159~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~160~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~161~ & \verb~~\\
\cellcolor{gray} &  & \verb~162~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~163~ & \verb~    /// Lädt die Metadaten einer Challenge aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~164~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public ChallengeMetaData LoadMetaData (string filename)~\\
\cellcolor{red} & 0 & \verb~166~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~      string name = null;~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~      KnotMetaData start = null;~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~      KnotMetaData target = null;~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~      IEnumerable<KeyValuePair<string, int>> highscore = null;~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~      using (ZipFile zip = ZipFile.Read (filename)) {~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~        foreach (ZipEntry entry in zip) {~\\
\cellcolor{red} & 0 & \verb~173~ & \verb~          string content = entry.ReadContent ();~\\
\cellcolor{gray} &  & \verb~174~ & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & \verb~          // für die Datei mit dem Startknoten~\\
\cellcolor{red} & 0 & \verb~176~ & \verb~          if (entry.FileName.ToLower ().Contains ("start")) {~\\
\cellcolor{red} & 0 & \verb~177~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{red} & 0 & \verb~178~ & \verb~            start = new KnotMetaData (parser.Name, () => parser.CountEdges, nu~\\
\cellcolor{red} & 0 & \verb~179~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~          // für die Datei mit dem Zielknoten~\\
\cellcolor{red} & 0 & \verb~182~ & \verb~          else if (entry.FileName.ToLower ().Contains ("target")) {~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~            target = new KnotMetaData (parser.Name, () => parser.CountEdges, n~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{gray} &  & \verb~187~ & \verb~          // für die Datei mit dem Namen~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~          else if (entry.FileName.ToLower ().Contains ("name")) {~\\
\cellcolor{red} & 0 & \verb~189~ & \verb~            name = content.Trim ();~\\
\cellcolor{red} & 0 & \verb~190~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & \verb~          // für die Datei mit den Highscores~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~          else if (entry.FileName.ToLower ().Contains ("highscore")) {~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~            highscore = parseHighscore (content.Split (new char[] {'\r','\n'},~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~197~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~198~ & \verb~      if (name != null && start != null && target != null) {~\\
\cellcolor{red} & 0 & \verb~199~ & \verb~        Log.Debug ("Load challenge file: ", filename, " (name=", name, ",start~\\
\cellcolor{red} & 0 & \verb~200~ & \verb~        return new ChallengeMetaData (~\\
\cellcolor{gray} &  & \verb~201~ & \verb~                   name: name,~\\
\cellcolor{gray} &  & \verb~202~ & \verb~                   start: start,~\\
\cellcolor{gray} &  & \verb~203~ & \verb~                   target: target,~\\
\cellcolor{gray} &  & \verb~204~ & \verb~                   filename: filename,~\\
\cellcolor{gray} &  & \verb~205~ & \verb~                   format: this,~\\
\cellcolor{gray} &  & \verb~206~ & \verb~                   highscore: highscore~\\
\cellcolor{gray} &  & \verb~207~ & \verb~               );~\\
\cellcolor{gray} &  & \verb~208~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~209~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~        throw new IOException (~\\
\cellcolor{gray} &  & \verb~211~ & \verb~            "Error! Invalid challenge file: " + filename~\\
\cellcolor{gray} &  & \verb~212~ & \verb~            + " (name=" + name + ",start=" + start + ",target=" + target + ",h~\\
\cellcolor{gray} &  & \verb~213~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~214~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~215~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~216~ & \verb~~\\
\cellcolor{gray} &  & \verb~217~ & \verb~    IEnumerable<string> printHighscore (IEnumerable<KeyValuePair<string, int>>~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~219~ & \verb~      foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~        Log.Debug (~\\
\cellcolor{gray} &  & \verb~221~ & \verb~            "Save Highscore: "~\\
\cellcolor{gray} &  & \verb~222~ & \verb~            + entry.Value.ToString ()~\\
\cellcolor{gray} &  & \verb~223~ & \verb~            + ":"~\\
\cellcolor{gray} &  & \verb~224~ & \verb~            + entry.Key.ToString ()~\\
\cellcolor{gray} &  & \verb~225~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{red} & 0 & \verb~227~ & \verb~        yield return entry.Value + ":" + entry.Key;~\\
\cellcolor{red} & 0 & \verb~228~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~229~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & \verb~    IEnumerable<KeyValuePair<string, int>> parseHighscore (IEnumerable<string>~\\
\cellcolor{red} & 0 & \verb~232~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~233~ & \verb~      foreach (string line in highscore) {~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~        Log.Debug ("Load Highscore: ",line);~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~        if (line.Contains (":")) {~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~          string[] entry = line.Split (new char[] {':'}, 2, StringSplitOptions~\\
\cellcolor{red} & 0 & \verb~237~ & \verb~          string name = entry [1].Trim ();~\\
\cellcolor{gray} &  & \verb~238~ & \verb~          int time;~\\
\cellcolor{red} & 0 & \verb~239~ & \verb~          if (Int32.TryParse (entry [0], out time)) {~\\
\cellcolor{red} & 0 & \verb~240~ & \verb~            Log.Debug ("=> ", name, ":", time);~\\
\cellcolor{red} & 0 & \verb~241~ & \verb~            yield return new KeyValuePair<string, int> (name, time);~\\
\cellcolor{red} & 0 & \verb~242~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~243~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~244~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~245~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~246~ & \verb~~\\
\cellcolor{gray} &  & \verb~247~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~248~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~249~ & \verb~~\\
\cellcolor{gray} &  & \verb~250~ & \verb~  static class ZipHelper~\\
\cellcolor{gray} &  & \verb~251~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~252~ & \verb~    public static string ReadContent (this ZipEntry entry)~\\
\cellcolor{gray} &  & \verb~253~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~254~ & \verb~      MemoryStream memory = new MemoryStream ();~\\
\cellcolor{gray} &  & \verb~255~ & \verb~      entry.Extract (memory);~\\
\cellcolor{gray} &  & \verb~256~ & \verb~      memory.Position = 0;~\\
\cellcolor{gray} &  & \verb~257~ & \verb~      var sr = new StreamReader (memory);~\\
\cellcolor{gray} &  & \verb~258~ & \verb~      return sr.ReadToEnd ();~\\
\cellcolor{gray} &  & \verb~259~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~260~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~261~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.ChallengeMetaData}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.ChallengeMetaData\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash ChallengeMetaData.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 85\\
\textbf{Coverable lines:} & 85\\
\textbf{Total lines:} & 240\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 6 & 0 & 0\\
\hline
\textbf{AddToHighscore(...)} & 2 & 0 & 0\\
\hline
\textbf{formatTime(...)} & 1 & 0 & 0\\
\hline
\textbf{Equals(...)} & 2 & 0 & 0\\
\hline
\textbf{Equals(...)} & 2 & 0 & 0\\
\hline
\textbf{GetHashCode()} & 2 & 0 & 0\\
\hline
\textbf{op\_Equality(...)} & 4 & 0 & 0\\
\hline
\textbf{op\_Inequality(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash ChallengeMetaData.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Platform;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// Enthält Metadaten zu einer Challenge.~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  public class ChallengeMetaData~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Der Name der Challenge.~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    public string Name~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~        return name;~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~        name = value;~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~        if (Format == null) {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~          Format = new ChallengeFileIO ();~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        string extension;~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~        if (Format.FileExtensions.Any ()) {~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~          extension = Format.FileExtensions.ElementAt (0);~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~          throw new ArgumentException ("Every implementation of IChallengeIO m~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~        Filename = SystemInfo.SavegameDirectory + SystemInfo.PathSeparator.ToS~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    private string name;~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// Der Ausgangsknoten, den der Spieler in den Referenzknoten transformier~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~    public KnotMetaData Start { get; private set; }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// Der Referenzknoten, in den der Spieler den Ausgangsknoten transformier~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~    public KnotMetaData Target { get; private set; }~\\
\cellcolor{gray} &  & \verb~101~ & \verb~~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    /// Das Format, aus dem die Metadaten der Challenge gelesen wurden oder nu~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~    public IChallengeIO Format { get; private set; }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    /// Der Dateiname, aus dem die Metadaten der Challenge gelesen wurden oder~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~    public string Filename { get; private set; }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    /// Ein öffentlicher Enumerator, der die Bestenliste unabhängig von der da~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~    public IEnumerable<KeyValuePair<string, int>> Highscore { get { return hig~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    private List<KeyValuePair<string, int>> highscore;~\\
\cellcolor{gray} &  & \verb~118~ & \verb~~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    public float AvgTime~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~        if (   highscore != null~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~                && highscore.Any ()) {~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~          float amount =0;~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~          foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~            amount += (float)entry.Value;~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~          return amount/((float)highscore.Count);~\\
\cellcolor{gray} &  & \verb~129~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~        return 0f;~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~      private set {}~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & \verb~    public string FormatedAvgTime~\\
\cellcolor{gray} &  & \verb~137~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~        float time = AvgTime;~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~        Log.Debug (time);~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~        if (time != 0f) {~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~          return formatTime (time);~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~        return "Not yet set.";~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~146~ & \verb~      private set {~\\
\cellcolor{red} & 0 & \verb~147~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~149~ & \verb~~\\
\cellcolor{gray} &  & \verb~150~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~151~ & \verb~~\\
\cellcolor{gray} &  & \verb~152~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~155~ & \verb~    /// Erstellt ein Challenge-Metadaten-Objekt mit einem gegebenen Namen und ~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~    public ChallengeMetaData (string name, KnotMetaData start, KnotMetaData ta~\\
\cellcolor{gray} &  & \verb~158~ & \verb~                              string filename, IChallengeIO format,~\\
\cellcolor{gray} &  & \verb~159~ & \verb~                              IEnumerable<KeyValuePair<string, int>> highscore~\\
\cellcolor{red} & 0 & \verb~160~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~161~ & \verb~      Name = name;~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~      Start = start;~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~      Target = target;~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~      Format = format ?? Format;~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~      Filename = filename ?? Filename;~\\
\cellcolor{gray} &  & \verb~166~ & \verb~~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~      this.highscore = new List<KeyValuePair<string, int>> ();~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~      if (highscore != null) {~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~        foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~          this.highscore.Add (entry);~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~173~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~174~ & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~178~ & \verb~~\\
\cellcolor{gray} &  & \verb~179~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~180~ & \verb~    /// Fügt eine neue Bestzeit eines bestimmten Spielers in die Bestenliste e~\\
\cellcolor{gray} &  & \verb~181~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~182~ & \verb~    public void AddToHighscore (string name, int time)~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~      KeyValuePair<string, int> entry = new KeyValuePair<string, int> (name, t~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~      if (!highscore.Contains (entry)) {~\\
\cellcolor{red} & 0 & \verb~186~ & \verb~        highscore.Add (entry);~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~189~ & \verb~~\\
\cellcolor{gray} &  & \verb~190~ & \verb~    public static string formatTime (float secs)~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~192~ & \verb~      Log.Debug (secs);~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~      TimeSpan t = TimeSpan.FromSeconds ( secs );~\\
\cellcolor{gray} &  & \verb~194~ & \verb~~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~      string answer = string.Format ("{0:D2}h:{1:D2}m:{2:D2}s",~\\
\cellcolor{gray} &  & \verb~196~ & \verb~                                     t.Hours,~\\
\cellcolor{gray} &  & \verb~197~ & \verb~                                     t.Minutes,~\\
\cellcolor{gray} &  & \verb~198~ & \verb~                                     t.Seconds);~\\
\cellcolor{red} & 0 & \verb~199~ & \verb~      return answer;~\\
\cellcolor{red} & 0 & \verb~200~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~201~ & \verb~~\\
\cellcolor{gray} &  & \verb~202~ & \verb~    public bool Equals (ChallengeMetaData other)~\\
\cellcolor{red} & 0 & \verb~203~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~204~ & \verb~      return other != null && name == other.name;~\\
\cellcolor{red} & 0 & \verb~205~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~206~ & \verb~~\\
\cellcolor{gray} &  & \verb~207~ & \verb~    public override bool Equals (object other)~\\
\cellcolor{red} & 0 & \verb~208~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~209~ & \verb~      return other != null && Equals (other as ChallengeMetaData);~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~~\\
\cellcolor{gray} &  & \verb~212~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{red} & 0 & \verb~213~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~214~ & \verb~      return (name ?? String.Empty).GetHashCode ();~\\
\cellcolor{red} & 0 & \verb~215~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~216~ & \verb~~\\
\cellcolor{gray} &  & \verb~217~ & \verb~    public static bool operator == (ChallengeMetaData a, ChallengeMetaData b)~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~219~ & \verb~      // If both are null, or both are same instance, return true.~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~222~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~223~ & \verb~~\\
\cellcolor{gray} &  & \verb~224~ & \verb~      // If one is null, but not both, return false.~\\
\cellcolor{red} & 0 & \verb~225~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{red} & 0 & \verb~226~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~227~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~228~ & \verb~~\\
\cellcolor{gray} &  & \verb~229~ & \verb~      // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~      return a.Equals (b);~\\
\cellcolor{red} & 0 & \verb~231~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~232~ & \verb~~\\
\cellcolor{gray} &  & \verb~233~ & \verb~    public static bool operator != (ChallengeMetaData a, ChallengeMetaData b)~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~      return !(a == b);~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~237~ & \verb~~\\
\cellcolor{gray} &  & \verb~238~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~239~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~240~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.CircleEntry`1}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.CircleEntry`1\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash CircleEntry.cs}\end{minipage} \\
\textbf{Coverage:} & 92.1\%\\
\textbf{Covered lines:} & 210\\
\textbf{Uncovered lines:} & 18\\
\textbf{Coverable lines:} & 228\\
\textbf{Total lines:} & 400\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor()} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 4 & 100 & 85.71\\
\hline
\textbf{InsertBefore(...)} & 1 & 100 & 100\\
\hline
\textbf{InsertAfter(...)} & 1 & 100 & 100\\
\hline
\textbf{Remove()} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Find(...)} & 1 & 100 & 100\\
\hline
\textbf{IndexOf(...)} & 1 & 100 & 100\\
\hline
\textbf{IndexOf(...)} & 3 & 92.31 & 80\\
\hline
\textbf{System.Collections.I} & 1 & 0 & 0\\
\hline
\textbf{ToString()} & 2 & 71.43 & 66.67\\
\hline
\textbf{op\_Addition(...)} & 3 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Increment(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Decrement(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Remove(...)} & 2 & 100 & 100\\
\hline
\textbf{RemoveAt(...)} & 1 & 100 & 100\\
\hline
\textbf{Insert(...)} & 1 & 0 & 0\\
\hline
\textbf{Add(...)} & 2 & 100 & 100\\
\hline
\textbf{Clear()} & 1 & 100 & 100\\
\hline
\textbf{CopyTo(...)} & 3 & 100 & 80\\
\hline
\textbf{MoveNext()} & 6 & 100 & 87.5\\
\hline
\textbf{MoveNext()} & 6 & 100 & 87.5\\
\hline
\textbf{MoveNext()} & 6 & 81.82 & 75\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 100 & 83.33\\
\hline
\textbf{MoveNext()} & 5 & 100 & 83.33\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash CircleEntry.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Eine doppelt verkettete Liste.~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public class CircleEntry<T> : IEnumerable<T>, ICollection<T>, IList<T>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    public T Value { get; set; }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    public CircleEntry<T> Next { get; set; }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    public CircleEntry<T> Previous { get; set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{green} & 1095 & \verb~67~ & \verb~    public CircleEntry (T value)~\\
\cellcolor{green} & 1095 & \verb~68~ & \verb~    {~\\
\cellcolor{green} & 1095 & \verb~69~ & \verb~      Value = value;~\\
\cellcolor{green} & 1095 & \verb~70~ & \verb~      Previous = this;~\\
\cellcolor{green} & 1095 & \verb~71~ & \verb~      Next = this;~\\
\cellcolor{green} & 1095 & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{green} & 7 & \verb~74~ & \verb~    private CircleEntry ()~\\
\cellcolor{green} & 7 & \verb~75~ & \verb~    {~\\
\cellcolor{green} & 7 & \verb~76~ & \verb~      Previous = this;~\\
\cellcolor{green} & 7 & \verb~77~ & \verb~      Next = this;~\\
\cellcolor{green} & 7 & \verb~78~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{green} & 41 & \verb~80~ & \verb~    public CircleEntry (IEnumerable<T> list)~\\
\cellcolor{green} & 41 & \verb~81~ & \verb~    {~\\
\cellcolor{green} & 41 & \verb~82~ & \verb~      bool first = true;~\\
\cellcolor{green} & 41 & \verb~83~ & \verb~      CircleEntry<T> inserted = this;~\\
\cellcolor{green} & 3384 & \verb~84~ & \verb~      foreach (T obj in list) {~\\
\cellcolor{green} & 1128 & \verb~85~ & \verb~        if (first) {~\\
\cellcolor{green} & 41 & \verb~86~ & \verb~          Value = obj;~\\
\cellcolor{green} & 41 & \verb~87~ & \verb~          Previous = this;~\\
\cellcolor{green} & 41 & \verb~88~ & \verb~          Next = this;~\\
\cellcolor{green} & 41 & \verb~89~ & \verb~        }~\\
\cellcolor{green} & 1046 & \verb~90~ & \verb~        else {~\\
\cellcolor{green} & 1046 & \verb~91~ & \verb~          inserted = inserted.InsertAfter (obj);~\\
\cellcolor{green} & 1046 & \verb~92~ & \verb~        }~\\
\cellcolor{green} & 1087 & \verb~93~ & \verb~        first = false;~\\
\cellcolor{green} & 1087 & \verb~94~ & \verb~      }~\\
\cellcolor{green} & 41 & \verb~95~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    public static CircleEntry<T> Empty~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    {~\\
\cellcolor{green} & 7 & \verb~99~ & \verb~      get {~\\
\cellcolor{green} & 7 & \verb~100~ & \verb~        return new CircleEntry<T> ();~\\
\cellcolor{green} & 7 & \verb~101~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    public CircleEntry<T> InsertBefore (T obj)~\\
\cellcolor{green} & 47 & \verb~105~ & \verb~    {~\\
\cellcolor{green} & 47 & \verb~106~ & \verb~      CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{green} & 47 & \verb~107~ & \verb~      insert.Previous = this.Previous;~\\
\cellcolor{green} & 47 & \verb~108~ & \verb~      insert.Next = this;~\\
\cellcolor{green} & 47 & \verb~109~ & \verb~      this.Previous.Next = insert;~\\
\cellcolor{green} & 47 & \verb~110~ & \verb~      this.Previous = insert;~\\
\cellcolor{green} & 47 & \verb~111~ & \verb~      return insert;~\\
\cellcolor{green} & 47 & \verb~112~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    public CircleEntry<T> InsertAfter (T obj)~\\
\cellcolor{green} & 1048 & \verb~115~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~116~ & \verb~      //Log.Debug (this, ".InsertAfter (", obj, ")");~\\
\cellcolor{green} & 1048 & \verb~117~ & \verb~      CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{green} & 1048 & \verb~118~ & \verb~      insert.Next = this.Next;~\\
\cellcolor{green} & 1048 & \verb~119~ & \verb~      insert.Previous = this;~\\
\cellcolor{green} & 1048 & \verb~120~ & \verb~      this.Next.Previous = insert;~\\
\cellcolor{green} & 1048 & \verb~121~ & \verb~      this.Next = insert;~\\
\cellcolor{green} & 1048 & \verb~122~ & \verb~      return insert;~\\
\cellcolor{green} & 1048 & \verb~123~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    public void Remove ()~\\
\cellcolor{green} & 115 & \verb~126~ & \verb~    {~\\
\cellcolor{green} & 115 & \verb~127~ & \verb~      Previous.Next = Next;~\\
\cellcolor{green} & 115 & \verb~128~ & \verb~      Next.Previous = Previous;~\\
\cellcolor{green} & 115 & \verb~129~ & \verb~      Previous = null;~\\
\cellcolor{green} & 115 & \verb~130~ & \verb~      Next = null;~\\
\cellcolor{green} & 115 & \verb~131~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    private bool IsEmpty~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    {~\\
\cellcolor{green} & 29 & \verb~135~ & \verb~      get {~\\
\cellcolor{green} & 29 & \verb~136~ & \verb~        return (Next == this || Next == null) && (Previous == this || Previous~\\
\cellcolor{green} & 29 & \verb~137~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    public int Count~\\
\cellcolor{gray} &  & \verb~141~ & \verb~    {~\\
\cellcolor{green} & 27 & \verb~142~ & \verb~      get {~\\
\cellcolor{green} & 27 & \verb~143~ & \verb~        if (IsEmpty) {~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~          return 0;~\\
\cellcolor{gray} &  & \verb~145~ & \verb~        }~\\
\cellcolor{green} & 27 & \verb~146~ & \verb~        else {~\\
\cellcolor{green} & 27 & \verb~147~ & \verb~          CircleEntry<T> current = this;~\\
\cellcolor{green} & 27 & \verb~148~ & \verb~          int count = 0;~\\
\cellcolor{green} & 244 & \verb~149~ & \verb~          do {~\\
\cellcolor{green} & 244 & \verb~150~ & \verb~            ++count;~\\
\cellcolor{green} & 244 & \verb~151~ & \verb~            current = current.Next;~\\
\cellcolor{green} & 244 & \verb~152~ & \verb~          }~\\
\cellcolor{green} & 244 & \verb~153~ & \verb~          while (current != this);~\\
\cellcolor{green} & 27 & \verb~154~ & \verb~          return count;~\\
\cellcolor{gray} &  & \verb~155~ & \verb~        }~\\
\cellcolor{green} & 27 & \verb~156~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~157~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{gray} &  & \verb~159~ & \verb~    public bool Contains (T obj, out IEnumerable<CircleEntry<T>> item)~\\
\cellcolor{green} & 199 & \verb~160~ & \verb~    {~\\
\cellcolor{green} & 199 & \verb~161~ & \verb~      item = Find (obj);~\\
\cellcolor{green} & 199 & \verb~162~ & \verb~      return item.Count () > 0;~\\
\cellcolor{green} & 199 & \verb~163~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public bool Contains (Func<T, bool> func, out IEnumerable<CircleEntry<T>> ~\\
\cellcolor{green} & 199 & \verb~166~ & \verb~    {~\\
\cellcolor{green} & 199 & \verb~167~ & \verb~      item = Find (func);~\\
\cellcolor{green} & 199 & \verb~168~ & \verb~      return item.Count () > 0;~\\
\cellcolor{green} & 199 & \verb~169~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~    public bool Contains (T obj, out CircleEntry<T> item)~\\
\cellcolor{green} & 301 & \verb~172~ & \verb~    {~\\
\cellcolor{green} & 301 & \verb~173~ & \verb~      item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{green} & 301 & \verb~174~ & \verb~      return item != null;~\\
\cellcolor{green} & 301 & \verb~175~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~    public bool Contains (Func<T, bool> func, out CircleEntry<T> item)~\\
\cellcolor{green} & 100 & \verb~178~ & \verb~    {~\\
\cellcolor{green} & 100 & \verb~179~ & \verb~      item = Find (func).ElementAtOrDefault (0);~\\
\cellcolor{green} & 100 & \verb~180~ & \verb~      return item != null;~\\
\cellcolor{green} & 100 & \verb~181~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~182~ & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & \verb~    public IEnumerable<CircleEntry<T>> Find (T obj)~\\
\cellcolor{green} & 707 & \verb~184~ & \verb~    {~\\
\cellcolor{green} & 27279 & \verb~185~ & \verb~      return Find ((t) => t.Equals (obj));~\\
\cellcolor{green} & 707 & \verb~186~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~187~ & \verb~~\\
\cellcolor{gray} &  & \verb~188~ & \verb~    public IEnumerable<CircleEntry<T>> Find (Func<T, bool> func)~\\
\cellcolor{green} & 1909 & \verb~189~ & \verb~    {~\\
\cellcolor{green} & 1909 & \verb~190~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{green} & 52516 & \verb~191~ & \verb~      do {~\\
\cellcolor{green} & 53929 & \verb~192~ & \verb~        if (func (current.Value)) {~\\
\cellcolor{green} & 1413 & \verb~193~ & \verb~          yield return current;~\\
\cellcolor{green} & 600 & \verb~194~ & \verb~        }~\\
\cellcolor{green} & 51703 & \verb~195~ & \verb~        current = current.Next;~\\
\cellcolor{green} & 51703 & \verb~196~ & \verb~      }~\\
\cellcolor{green} & 51703 & \verb~197~ & \verb~      while (current != this);~\\
\cellcolor{green} & 1096 & \verb~198~ & \verb~      yield break;~\\
\cellcolor{gray} &  & \verb~199~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~200~ & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & \verb~    public int IndexOf (T obj)~\\
\cellcolor{green} & 100 & \verb~202~ & \verb~    {~\\
\cellcolor{green} & 5150 & \verb~203~ & \verb~      return IndexOf ((t) => t.Equals (obj));~\\
\cellcolor{green} & 100 & \verb~204~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~    public int IndexOf (Func<T, bool> func)~\\
\cellcolor{green} & 200 & \verb~207~ & \verb~    {~\\
\cellcolor{green} & 200 & \verb~208~ & \verb~      int i = 0;~\\
\cellcolor{green} & 200 & \verb~209~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{green} & 10100 & \verb~210~ & \verb~      do {~\\
\cellcolor{green} & 10300 & \verb~211~ & \verb~        if (func (current.Value)) {~\\
\cellcolor{green} & 200 & \verb~212~ & \verb~          return i;~\\
\cellcolor{gray} &  & \verb~213~ & \verb~        }~\\
\cellcolor{green} & 9900 & \verb~214~ & \verb~        current = current.Next;~\\
\cellcolor{green} & 9900 & \verb~215~ & \verb~        ++ i;~\\
\cellcolor{green} & 9900 & \verb~216~ & \verb~      }~\\
\cellcolor{green} & 9900 & \verb~217~ & \verb~      while (current != this);~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~      return -1;~\\
\cellcolor{green} & 200 & \verb~219~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~220~ & \verb~~\\
\cellcolor{gray} &  & \verb~221~ & \verb~    public IEnumerable<T> RangeTo (CircleEntry<T> other)~\\
\cellcolor{green} & 4 & \verb~222~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~223~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{green} & 16 & \verb~224~ & \verb~      do {~\\
\cellcolor{green} & 16 & \verb~225~ & \verb~        yield return current.Value;~\\
\cellcolor{green} & 16 & \verb~226~ & \verb~        current = current.Next;~\\
\cellcolor{green} & 16 & \verb~227~ & \verb~      }~\\
\cellcolor{green} & 16 & \verb~228~ & \verb~      while (current != other.Next && current != this);~\\
\cellcolor{green} & 4 & \verb~229~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & \verb~    public IEnumerable<T> WayTo (T other)~\\
\cellcolor{green} & 1 & \verb~232~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~233~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{green} & 3 & \verb~234~ & \verb~      while (!current.Value.Equals (other)) {~\\
\cellcolor{green} & 1 & \verb~235~ & \verb~        yield return current.Value;~\\
\cellcolor{green} & 1 & \verb~236~ & \verb~        current = current.Next;~\\
\cellcolor{green} & 1 & \verb~237~ & \verb~        if (current == this) {~\\
\cellcolor{red} & 0 & \verb~238~ & \verb~          break;~\\
\cellcolor{gray} &  & \verb~239~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~240~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~241~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~242~ & \verb~~\\
\cellcolor{gray} &  & \verb~243~ & \verb~    public IEnumerable<Tuple<T,T>> Pairs~\\
\cellcolor{gray} &  & \verb~244~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~245~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~246~ & \verb~        CircleEntry<T> current = this;~\\
\cellcolor{red} & 0 & \verb~247~ & \verb~        do {~\\
\cellcolor{red} & 0 & \verb~248~ & \verb~          yield return Tuple.Create (current.Value, current.Next.Value);~\\
\cellcolor{red} & 0 & \verb~249~ & \verb~          current = current.Next;~\\
\cellcolor{red} & 0 & \verb~250~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~251~ & \verb~        while (current != this);~\\
\cellcolor{red} & 0 & \verb~252~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~253~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~254~ & \verb~~\\
\cellcolor{gray} &  & \verb~255~ & \verb~    public IEnumerable<Tuple<T,T,T>> Triples~\\
\cellcolor{gray} &  & \verb~256~ & \verb~    {~\\
\cellcolor{green} & 12 & \verb~257~ & \verb~      get {~\\
\cellcolor{green} & 12 & \verb~258~ & \verb~        CircleEntry<T> current = this;~\\
\cellcolor{green} & 52 & \verb~259~ & \verb~        do {~\\
\cellcolor{green} & 52 & \verb~260~ & \verb~          yield return Tuple.Create (current.Previous.Value, current.Value, cu~\\
\cellcolor{green} & 50 & \verb~261~ & \verb~          current = current.Next;~\\
\cellcolor{green} & 50 & \verb~262~ & \verb~        }~\\
\cellcolor{green} & 50 & \verb~263~ & \verb~        while (current != this);~\\
\cellcolor{green} & 10 & \verb~264~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~265~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~266~ & \verb~~\\
\cellcolor{gray} &  & \verb~267~ & \verb~    public IEnumerator<T> GetEnumerator ()~\\
\cellcolor{green} & 91 & \verb~268~ & \verb~    {~\\
\cellcolor{green} & 91 & \verb~269~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{green} & 826 & \verb~270~ & \verb~      do {~\\
\cellcolor{gray} &  & \verb~271~ & \verb~        //Log.Debug (this, " => ", current.Content);~\\
\cellcolor{green} & 826 & \verb~272~ & \verb~        yield return current.Value;~\\
\cellcolor{green} & 818 & \verb~273~ & \verb~        current = current.Next;~\\
\cellcolor{green} & 818 & \verb~274~ & \verb~      }~\\
\cellcolor{green} & 818 & \verb~275~ & \verb~      while (current != this);~\\
\cellcolor{green} & 83 & \verb~276~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~277~ & \verb~~\\
\cellcolor{gray} &  & \verb~278~ & \verb~    // explicit interface implementation for nongeneric interface~\\
\cellcolor{gray} &  & \verb~279~ & \verb~    IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{red} & 0 & \verb~280~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~281~ & \verb~      return GetEnumerator (); // just return the generic version~\\
\cellcolor{red} & 0 & \verb~282~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~283~ & \verb~~\\
\cellcolor{gray} &  & \verb~284~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 2 & \verb~285~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~286~ & \verb~      if (IsEmpty) {~\\
\cellcolor{red} & 0 & \verb~287~ & \verb~        return "CircleEntry (" + Value.ToString () + ")";~\\
\cellcolor{gray} &  & \verb~288~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~289~ & \verb~      else {~\\
\cellcolor{green} & 2 & \verb~290~ & \verb~        return "CircleEntry.Empty";~\\
\cellcolor{gray} &  & \verb~291~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~292~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~293~ & \verb~~\\
\cellcolor{gray} &  & \verb~294~ & \verb~    public static CircleEntry<T> operator + (CircleEntry<T> circle, int i)~\\
\cellcolor{green} & 579 & \verb~295~ & \verb~    {~\\
\cellcolor{green} & 579 & \verb~296~ & \verb~      CircleEntry<T> next = circle;~\\
\cellcolor{green} & 40549 & \verb~297~ & \verb~      while (i > 0) {~\\
\cellcolor{green} & 19985 & \verb~298~ & \verb~        next = next.Next;~\\
\cellcolor{green} & 19985 & \verb~299~ & \verb~        i--;~\\
\cellcolor{green} & 19985 & \verb~300~ & \verb~      }~\\
\cellcolor{green} & 989 & \verb~301~ & \verb~      while (i < 0) {~\\
\cellcolor{green} & 205 & \verb~302~ & \verb~        next = next.Previous;~\\
\cellcolor{green} & 205 & \verb~303~ & \verb~        i++;~\\
\cellcolor{green} & 205 & \verb~304~ & \verb~      }~\\
\cellcolor{green} & 579 & \verb~305~ & \verb~      return next;~\\
\cellcolor{green} & 579 & \verb~306~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~307~ & \verb~~\\
\cellcolor{gray} &  & \verb~308~ & \verb~    public T this [int index]~\\
\cellcolor{gray} &  & \verb~309~ & \verb~    {~\\
\cellcolor{green} & 238 & \verb~310~ & \verb~      get {~\\
\cellcolor{green} & 238 & \verb~311~ & \verb~        return (this + index).Value;~\\
\cellcolor{green} & 238 & \verb~312~ & \verb~      }~\\
\cellcolor{green} & 100 & \verb~313~ & \verb~      set {~\\
\cellcolor{green} & 100 & \verb~314~ & \verb~        (this + index).Value = value;~\\
\cellcolor{green} & 100 & \verb~315~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~316~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~317~ & \verb~~\\
\cellcolor{gray} &  & \verb~318~ & \verb~    public static CircleEntry<T> operator - (CircleEntry<T> circle, int i)~\\
\cellcolor{green} & 30 & \verb~319~ & \verb~    {~\\
\cellcolor{green} & 30 & \verb~320~ & \verb~      return circle + (-i);~\\
\cellcolor{green} & 30 & \verb~321~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~322~ & \verb~~\\
\cellcolor{gray} &  & \verb~323~ & \verb~    public static CircleEntry<T> operator ++ (CircleEntry<T> circle)~\\
\cellcolor{green} & 189 & \verb~324~ & \verb~    {~\\
\cellcolor{green} & 189 & \verb~325~ & \verb~      return circle.Next;~\\
\cellcolor{green} & 189 & \verb~326~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~327~ & \verb~~\\
\cellcolor{gray} &  & \verb~328~ & \verb~    public static CircleEntry<T> operator -- (CircleEntry<T> circle)~\\
\cellcolor{green} & 11 & \verb~329~ & \verb~    {~\\
\cellcolor{green} & 11 & \verb~330~ & \verb~      return circle.Previous;~\\
\cellcolor{green} & 11 & \verb~331~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~332~ & \verb~~\\
\cellcolor{gray} &  & \verb~333~ & \verb~    public static implicit operator T (CircleEntry<T> circle)~\\
\cellcolor{green} & 700 & \verb~334~ & \verb~    {~\\
\cellcolor{green} & 700 & \verb~335~ & \verb~      return circle.Value;~\\
\cellcolor{green} & 700 & \verb~336~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~337~ & \verb~~\\
\cellcolor{green} & 3 & \verb~338~ & \verb~    public bool IsReadOnly { get { return false; } }~\\
\cellcolor{gray} &  & \verb~339~ & \verb~~\\
\cellcolor{gray} &  & \verb~340~ & \verb~    public bool Contains (T obj)~\\
\cellcolor{green} & 102 & \verb~341~ & \verb~    {~\\
\cellcolor{green} & 102 & \verb~342~ & \verb~      CircleEntry<T> item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{green} & 102 & \verb~343~ & \verb~      return item != null;~\\
\cellcolor{green} & 102 & \verb~344~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~345~ & \verb~~\\
\cellcolor{gray} &  & \verb~346~ & \verb~    public bool Remove (T value)~\\
\cellcolor{green} & 198 & \verb~347~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~348~ & \verb~      CircleEntry<T> item;~\\
\cellcolor{green} & 297 & \verb~349~ & \verb~      if (Contains (value, out item)) {~\\
\cellcolor{green} & 99 & \verb~350~ & \verb~        item.Remove ();~\\
\cellcolor{green} & 99 & \verb~351~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~352~ & \verb~      }~\\
\cellcolor{green} & 99 & \verb~353~ & \verb~      else {~\\
\cellcolor{green} & 99 & \verb~354~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~355~ & \verb~      }~\\
\cellcolor{green} & 198 & \verb~356~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~357~ & \verb~~\\
\cellcolor{gray} &  & \verb~358~ & \verb~    public void RemoveAt (int i)~\\
\cellcolor{green} & 1 & \verb~359~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~360~ & \verb~      (this + i).Remove ();~\\
\cellcolor{green} & 1 & \verb~361~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~362~ & \verb~~\\
\cellcolor{gray} &  & \verb~363~ & \verb~    public void Insert (int i, T value)~\\
\cellcolor{red} & 0 & \verb~364~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~365~ & \verb~      (this + i).InsertBefore (value);~\\
\cellcolor{red} & 0 & \verb~366~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~367~ & \verb~~\\
\cellcolor{gray} &  & \verb~368~ & \verb~    public void Add (T value)~\\
\cellcolor{green} & 50 & \verb~369~ & \verb~    {~\\
\cellcolor{green} & 56 & \verb~370~ & \verb~      if (Value == null) {~\\
\cellcolor{green} & 6 & \verb~371~ & \verb~        Value = value;~\\
\cellcolor{green} & 6 & \verb~372~ & \verb~      }~\\
\cellcolor{green} & 44 & \verb~373~ & \verb~      else {~\\
\cellcolor{green} & 44 & \verb~374~ & \verb~        InsertBefore (value);~\\
\cellcolor{green} & 44 & \verb~375~ & \verb~      }~\\
\cellcolor{green} & 50 & \verb~376~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~377~ & \verb~~\\
\cellcolor{gray} &  & \verb~378~ & \verb~    public void Clear ()~\\
\cellcolor{green} & 1 & \verb~379~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~380~ & \verb~      Remove ();~\\
\cellcolor{green} & 1 & \verb~381~ & \verb~      Next = Previous = this;~\\
\cellcolor{green} & 1 & \verb~382~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~383~ & \verb~~\\
\cellcolor{gray} &  & \verb~384~ & \verb~    public void CopyTo (T[] array, int start)~\\
\cellcolor{green} & 1 & \verb~385~ & \verb~    {~\\
\cellcolor{green} & 303 & \verb~386~ & \verb~      foreach (T value in this) {~\\
\cellcolor{green} & 100 & \verb~387~ & \verb~        array.SetValue (value, start);~\\
\cellcolor{green} & 100 & \verb~388~ & \verb~        ++start;~\\
\cellcolor{green} & 100 & \verb~389~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~390~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~391~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~392~ & \verb~~\\
\cellcolor{gray} &  & \verb~393~ & \verb~  public static class CircleExtensions~\\
\cellcolor{gray} &  & \verb~394~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~395~ & \verb~    public static CircleEntry<T> ToCircle<T> (this IEnumerable<T> enumerable)~\\
\cellcolor{gray} &  & \verb~396~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~397~ & \verb~      return new CircleEntry<T> (enumerable);~\\
\cellcolor{gray} &  & \verb~398~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~399~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~400~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.CircleExtensions}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.CircleExtensions\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash CircleEntry.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 400\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ToCircle(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash CircleEntry.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Eine doppelt verkettete Liste.~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public class CircleEntry<T> : IEnumerable<T>, ICollection<T>, IList<T>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    public T Value { get; set; }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    public CircleEntry<T> Next { get; set; }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    public CircleEntry<T> Previous { get; set; }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    public CircleEntry (T value)~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~69~ & \verb~      Value = value;~\\
\cellcolor{gray} &  & \verb~70~ & \verb~      Previous = this;~\\
\cellcolor{gray} &  & \verb~71~ & \verb~      Next = this;~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    private CircleEntry ()~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~76~ & \verb~      Previous = this;~\\
\cellcolor{gray} &  & \verb~77~ & \verb~      Next = this;~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    public CircleEntry (IEnumerable<T> list)~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~82~ & \verb~      bool first = true;~\\
\cellcolor{gray} &  & \verb~83~ & \verb~      CircleEntry<T> inserted = this;~\\
\cellcolor{gray} &  & \verb~84~ & \verb~      foreach (T obj in list) {~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        if (first) {~\\
\cellcolor{gray} &  & \verb~86~ & \verb~          Value = obj;~\\
\cellcolor{gray} &  & \verb~87~ & \verb~          Previous = this;~\\
\cellcolor{gray} &  & \verb~88~ & \verb~          Next = this;~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        else {~\\
\cellcolor{gray} &  & \verb~91~ & \verb~          inserted = inserted.InsertAfter (obj);~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        first = false;~\\
\cellcolor{gray} &  & \verb~94~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    public static CircleEntry<T> Empty~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~99~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        return new CircleEntry<T> ();~\\
\cellcolor{gray} &  & \verb~101~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    public CircleEntry<T> InsertBefore (T obj)~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~106~ & \verb~      CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{gray} &  & \verb~107~ & \verb~      insert.Previous = this.Previous;~\\
\cellcolor{gray} &  & \verb~108~ & \verb~      insert.Next = this;~\\
\cellcolor{gray} &  & \verb~109~ & \verb~      this.Previous.Next = insert;~\\
\cellcolor{gray} &  & \verb~110~ & \verb~      this.Previous = insert;~\\
\cellcolor{gray} &  & \verb~111~ & \verb~      return insert;~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    public CircleEntry<T> InsertAfter (T obj)~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~116~ & \verb~      //Log.Debug (this, ".InsertAfter (", obj, ")");~\\
\cellcolor{gray} &  & \verb~117~ & \verb~      CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{gray} &  & \verb~118~ & \verb~      insert.Next = this.Next;~\\
\cellcolor{gray} &  & \verb~119~ & \verb~      insert.Previous = this;~\\
\cellcolor{gray} &  & \verb~120~ & \verb~      this.Next.Previous = insert;~\\
\cellcolor{gray} &  & \verb~121~ & \verb~      this.Next = insert;~\\
\cellcolor{gray} &  & \verb~122~ & \verb~      return insert;~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    public void Remove ()~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~127~ & \verb~      Previous.Next = Next;~\\
\cellcolor{gray} &  & \verb~128~ & \verb~      Next.Previous = Previous;~\\
\cellcolor{gray} &  & \verb~129~ & \verb~      Previous = null;~\\
\cellcolor{gray} &  & \verb~130~ & \verb~      Next = null;~\\
\cellcolor{gray} &  & \verb~131~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    private bool IsEmpty~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~135~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        return (Next == this || Next == null) && (Previous == this || Previous~\\
\cellcolor{gray} &  & \verb~137~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    public int Count~\\
\cellcolor{gray} &  & \verb~141~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~142~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        if (IsEmpty) {~\\
\cellcolor{gray} &  & \verb~144~ & \verb~          return 0;~\\
\cellcolor{gray} &  & \verb~145~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~        else {~\\
\cellcolor{gray} &  & \verb~147~ & \verb~          CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~148~ & \verb~          int count = 0;~\\
\cellcolor{gray} &  & \verb~149~ & \verb~          do {~\\
\cellcolor{gray} &  & \verb~150~ & \verb~            ++count;~\\
\cellcolor{gray} &  & \verb~151~ & \verb~            current = current.Next;~\\
\cellcolor{gray} &  & \verb~152~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~          while (current != this);~\\
\cellcolor{gray} &  & \verb~154~ & \verb~          return count;~\\
\cellcolor{gray} &  & \verb~155~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~156~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~157~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{gray} &  & \verb~159~ & \verb~    public bool Contains (T obj, out IEnumerable<CircleEntry<T>> item)~\\
\cellcolor{gray} &  & \verb~160~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~161~ & \verb~      item = Find (obj);~\\
\cellcolor{gray} &  & \verb~162~ & \verb~      return item.Count () > 0;~\\
\cellcolor{gray} &  & \verb~163~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public bool Contains (Func<T, bool> func, out IEnumerable<CircleEntry<T>> ~\\
\cellcolor{gray} &  & \verb~166~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~167~ & \verb~      item = Find (func);~\\
\cellcolor{gray} &  & \verb~168~ & \verb~      return item.Count () > 0;~\\
\cellcolor{gray} &  & \verb~169~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~    public bool Contains (T obj, out CircleEntry<T> item)~\\
\cellcolor{gray} &  & \verb~172~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~173~ & \verb~      item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{gray} &  & \verb~174~ & \verb~      return item != null;~\\
\cellcolor{gray} &  & \verb~175~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~    public bool Contains (Func<T, bool> func, out CircleEntry<T> item)~\\
\cellcolor{gray} &  & \verb~178~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~179~ & \verb~      item = Find (func).ElementAtOrDefault (0);~\\
\cellcolor{gray} &  & \verb~180~ & \verb~      return item != null;~\\
\cellcolor{gray} &  & \verb~181~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~182~ & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & \verb~    public IEnumerable<CircleEntry<T>> Find (T obj)~\\
\cellcolor{gray} &  & \verb~184~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~185~ & \verb~      return Find ((t) => t.Equals (obj));~\\
\cellcolor{gray} &  & \verb~186~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~187~ & \verb~~\\
\cellcolor{gray} &  & \verb~188~ & \verb~    public IEnumerable<CircleEntry<T>> Find (Func<T, bool> func)~\\
\cellcolor{gray} &  & \verb~189~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~190~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~191~ & \verb~      do {~\\
\cellcolor{gray} &  & \verb~192~ & \verb~        if (func (current.Value)) {~\\
\cellcolor{gray} &  & \verb~193~ & \verb~          yield return current;~\\
\cellcolor{gray} &  & \verb~194~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~195~ & \verb~        current = current.Next;~\\
\cellcolor{gray} &  & \verb~196~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~      while (current != this);~\\
\cellcolor{gray} &  & \verb~198~ & \verb~      yield break;~\\
\cellcolor{gray} &  & \verb~199~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~200~ & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & \verb~    public int IndexOf (T obj)~\\
\cellcolor{gray} &  & \verb~202~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~203~ & \verb~      return IndexOf ((t) => t.Equals (obj));~\\
\cellcolor{gray} &  & \verb~204~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~    public int IndexOf (Func<T, bool> func)~\\
\cellcolor{gray} &  & \verb~207~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~208~ & \verb~      int i = 0;~\\
\cellcolor{gray} &  & \verb~209~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~210~ & \verb~      do {~\\
\cellcolor{gray} &  & \verb~211~ & \verb~        if (func (current.Value)) {~\\
\cellcolor{gray} &  & \verb~212~ & \verb~          return i;~\\
\cellcolor{gray} &  & \verb~213~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~214~ & \verb~        current = current.Next;~\\
\cellcolor{gray} &  & \verb~215~ & \verb~        ++ i;~\\
\cellcolor{gray} &  & \verb~216~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~217~ & \verb~      while (current != this);~\\
\cellcolor{gray} &  & \verb~218~ & \verb~      return -1;~\\
\cellcolor{gray} &  & \verb~219~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~220~ & \verb~~\\
\cellcolor{gray} &  & \verb~221~ & \verb~    public IEnumerable<T> RangeTo (CircleEntry<T> other)~\\
\cellcolor{gray} &  & \verb~222~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~223~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~224~ & \verb~      do {~\\
\cellcolor{gray} &  & \verb~225~ & \verb~        yield return current.Value;~\\
\cellcolor{gray} &  & \verb~226~ & \verb~        current = current.Next;~\\
\cellcolor{gray} &  & \verb~227~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~228~ & \verb~      while (current != other.Next && current != this);~\\
\cellcolor{gray} &  & \verb~229~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & \verb~    public IEnumerable<T> WayTo (T other)~\\
\cellcolor{gray} &  & \verb~232~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~233~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~234~ & \verb~      while (!current.Value.Equals (other)) {~\\
\cellcolor{gray} &  & \verb~235~ & \verb~        yield return current.Value;~\\
\cellcolor{gray} &  & \verb~236~ & \verb~        current = current.Next;~\\
\cellcolor{gray} &  & \verb~237~ & \verb~        if (current == this) {~\\
\cellcolor{gray} &  & \verb~238~ & \verb~          break;~\\
\cellcolor{gray} &  & \verb~239~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~240~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~241~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~242~ & \verb~~\\
\cellcolor{gray} &  & \verb~243~ & \verb~    public IEnumerable<Tuple<T,T>> Pairs~\\
\cellcolor{gray} &  & \verb~244~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~245~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~246~ & \verb~        CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~247~ & \verb~        do {~\\
\cellcolor{gray} &  & \verb~248~ & \verb~          yield return Tuple.Create (current.Value, current.Next.Value);~\\
\cellcolor{gray} &  & \verb~249~ & \verb~          current = current.Next;~\\
\cellcolor{gray} &  & \verb~250~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~251~ & \verb~        while (current != this);~\\
\cellcolor{gray} &  & \verb~252~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~253~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~254~ & \verb~~\\
\cellcolor{gray} &  & \verb~255~ & \verb~    public IEnumerable<Tuple<T,T,T>> Triples~\\
\cellcolor{gray} &  & \verb~256~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~257~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~258~ & \verb~        CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~259~ & \verb~        do {~\\
\cellcolor{gray} &  & \verb~260~ & \verb~          yield return Tuple.Create (current.Previous.Value, current.Value, cu~\\
\cellcolor{gray} &  & \verb~261~ & \verb~          current = current.Next;~\\
\cellcolor{gray} &  & \verb~262~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~263~ & \verb~        while (current != this);~\\
\cellcolor{gray} &  & \verb~264~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~265~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~266~ & \verb~~\\
\cellcolor{gray} &  & \verb~267~ & \verb~    public IEnumerator<T> GetEnumerator ()~\\
\cellcolor{gray} &  & \verb~268~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~269~ & \verb~      CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~270~ & \verb~      do {~\\
\cellcolor{gray} &  & \verb~271~ & \verb~        //Log.Debug (this, " => ", current.Content);~\\
\cellcolor{gray} &  & \verb~272~ & \verb~        yield return current.Value;~\\
\cellcolor{gray} &  & \verb~273~ & \verb~        current = current.Next;~\\
\cellcolor{gray} &  & \verb~274~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~275~ & \verb~      while (current != this);~\\
\cellcolor{gray} &  & \verb~276~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~277~ & \verb~~\\
\cellcolor{gray} &  & \verb~278~ & \verb~    // explicit interface implementation for nongeneric interface~\\
\cellcolor{gray} &  & \verb~279~ & \verb~    IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{gray} &  & \verb~280~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~281~ & \verb~      return GetEnumerator (); // just return the generic version~\\
\cellcolor{gray} &  & \verb~282~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~283~ & \verb~~\\
\cellcolor{gray} &  & \verb~284~ & \verb~    public override string ToString ()~\\
\cellcolor{gray} &  & \verb~285~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~286~ & \verb~      if (IsEmpty) {~\\
\cellcolor{gray} &  & \verb~287~ & \verb~        return "CircleEntry (" + Value.ToString () + ")";~\\
\cellcolor{gray} &  & \verb~288~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~289~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~290~ & \verb~        return "CircleEntry.Empty";~\\
\cellcolor{gray} &  & \verb~291~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~292~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~293~ & \verb~~\\
\cellcolor{gray} &  & \verb~294~ & \verb~    public static CircleEntry<T> operator + (CircleEntry<T> circle, int i)~\\
\cellcolor{gray} &  & \verb~295~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~296~ & \verb~      CircleEntry<T> next = circle;~\\
\cellcolor{gray} &  & \verb~297~ & \verb~      while (i > 0) {~\\
\cellcolor{gray} &  & \verb~298~ & \verb~        next = next.Next;~\\
\cellcolor{gray} &  & \verb~299~ & \verb~        i--;~\\
\cellcolor{gray} &  & \verb~300~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~301~ & \verb~      while (i < 0) {~\\
\cellcolor{gray} &  & \verb~302~ & \verb~        next = next.Previous;~\\
\cellcolor{gray} &  & \verb~303~ & \verb~        i++;~\\
\cellcolor{gray} &  & \verb~304~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~305~ & \verb~      return next;~\\
\cellcolor{gray} &  & \verb~306~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~307~ & \verb~~\\
\cellcolor{gray} &  & \verb~308~ & \verb~    public T this [int index]~\\
\cellcolor{gray} &  & \verb~309~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~310~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~311~ & \verb~        return (this + index).Value;~\\
\cellcolor{gray} &  & \verb~312~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~313~ & \verb~      set {~\\
\cellcolor{gray} &  & \verb~314~ & \verb~        (this + index).Value = value;~\\
\cellcolor{gray} &  & \verb~315~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~316~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~317~ & \verb~~\\
\cellcolor{gray} &  & \verb~318~ & \verb~    public static CircleEntry<T> operator - (CircleEntry<T> circle, int i)~\\
\cellcolor{gray} &  & \verb~319~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~320~ & \verb~      return circle + (-i);~\\
\cellcolor{gray} &  & \verb~321~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~322~ & \verb~~\\
\cellcolor{gray} &  & \verb~323~ & \verb~    public static CircleEntry<T> operator ++ (CircleEntry<T> circle)~\\
\cellcolor{gray} &  & \verb~324~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~325~ & \verb~      return circle.Next;~\\
\cellcolor{gray} &  & \verb~326~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~327~ & \verb~~\\
\cellcolor{gray} &  & \verb~328~ & \verb~    public static CircleEntry<T> operator -- (CircleEntry<T> circle)~\\
\cellcolor{gray} &  & \verb~329~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~330~ & \verb~      return circle.Previous;~\\
\cellcolor{gray} &  & \verb~331~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~332~ & \verb~~\\
\cellcolor{gray} &  & \verb~333~ & \verb~    public static implicit operator T (CircleEntry<T> circle)~\\
\cellcolor{gray} &  & \verb~334~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~335~ & \verb~      return circle.Value;~\\
\cellcolor{gray} &  & \verb~336~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~337~ & \verb~~\\
\cellcolor{gray} &  & \verb~338~ & \verb~    public bool IsReadOnly { get { return false; } }~\\
\cellcolor{gray} &  & \verb~339~ & \verb~~\\
\cellcolor{gray} &  & \verb~340~ & \verb~    public bool Contains (T obj)~\\
\cellcolor{gray} &  & \verb~341~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~342~ & \verb~      CircleEntry<T> item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{gray} &  & \verb~343~ & \verb~      return item != null;~\\
\cellcolor{gray} &  & \verb~344~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~345~ & \verb~~\\
\cellcolor{gray} &  & \verb~346~ & \verb~    public bool Remove (T value)~\\
\cellcolor{gray} &  & \verb~347~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~348~ & \verb~      CircleEntry<T> item;~\\
\cellcolor{gray} &  & \verb~349~ & \verb~      if (Contains (value, out item)) {~\\
\cellcolor{gray} &  & \verb~350~ & \verb~        item.Remove ();~\\
\cellcolor{gray} &  & \verb~351~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~352~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~353~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~354~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~355~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~356~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~357~ & \verb~~\\
\cellcolor{gray} &  & \verb~358~ & \verb~    public void RemoveAt (int i)~\\
\cellcolor{gray} &  & \verb~359~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~360~ & \verb~      (this + i).Remove ();~\\
\cellcolor{gray} &  & \verb~361~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~362~ & \verb~~\\
\cellcolor{gray} &  & \verb~363~ & \verb~    public void Insert (int i, T value)~\\
\cellcolor{gray} &  & \verb~364~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~365~ & \verb~      (this + i).InsertBefore (value);~\\
\cellcolor{gray} &  & \verb~366~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~367~ & \verb~~\\
\cellcolor{gray} &  & \verb~368~ & \verb~    public void Add (T value)~\\
\cellcolor{gray} &  & \verb~369~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~370~ & \verb~      if (Value == null) {~\\
\cellcolor{gray} &  & \verb~371~ & \verb~        Value = value;~\\
\cellcolor{gray} &  & \verb~372~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~373~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~374~ & \verb~        InsertBefore (value);~\\
\cellcolor{gray} &  & \verb~375~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~376~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~377~ & \verb~~\\
\cellcolor{gray} &  & \verb~378~ & \verb~    public void Clear ()~\\
\cellcolor{gray} &  & \verb~379~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~380~ & \verb~      Remove ();~\\
\cellcolor{gray} &  & \verb~381~ & \verb~      Next = Previous = this;~\\
\cellcolor{gray} &  & \verb~382~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~383~ & \verb~~\\
\cellcolor{gray} &  & \verb~384~ & \verb~    public void CopyTo (T[] array, int start)~\\
\cellcolor{gray} &  & \verb~385~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~386~ & \verb~      foreach (T value in this) {~\\
\cellcolor{gray} &  & \verb~387~ & \verb~        array.SetValue (value, start);~\\
\cellcolor{gray} &  & \verb~388~ & \verb~        ++start;~\\
\cellcolor{gray} &  & \verb~389~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~390~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~391~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~392~ & \verb~~\\
\cellcolor{gray} &  & \verb~393~ & \verb~  public static class CircleExtensions~\\
\cellcolor{gray} &  & \verb~394~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~395~ & \verb~    public static CircleEntry<T> ToCircle<T> (this IEnumerable<T> enumerable)~\\
\cellcolor{green} & 1 & \verb~396~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~397~ & \verb~      return new CircleEntry<T> (enumerable);~\\
\cellcolor{green} & 1 & \verb~398~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~399~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~400~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.Direction}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.Direction\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Direction.cs}\end{minipage} \\
\textbf{Coverage:} & 98.7\%\\
\textbf{Covered lines:} & 77\\
\textbf{Uncovered lines:} & 1\\
\textbf{Coverable lines:} & 78\\
\textbf{Total lines:} & 252\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{FromAxis(...)} & 5 & 100 & 85.71\\
\hline
\textbf{FromString(...)} & 3 & 91.67 & 80\\
\hline
\textbf{ToString()} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Division(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 100 & 85.71\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 5 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{GetHashCode()} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Direction.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Eine Wertesammlung der möglichen Richtungen in einem dreidimensionalen R~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Wird benutzt, damit keine ungültigen Kantenrichtungen angegeben werden k~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// Dies ist eine Klasse und kein Enum, kann aber~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// uneingeschränkt wie eines benutzt werden (Typesafe Enum Pattern).~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  public sealed class Direction : IEquatable<Direction>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    #region Enumeration Values~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Links.~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~69~ & \verb~    public static readonly Direction Left = new Direction (Vector3.Left, "Left~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// Rechts.~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~73~ & \verb~    public static readonly Direction Right = new Direction (Vector3.Right, "Ri~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// Hoch.~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~77~ & \verb~    public static readonly Direction Up = new Direction (Vector3.Up, "Up");~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// Runter.~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~81~ & \verb~    public static readonly Direction Down = new Direction (Vector3.Down, "Down~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    /// Vorwärts.~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~85~ & \verb~    public static readonly Direction Forward = new Direction (Vector3.Forward,~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// Rückwärts.~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~89~ & \verb~    public static readonly Direction Backward = new Direction (Vector3.Backwar~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// Keine Richtung.~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~93~ & \verb~    public static readonly Direction Zero = new Direction (Vector3.Zero, "Zero~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    #region Static Attributes~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{green} & 1 & \verb~99~ & \verb~    public static readonly Direction[] Values = {~\\
\cellcolor{gray} &  & \verb~100~ & \verb~      Left, Right, Up, Down, Forward,  Backward~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    };~\\
\cellcolor{green} & 1 & \verb~102~ & \verb~    private static readonly Dictionary<Direction, Direction> ReverseMap~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        = new Dictionary<Direction, Direction> ()~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~105~ & \verb~      { Left, Right }, { Right, Left },~\\
\cellcolor{gray} &  & \verb~106~ & \verb~      { Up, Down }, { Down, Up },~\\
\cellcolor{gray} &  & \verb~107~ & \verb~      { Forward, Backward }, { Backward, Forward },~\\
\cellcolor{gray} &  & \verb~108~ & \verb~      { Zero, Zero }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    };~\\
\cellcolor{gray} &  & \verb~110~ & \verb~~\\
\cellcolor{green} & 1 & \verb~111~ & \verb~    private static readonly Dictionary<Direction, Axis> AxisMap~\\
\cellcolor{gray} &  & \verb~112~ & \verb~        = new Dictionary<Direction, Axis> ()~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~114~ & \verb~      { Left, Axis.X }, { Right, Axis.X },~\\
\cellcolor{gray} &  & \verb~115~ & \verb~      { Up, Axis.Y }, { Down, Axis.Y },~\\
\cellcolor{gray} &  & \verb~116~ & \verb~      { Forward, Axis.Z }, { Backward, Axis.Z },~\\
\cellcolor{gray} &  & \verb~117~ & \verb~      { Zero, Axis.Zero }~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    };~\\
\cellcolor{gray} &  & \verb~119~ & \verb~~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{green} & 1969 & \verb~124~ & \verb~    public Vector3 Vector { get; private set; }~\\
\cellcolor{gray} &  & \verb~125~ & \verb~~\\
\cellcolor{green} & 384 & \verb~126~ & \verb~    public string Description { get; private set; }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{green} & 183 & \verb~128~ & \verb~    public Direction Reverse { get { return ReverseMap [this]; } }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{green} & 33 & \verb~130~ & \verb~    public Axis Axis { get { return AxisMap[this]; } }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{gray} &  & \verb~132~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~133~ & \verb~~\\
\cellcolor{gray} &  & \verb~134~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{green} & 7 & \verb~136~ & \verb~    private Direction (Vector3 vector, string desciption)~\\
\cellcolor{green} & 7 & \verb~137~ & \verb~    {~\\
\cellcolor{green} & 7 & \verb~138~ & \verb~      Vector = vector;~\\
\cellcolor{green} & 7 & \verb~139~ & \verb~      Description = desciption;~\\
\cellcolor{green} & 7 & \verb~140~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~~\\
\cellcolor{gray} &  & \verb~142~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~143~ & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & \verb~    #region Methods and Operators~\\
\cellcolor{gray} &  & \verb~145~ & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & \verb~    public static Direction FromAxis (Axis axis)~\\
\cellcolor{green} & 3 & \verb~147~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~148~ & \verb~      return axis == Axis.X ? Right : axis == Axis.Y ? Up : axis == Axis.Z ? B~\\
\cellcolor{green} & 3 & \verb~149~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~    public static Direction FromString (string str)~\\
\cellcolor{green} & 6 & \verb~152~ & \verb~    {~\\
\cellcolor{green} & 75 & \verb~153~ & \verb~      foreach (Direction direction in Values) {~\\
\cellcolor{green} & 27 & \verb~154~ & \verb~        if (str.ToLower () == direction.Description.ToLower ()) {~\\
\cellcolor{green} & 6 & \verb~155~ & \verb~          return direction;~\\
\cellcolor{gray} &  & \verb~156~ & \verb~        }~\\
\cellcolor{green} & 15 & \verb~157~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~158~ & \verb~      return null;~\\
\cellcolor{green} & 6 & \verb~159~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~160~ & \verb~~\\
\cellcolor{gray} &  & \verb~161~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 108 & \verb~162~ & \verb~    {~\\
\cellcolor{green} & 108 & \verb~163~ & \verb~      return Description;~\\
\cellcolor{green} & 108 & \verb~164~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~    public static Vector3 operator + (Vector3 v, Direction d)~\\
\cellcolor{green} & 317 & \verb~167~ & \verb~    {~\\
\cellcolor{green} & 317 & \verb~168~ & \verb~      return v + d.Vector;~\\
\cellcolor{green} & 317 & \verb~169~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~    public static Vector3 operator - (Vector3 v, Direction d)~\\
\cellcolor{green} & 1 & \verb~172~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~173~ & \verb~      return v - d.Vector;~\\
\cellcolor{green} & 1 & \verb~174~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~175~ & \verb~~\\
\cellcolor{gray} &  & \verb~176~ & \verb~    public static Vector3 operator / (Direction d, float i)~\\
\cellcolor{green} & 600 & \verb~177~ & \verb~    {~\\
\cellcolor{green} & 600 & \verb~178~ & \verb~      return d.Vector / i;~\\
\cellcolor{green} & 600 & \verb~179~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~    public static Vector3 operator * (Direction d, float i)~\\
\cellcolor{green} & 1 & \verb~182~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~183~ & \verb~      return d.Vector * i;~\\
\cellcolor{green} & 1 & \verb~184~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~185~ & \verb~~\\
\cellcolor{gray} &  & \verb~186~ & \verb~    public static bool operator == (Direction a, Direction b)~\\
\cellcolor{green} & 792 & \verb~187~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~188~ & \verb~      // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 1082 & \verb~189~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 290 & \verb~190~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~191~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~192~ & \verb~~\\
\cellcolor{gray} &  & \verb~193~ & \verb~      // If one is null, but not both, return false.~\\
\cellcolor{green} & 579 & \verb~194~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 77 & \verb~195~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~196~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & \verb~      // Return true if the fields match:~\\
\cellcolor{green} & 425 & \verb~199~ & \verb~      return a.Vector == b.Vector;~\\
\cellcolor{green} & 792 & \verb~200~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~201~ & \verb~~\\
\cellcolor{gray} &  & \verb~202~ & \verb~    public static bool operator != (Direction d1, Direction d2)~\\
\cellcolor{green} & 109 & \verb~203~ & \verb~    {~\\
\cellcolor{green} & 109 & \verb~204~ & \verb~      return !(d1 == d2);~\\
\cellcolor{green} & 109 & \verb~205~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~206~ & \verb~~\\
\cellcolor{gray} &  & \verb~207~ & \verb~    public bool Equals (Direction other)~\\
\cellcolor{green} & 77 & \verb~208~ & \verb~    {~\\
\cellcolor{green} & 77 & \verb~209~ & \verb~      return other != null && Vector == other.Vector;~\\
\cellcolor{green} & 77 & \verb~210~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~~\\
\cellcolor{gray} &  & \verb~212~ & \verb~    public override bool Equals (object other)~\\
\cellcolor{green} & 7 & \verb~213~ & \verb~    {~\\
\cellcolor{green} & 8 & \verb~214~ & \verb~      if (other == null) {~\\
\cellcolor{green} & 1 & \verb~215~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~216~ & \verb~      }~\\
\cellcolor{green} & 7 & \verb~217~ & \verb~      else if (other is Direction) {~\\
\cellcolor{green} & 1 & \verb~218~ & \verb~        return Equals (other as Direction);~\\
\cellcolor{gray} &  & \verb~219~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~220~ & \verb~      else if (other is Vector3) {~\\
\cellcolor{green} & 1 & \verb~221~ & \verb~        return Vector.Equals ((Vector3)other);~\\
\cellcolor{gray} &  & \verb~222~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~223~ & \verb~      else if (other is string) {~\\
\cellcolor{green} & 2 & \verb~224~ & \verb~        return Description.Equals ((string)other);~\\
\cellcolor{gray} &  & \verb~225~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~226~ & \verb~      else {~\\
\cellcolor{green} & 2 & \verb~227~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~228~ & \verb~      }~\\
\cellcolor{green} & 7 & \verb~229~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & \verb~    public static implicit operator string (Direction direction)~\\
\cellcolor{green} & 9 & \verb~232~ & \verb~    {~\\
\cellcolor{green} & 9 & \verb~233~ & \verb~      return direction.Description;~\\
\cellcolor{green} & 9 & \verb~234~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~235~ & \verb~~\\
\cellcolor{gray} &  & \verb~236~ & \verb~    public static implicit operator Vector3 (Direction direction)~\\
\cellcolor{green} & 23 & \verb~237~ & \verb~    {~\\
\cellcolor{green} & 23 & \verb~238~ & \verb~      return direction.Vector;~\\
\cellcolor{green} & 23 & \verb~239~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~240~ & \verb~~\\
\cellcolor{gray} &  & \verb~241~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{green} & 236 & \verb~242~ & \verb~    {~\\
\cellcolor{green} & 236 & \verb~243~ & \verb~      return Description.GetHashCode ();~\\
\cellcolor{green} & 236 & \verb~244~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~245~ & \verb~~\\
\cellcolor{gray} &  & \verb~246~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~247~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~248~ & \verb~~\\
\cellcolor{gray} &  & \verb~249~ & \verb~  public enum Axis {~\\
\cellcolor{gray} &  & \verb~250~ & \verb~    X, Y, Z, Zero~\\
\cellcolor{gray} &  & \verb~251~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~252~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.DirectionHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.DirectionHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash DirectionHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 8\\
\textbf{Coverable lines:} & 8\\
\textbf{Total lines:} & 70\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ToDirection(...)} & 3 & 0 & 0\\
\hline
\textbf{.cctor()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash DirectionHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  public static class DirectionHelper~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~58~ & \verb~    public static Direction ToDirection (this Vector3 vector)~\\
\cellcolor{red} & 0 & \verb~59~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~60~ & \verb~      foreach (Direction direction in Direction.Values) {~\\
\cellcolor{red} & 0 & \verb~61~ & \verb~        if (direction.Vector == vector) {~\\
\cellcolor{red} & 0 & \verb~62~ & \verb~          return direction;~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~      return Direction.Zero;~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~    public static Axis[] Axes = new Axis[] { Axis.X, Axis.Y, Axis.Z };~\\
\cellcolor{gray} &  & \verb~69~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~70~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.Edge}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.Edge\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Edge.cs}\end{minipage} \\
\textbf{Coverage:} & 95.3\%\\
\textbf{Covered lines:} & 82\\
\textbf{Uncovered lines:} & 4\\
\textbf{Coverable lines:} & 86\\
\textbf{Total lines:} & 243\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 100 & 85.71\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 100\\
\hline
\textbf{Equals(...)} & 6 & 57.89 & 63.64\\
\hline
\textbf{GetHashCode()} & 1 & 100 & 100\\
\hline
\textbf{ToString()} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{RandomColor()} & 1 & 100 & 100\\
\hline
\textbf{RandomColor(...)} & 1 & 100 & 100\\
\hline
\textbf{RandomEdge()} & 6 & 100 & 54.55\\
\hline
\textbf{Clone()} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Edge.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Eine Kante eines Knotens, die aus einer Richtung und einer Farbe, sowie ~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public sealed class Edge : IEquatable<Edge>, ICloneable~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// Die Farbe der Kante.~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{green} & 439 & \verb~66~ & \verb~    public Color Color { get; set; }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Die Richtung der Kante.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1612 & \verb~71~ & \verb~    public Direction Direction { get; private set; }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// Die Liste der Flächennummern, die an die Kante angrenzen.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// </summary>~\\
\cellcolor{green} & 420 & \verb~76~ & \verb~    public HashSet<int> Rectangles { get; private set; }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    private int id;~\\
\cellcolor{green} & 1 & \verb~79~ & \verb~    private static int previousId = 0;~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// Erstellt eine neue Kante mit der angegebenen Richtung.~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// </summary>~\\
\cellcolor{green} & 161 & \verb~88~ & \verb~    public Edge (Direction direction)~\\
\cellcolor{green} & 161 & \verb~89~ & \verb~    {~\\
\cellcolor{green} & 161 & \verb~90~ & \verb~      Direction = direction;~\\
\cellcolor{green} & 161 & \verb~91~ & \verb~      Color = DefaultColor;~\\
\cellcolor{green} & 161 & \verb~92~ & \verb~      id = ++previousId;~\\
\cellcolor{green} & 161 & \verb~93~ & \verb~      Rectangles = new HashSet<int> ();~\\
\cellcolor{green} & 161 & \verb~94~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// Erstellt eine neue Kante mit der angegebenen Richtung und Farbe.~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// </summary>~\\
\cellcolor{green} & 19 & \verb~99~ & \verb~    public Edge (Direction direction, Color color)~\\
\cellcolor{green} & 19 & \verb~100~ & \verb~    {~\\
\cellcolor{green} & 19 & \verb~101~ & \verb~      Direction = direction;~\\
\cellcolor{green} & 19 & \verb~102~ & \verb~      Color = color;~\\
\cellcolor{green} & 19 & \verb~103~ & \verb~      id = ++previousId;~\\
\cellcolor{green} & 19 & \verb~104~ & \verb~      Rectangles = new HashSet<int>();~\\
\cellcolor{green} & 19 & \verb~105~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~108~ & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~110~ & \verb~~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    public static bool operator == (Edge a, Edge b)~\\
\cellcolor{green} & 76 & \verb~112~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~113~ & \verb~      // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 78 & \verb~114~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 2 & \verb~115~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~116~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~      // If one is null, but not both, return false.~\\
\cellcolor{green} & 145 & \verb~119~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 71 & \verb~120~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~121~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~      // Return true if the fields match:~\\
\cellcolor{green} & 3 & \verb~124~ & \verb~      return a.id == b.id;~\\
\cellcolor{green} & 76 & \verb~125~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    public static bool operator != (Edge a, Edge b)~\\
\cellcolor{green} & 74 & \verb~128~ & \verb~    {~\\
\cellcolor{green} & 74 & \verb~129~ & \verb~      return !(a == b);~\\
\cellcolor{green} & 74 & \verb~130~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{gray} &  & \verb~132~ & \verb~    public bool Equals (Edge other)~\\
\cellcolor{green} & 72 & \verb~133~ & \verb~    {~\\
\cellcolor{green} & 72 & \verb~134~ & \verb~      return other != null && this.id == other.id;~\\
\cellcolor{green} & 72 & \verb~135~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~136~ & \verb~~\\
\cellcolor{gray} &  & \verb~137~ & \verb~    public override bool Equals (object other)~\\
\cellcolor{green} & 30 & \verb~138~ & \verb~    {~\\
\cellcolor{green} & 30 & \verb~139~ & \verb~      if (other == null) {~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~141~ & \verb~      }~\\
\cellcolor{green} & 59 & \verb~142~ & \verb~      else if (other is Edge) {~\\
\cellcolor{green} & 29 & \verb~143~ & \verb~        return Equals (other as Edge);~\\
\cellcolor{gray} &  & \verb~144~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~145~ & \verb~      else if (other is Direction) {~\\
\cellcolor{red} & 0 & \verb~146~ & \verb~        return Direction.Equals (other as Direction);~\\
\cellcolor{gray} &  & \verb~147~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~148~ & \verb~      else if (other is Vector3) {~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~        return Direction.Vector.Equals ((Vector3)other);~\\
\cellcolor{gray} &  & \verb~150~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~151~ & \verb~      else if (other is Color) {~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~        return Color.Equals ((Color)other);~\\
\cellcolor{gray} &  & \verb~153~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~154~ & \verb~      else {~\\
\cellcolor{green} & 1 & \verb~155~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~156~ & \verb~      }~\\
\cellcolor{green} & 30 & \verb~157~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{gray} &  & \verb~159~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{green} & 235 & \verb~160~ & \verb~    {~\\
\cellcolor{green} & 235 & \verb~161~ & \verb~      return id;~\\
\cellcolor{green} & 235 & \verb~162~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~163~ & \verb~~\\
\cellcolor{gray} &  & \verb~164~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 1 & \verb~165~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~166~ & \verb~      return Direction + "/" + id.ToString ();~\\
\cellcolor{green} & 1 & \verb~167~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~168~ & \verb~~\\
\cellcolor{gray} &  & \verb~169~ & \verb~    public static implicit operator Direction (Edge edge)~\\
\cellcolor{green} & 9 & \verb~170~ & \verb~    {~\\
\cellcolor{green} & 9 & \verb~171~ & \verb~      return edge.Direction;~\\
\cellcolor{green} & 9 & \verb~172~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~173~ & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & \verb~    public static implicit operator Vector3 (Edge edge)~\\
\cellcolor{green} & 7 & \verb~175~ & \verb~    {~\\
\cellcolor{green} & 7 & \verb~176~ & \verb~      return edge.Direction;~\\
\cellcolor{green} & 7 & \verb~177~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~178~ & \verb~~\\
\cellcolor{gray} &  & \verb~179~ & \verb~    public static implicit operator Color (Edge edge)~\\
\cellcolor{green} & 18 & \verb~180~ & \verb~    {~\\
\cellcolor{green} & 18 & \verb~181~ & \verb~      return edge.Color;~\\
\cellcolor{green} & 18 & \verb~182~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~183~ & \verb~~\\
\cellcolor{gray} &  & \verb~184~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~185~ & \verb~~\\
\cellcolor{gray} &  & \verb~186~ & \verb~    #region Helper Methods~\\
\cellcolor{gray} &  & \verb~187~ & \verb~~\\
\cellcolor{green} & 1 & \verb~188~ & \verb~    private static Random r = new Random ();~\\
\cellcolor{gray} &  & \verb~189~ & \verb~~\\
\cellcolor{gray} &  & \verb~190~ & \verb~    public static Color RandomColor ()~\\
\cellcolor{green} & 1 & \verb~191~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~192~ & \verb~      return Colors [r.Next () % Colors.Count];~\\
\cellcolor{green} & 1 & \verb~193~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~194~ & \verb~~\\
\cellcolor{gray} &  & \verb~195~ & \verb~    public static Color RandomColor (GameTime time)~\\
\cellcolor{green} & 1 & \verb~196~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~197~ & \verb~      return Colors [(int)time.TotalGameTime.TotalSeconds % Colors.Count];~\\
\cellcolor{green} & 1 & \verb~198~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~199~ & \verb~~\\
\cellcolor{gray} &  & \verb~200~ & \verb~    public static Edge RandomEdge ()~\\
\cellcolor{green} & 1 & \verb~201~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~202~ & \verb~      int i = r.Next () % 6;~\\
\cellcolor{green} & 1 & \verb~203~ & \verb~      return i == 0 ? Left : i == 1 ? Right : i == 2 ? Up : i == 3 ? Down : i ~\\
\cellcolor{green} & 1 & \verb~204~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~    public object Clone ()~\\
\cellcolor{green} & 1 & \verb~207~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~208~ & \verb~      return new Edge (Direction, Color);~\\
\cellcolor{green} & 1 & \verb~209~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~210~ & \verb~~\\
\cellcolor{gray} &  & \verb~211~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~212~ & \verb~~\\
\cellcolor{gray} &  & \verb~213~ & \verb~    #region Static Properties~\\
\cellcolor{gray} &  & \verb~214~ & \verb~~\\
\cellcolor{green} & 1 & \verb~215~ & \verb~    public static List<Color> Colors = new List<Color> ()~\\
\cellcolor{gray} &  & \verb~216~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~217~ & \verb~      Color.Red, Color.Green, Color.Blue, Color.Yellow, Color.Orange~\\
\cellcolor{gray} &  & \verb~218~ & \verb~    };~\\
\cellcolor{green} & 1 & \verb~219~ & \verb~    public static Color DefaultColor = RandomColor ();~\\
\cellcolor{gray} &  & \verb~220~ & \verb~~\\
\cellcolor{green} & 21 & \verb~221~ & \verb~    public static Edge Zero { get { return new Edge (Direction.Zero); } }~\\
\cellcolor{gray} &  & \verb~222~ & \verb~~\\
\cellcolor{green} & 3 & \verb~223~ & \verb~    public static Edge UnitX { get { return new Edge (Direction.Right); } }~\\
\cellcolor{gray} &  & \verb~224~ & \verb~~\\
\cellcolor{green} & 3 & \verb~225~ & \verb~    public static Edge UnitY { get { return new Edge (Direction.Up); } }~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{green} & 3 & \verb~227~ & \verb~    public static Edge UnitZ { get { return new Edge (Direction.Backward); } }~\\
\cellcolor{gray} &  & \verb~228~ & \verb~~\\
\cellcolor{green} & 108 & \verb~229~ & \verb~    public static Edge Up { get { return new Edge (Direction.Up); } }~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{green} & 93 & \verb~231~ & \verb~    public static Edge Down { get { return new Edge (Direction.Down); } }~\\
\cellcolor{gray} &  & \verb~232~ & \verb~~\\
\cellcolor{green} & 108 & \verb~233~ & \verb~    public static Edge Right { get { return new Edge (Direction.Right); } }~\\
\cellcolor{gray} &  & \verb~234~ & \verb~~\\
\cellcolor{green} & 108 & \verb~235~ & \verb~    public static Edge Left { get { return new Edge (Direction.Left); } }~\\
\cellcolor{gray} &  & \verb~236~ & \verb~~\\
\cellcolor{green} & 18 & \verb~237~ & \verb~    public static Edge Forward { get { return new Edge (Direction.Forward); } ~\\
\cellcolor{gray} &  & \verb~238~ & \verb~~\\
\cellcolor{green} & 18 & \verb~239~ & \verb~    public static Edge Backward { get { return new Edge (Direction.Backward); ~\\
\cellcolor{gray} &  & \verb~240~ & \verb~~\\
\cellcolor{gray} &  & \verb~241~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~242~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~243~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.Knot}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.Knot\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Knot.cs}\end{minipage} \\
\textbf{Coverage:} & 84.9\%\\
\textbf{Covered lines:} & 266\\
\textbf{Uncovered lines:} & 47\\
\textbf{Coverable lines:} & 313\\
\textbf{Total lines:} & 643\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 5 & 100 & 55.56\\
\hline
\textbf{.ctor(...)} & 8 & 100 & 86.67\\
\hline
\textbf{.ctor(...)} & 5 & 100 & 88.89\\
\hline
\textbf{IsValidStructure(...} & 6 & 83.33 & 72.73\\
\hline
\textbf{IsValidStructure(...} & 2 & 100 & 100\\
\hline
\textbf{TryMove(...)} & 21 & 87.30 & 87.80\\
\hline
\textbf{MoveCenterToZero()} & 8 & 100 & 86.67\\
\hline
\textbf{Move(...)} & 2 & 100 & 100\\
\hline
\textbf{IsValidDirection(...} & 16 & 81.25 & 77.42\\
\hline
\textbf{onEdgesChanged()} & 1 & 0 & 0\\
\hline
\textbf{GetEnumerator()} & 1 & 100 & 100\\
\hline
\textbf{Save()} & 3 & 0 & 0\\
\hline
\textbf{Clone()} & 2 & 100 & 100\\
\hline
\textbf{OnSelectionChanged()} & 1 & 100 & 100\\
\hline
\textbf{AddToSelection(...)} & 3 & 100 & 60\\
\hline
\textbf{RemoveFromSelection(} & 2 & 100 & 100\\
\hline
\textbf{ClearSelection()} & 1 & 100 & 100\\
\hline
\textbf{AddRangeToSelection(} & 9 & 100 & 88.24\\
\hline
\textbf{IsSelected(...)} & 1 & 0 & 0\\
\hline
\textbf{System.Collections.I} & 1 & 100 & 100\\
\hline
\textbf{Save(...)} & 1 & 0 & 0\\
\hline
\textbf{Equals(...)} & 8 & 51.43 & 46.67\\
\hline
\textbf{Charakteristic()} & 9 & 100 & 100\\
\hline
\textbf{ToString()} & 3 & 100 & 66.67\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Knot.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// Diese Klasse repräsentiert einen Knoten, bestehend aus einem Knoten-Meta~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  public sealed class Knot : ICloneable, IEnumerable<Edge>, IEquatable<Knot>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Der Name des Knotens, welcher auch leer sein kann.~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// Beim Speichern muss der Nutzer in diesem Fall zwingend einen nichtleer~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Der Wert dieser Eigenschaft wird aus der \glqq Name\grqq -Eigenschaft ~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// und bei Änderungen wieder in diesem gespeichert.~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// Beim Ändern dieser Eigenschaft wird automatisch auch der im Metadaten-~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    public string Name~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    {~\\
\cellcolor{green} & 30 & \verb~75~ & \verb~      get { return MetaData.Name; }~\\
\cellcolor{green} & 3 & \verb~76~ & \verb~      set { MetaData.Name = value; }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// Das Startelement der doppelt-verketteten Liste, in der die Kanten gesp~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    private CircleEntry<Edge> startElement;~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// Die Metadaten des Knotens.~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// </summary>~\\
\cellcolor{green} & 51 & \verb~87~ & \verb~    public KnotMetaData MetaData { get; private set; }~\\
\cellcolor{gray} &  & \verb~88~ & \verb~~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    /// Ein Ereignis, das in der Move-Methode ausgelöst wird, wenn sich die St~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// </summary>~\\
\cellcolor{green} & 28 & \verb~92~ & \verb~    public Action EdgesChanged = () => {};~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    /// Enthält die aktuell vom Spieler selektierten Kanten in der Reihenfolge~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// </summary>~\\
\cellcolor{green} & 24 & \verb~97~ & \verb~    public IEnumerable<Edge> SelectedEdges { get { return selectedEdges; } }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// Enthält die selektierten Kanten.~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    private HashSet<Edge> selectedEdges;~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    /// WTF?!~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    public int debugId;~\\
\cellcolor{gray} &  & \verb~108~ & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    /// Wird aufgerufen, wenn sich die Selektion geändert hat.~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    /// </summary>~\\
\cellcolor{green} & 39 & \verb~112~ & \verb~    public Action SelectionChanged = () => {};~\\
\cellcolor{gray} &  & \verb~113~ & \verb~~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    /// Enthält die zuletzt selektierte Kante.~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    private CircleEntry<Edge> lastSelected;~\\
\cellcolor{gray} &  & \verb~118~ & \verb~~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    /// Wird aufgerufen, wenn sich die Startkante geändert hat.~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    /// </summary>~\\
\cellcolor{green} & 28 & \verb~122~ & \verb~    public Action<Vector3> StartEdgeChanged = (v) => {};~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    /// Der Cache für die Knotencharakteristik.~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    /// </summary>~\\
\cellcolor{green} & 28 & \verb~127~ & \verb~    private KnotCharakteristic? CharakteristicCache = null;~\\
\cellcolor{gray} &  & \verb~128~ & \verb~~\\
\cellcolor{green} & 35 & \verb~129~ & \verb~    public Vector3 OffSet { get; private set;}~\\
\cellcolor{gray} &  & \verb~130~ & \verb~~\\
\cellcolor{gray} &  & \verb~131~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~134~ & \verb~~\\
\cellcolor{gray} &  & \verb~135~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~136~ & \verb~    /// Erstellt einen minimalen Standardknoten. Das Metadaten-Objekt enthält ~\\
\cellcolor{gray} &  & \verb~137~ & \verb~    /// die das Speicherformat und den Dateinamen beinhalten, den Wert \glqq n~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~139~ & \verb~    public Knot ()~\\
\cellcolor{green} & 1 & \verb~140~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~141~ & \verb~      debugId++;~\\
\cellcolor{green} & 1 & \verb~142~ & \verb~      MetaData = new KnotMetaData (String.Empty, () => startElement.Count, nul~\\
\cellcolor{green} & 1 & \verb~143~ & \verb~      startElement = new CircleEntry<Edge> (new Edge[] {~\\
\cellcolor{gray} &  & \verb~144~ & \verb~        // Edge.Up, Edge.Right, Edge.Right, Edge.Down, Edge.Backward,~\\
\cellcolor{gray} &  & \verb~145~ & \verb~        // Edge.Up, Edge.Left, Edge.Left, Edge.Down, Edge.Forward~\\
\cellcolor{gray} &  & \verb~146~ & \verb~        Edge.Up, Edge.Right, Edge.Down, Edge.Left~\\
\cellcolor{gray} &  & \verb~147~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~                                           );~\\
\cellcolor{green} & 1 & \verb~149~ & \verb~      selectedEdges = new HashSet<Edge> ();~\\
\cellcolor{green} & 1 & \verb~150~ & \verb~      OffSet = Vector3.Zero;~\\
\cellcolor{green} & 1 & \verb~151~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~152~ & \verb~~\\
\cellcolor{gray} &  & \verb~153~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~154~ & \verb~    /// Erstellt einen neuen Knoten mit dem angegebenen Metadaten-Objekt und d~\\
\cellcolor{gray} &  & \verb~155~ & \verb~    /// die in der doppelt verketteten Liste gespeichert werden.~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    /// Die Eigenschaft des Metadaten-Objektes, die die Anzahl der Kanten enth~\\
\cellcolor{gray} &  & \verb~157~ & \verb~    /// wird auf ein Delegate gesetzt, welches jeweils die aktuelle Anzahl der~\\
\cellcolor{gray} &  & \verb~158~ & \verb~    /// </summary>~\\
\cellcolor{green} & 24 & \verb~159~ & \verb~    public Knot (KnotMetaData metaData, IEnumerable<Edge> edges)~\\
\cellcolor{green} & 24 & \verb~160~ & \verb~    {~\\
\cellcolor{green} & 24 & \verb~161~ & \verb~      debugId++;~\\
\cellcolor{green} & 24 & \verb~162~ & \verb~      Stack<Direction> structure = new Stack<Direction> ();~\\
\cellcolor{green} & 726 & \verb~163~ & \verb~      foreach (Edge edge in edges) {~\\
\cellcolor{green} & 218 & \verb~164~ & \verb~        structure.Push (edge.Direction);~\\
\cellcolor{green} & 218 & \verb~165~ & \verb~      }~\\
\cellcolor{green} & 25 & \verb~166~ & \verb~      if (!IsValidStructure (structure)) {~\\
\cellcolor{green} & 1 & \verb~167~ & \verb~        throw new InvalidDataException ();~\\
\cellcolor{gray} &  & \verb~168~ & \verb~      }~\\
\cellcolor{green} & 23 & \verb~169~ & \verb~      MetaData = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~170~ & \verb~          name: metaData.Name,~\\
\cellcolor{green} & 1 & \verb~171~ & \verb~          countEdges: () => this.startElement.Count,~\\
\cellcolor{gray} &  & \verb~172~ & \verb~          format: metaData.Format,~\\
\cellcolor{gray} &  & \verb~173~ & \verb~          filename: metaData.Filename~\\
\cellcolor{gray} &  & \verb~174~ & \verb~      );~\\
\cellcolor{green} & 23 & \verb~175~ & \verb~      this.startElement = new CircleEntry<Edge> (edges);~\\
\cellcolor{green} & 23 & \verb~176~ & \verb~      selectedEdges = new HashSet<Edge> ();~\\
\cellcolor{green} & 23 & \verb~177~ & \verb~      OffSet = Vector3.Zero;~\\
\cellcolor{green} & 23 & \verb~178~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~179~ & \verb~~\\
\cellcolor{green} & 3 & \verb~180~ & \verb~    private Knot (KnotMetaData metaData, CircleEntry<Edge> start, HashSet<Edge~\\
\cellcolor{green} & 3 & \verb~181~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~182~ & \verb~      startElement = start;~\\
\cellcolor{green} & 3 & \verb~183~ & \verb~      MetaData = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~184~ & \verb~          name: metaData.Name,~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~          countEdges: () => this.startElement.Count,~\\
\cellcolor{gray} &  & \verb~186~ & \verb~          format: metaData.Format,~\\
\cellcolor{gray} &  & \verb~187~ & \verb~          filename: metaData.Filename~\\
\cellcolor{gray} &  & \verb~188~ & \verb~      );~\\
\cellcolor{green} & 3 & \verb~189~ & \verb~      selectedEdges = selected;~\\
\cellcolor{green} & 3 & \verb~190~ & \verb~      OffSet = offset;~\\
\cellcolor{green} & 3 & \verb~191~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~192~ & \verb~~\\
\cellcolor{gray} &  & \verb~193~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~194~ & \verb~~\\
\cellcolor{gray} &  & \verb~195~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~196~ & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~198~ & \verb~    /// Prüft ob die gegeben Struktur einen gültigen Knoten darstellt.~\\
\cellcolor{gray} &  & \verb~199~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~200~ & \verb~    public bool IsValidStructure (IEnumerable<Direction> knot)~\\
\cellcolor{green} & 27 & \verb~201~ & \verb~    {~\\
\cellcolor{green} & 27 & \verb~202~ & \verb~      Vector3 position3D = Vector3.Zero;~\\
\cellcolor{green} & 27 & \verb~203~ & \verb~      HashSet<Vector3> occupancy = new HashSet<Vector3> ();~\\
\cellcolor{green} & 27 & \verb~204~ & \verb~      if (knot.Count () < 4) {~\\
\cellcolor{red} & 0 & \verb~205~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~206~ & \verb~      }~\\
\cellcolor{green} & 795 & \verb~207~ & \verb~      foreach (Direction peek in knot) {~\\
\cellcolor{green} & 238 & \verb~208~ & \verb~        if (occupancy.Contains (position3D + (peek / 2))) {~\\
\cellcolor{red} & 0 & \verb~209~ & \verb~          return false;~\\
\cellcolor{gray} &  & \verb~210~ & \verb~        }~\\
\cellcolor{green} & 238 & \verb~211~ & \verb~        else {~\\
\cellcolor{green} & 238 & \verb~212~ & \verb~          occupancy.Add (position3D + (peek / 2));~\\
\cellcolor{green} & 238 & \verb~213~ & \verb~          position3D += peek;~\\
\cellcolor{green} & 238 & \verb~214~ & \verb~        }~\\
\cellcolor{green} & 238 & \verb~215~ & \verb~      }~\\
\cellcolor{green} & 28 & \verb~216~ & \verb~      if (position3D.DistanceTo (Vector3.Zero) > 0.00001f) {~\\
\cellcolor{green} & 1 & \verb~217~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~218~ & \verb~      }~\\
\cellcolor{green} & 26 & \verb~219~ & \verb~      return true;~\\
\cellcolor{green} & 27 & \verb~220~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~221~ & \verb~~\\
\cellcolor{gray} &  & \verb~222~ & \verb~    private bool IsValidStructure (IEnumerable<Edge> edges)~\\
\cellcolor{green} & 3 & \verb~223~ & \verb~    {~\\
\cellcolor{green} & 43 & \verb~224~ & \verb~      return IsValidStructure (from e in edges select e.Direction);~\\
\cellcolor{green} & 3 & \verb~225~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~228~ & \verb~    /// Verschiebt die aktuelle Kantenauswahl in die angegebene Richtung um di~\\
\cellcolor{gray} &  & \verb~229~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~230~ & \verb~    public bool TryMove (Direction direction, int distance, out Knot newknot)~\\
\cellcolor{green} & 9 & \verb~231~ & \verb~    {~\\
\cellcolor{green} & 12 & \verb~232~ & \verb~      if (direction == Direction.Zero || distance == 0) {~\\
\cellcolor{green} & 3 & \verb~233~ & \verb~        newknot = this;~\\
\cellcolor{green} & 3 & \verb~234~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~235~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~236~ & \verb~~\\
\cellcolor{green} & 6 & \verb~237~ & \verb~      Log.Debug ("TryMove: direction = ", direction, ", distance = ", distance~\\
\cellcolor{green} & 38 & \verb~238~ & \verb~      Log.Debug ("Current Knot #", startElement.Count, " = ", string.Join (", ~\\
\cellcolor{gray} &  & \verb~239~ & \verb~~\\
\cellcolor{green} & 6 & \verb~240~ & \verb~      HashSet<Edge> selected = new HashSet<Edge> (selectedEdges);~\\
\cellcolor{green} & 6 & \verb~241~ & \verb~      CircleEntry<Edge> newCircle = CircleEntry<Edge>.Empty;~\\
\cellcolor{gray} &  & \verb~242~ & \verb~~\\
\cellcolor{green} & 114 & \verb~243~ & \verb~      foreach (Tuple<Edge, Edge, Edge> triple in startElement.Triples) {~\\
\cellcolor{green} & 32 & \verb~244~ & \verb~        Edge previousEdge = triple.Item1;~\\
\cellcolor{green} & 32 & \verb~245~ & \verb~        Edge currentEdge = triple.Item2;~\\
\cellcolor{green} & 32 & \verb~246~ & \verb~        Edge nextEdge = triple.Item3;~\\
\cellcolor{gray} &  & \verb~247~ & \verb~~\\
\cellcolor{green} & 38 & \verb~248~ & \verb~        if (selectedEdges.Contains (currentEdge) && !selectedEdges.Contains (p~\\
\cellcolor{green} & 15 & \verb~249~ & \verb~          distance.Repeat (i => newCircle.Add (new Edge (direction: direction,~\\
\cellcolor{green} & 6 & \verb~250~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~251~ & \verb~~\\
\cellcolor{green} & 32 & \verb~252~ & \verb~        newCircle.Add (currentEdge);~\\
\cellcolor{gray} &  & \verb~253~ & \verb~~\\
\cellcolor{green} & 38 & \verb~254~ & \verb~        if (selectedEdges.Contains (currentEdge) && !selectedEdges.Contains (n~\\
\cellcolor{green} & 15 & \verb~255~ & \verb~          distance.Repeat (i => newCircle.Add (new Edge (direction: direction.~\\
\cellcolor{green} & 6 & \verb~256~ & \verb~        }~\\
\cellcolor{green} & 32 & \verb~257~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~258~ & \verb~~\\
\cellcolor{green} & 56 & \verb~259~ & \verb~      Log.Debug ("New Knot #", newCircle.Count, " = ", string.Join (", ", from~\\
\cellcolor{gray} &  & \verb~260~ & \verb~~\\
\cellcolor{green} & 6 & \verb~261~ & \verb~      Vector3 localOffset = OffSet;~\\
\cellcolor{green} & 6 & \verb~262~ & \verb~      CircleEntry<Edge> current = newCircle;~\\
\cellcolor{green} & 45 & \verb~263~ & \verb~      do {~\\
\cellcolor{green} & 55 & \verb~264~ & \verb~        if (current [- 1].Direction == current [- 2].Direction.Reverse) {~\\
\cellcolor{gray} &  & \verb~265~ & \verb~          // Selektierte nicht löschen~\\
\cellcolor{green} & 13 & \verb~266~ & \verb~          if (selected.Contains (current [- 1]) || selected.Contains (current ~\\
\cellcolor{green} & 3 & \verb~267~ & \verb~            Log.Debug ("Error: Selektierte nicht löschen");~\\
\cellcolor{green} & 3 & \verb~268~ & \verb~            newknot = null;~\\
\cellcolor{green} & 3 & \verb~269~ & \verb~            return false;~\\
\cellcolor{gray} &  & \verb~270~ & \verb~          }~\\
\cellcolor{green} & 7 & \verb~271~ & \verb~          if (newCircle == current - 1) {~\\
\cellcolor{red} & 0 & \verb~272~ & \verb~            localOffset += (current - 1).Value;~\\
\cellcolor{red} & 0 & \verb~273~ & \verb~            newCircle = current;~\\
\cellcolor{red} & 0 & \verb~274~ & \verb~          }~\\
\cellcolor{green} & 8 & \verb~275~ & \verb~          else if (newCircle == current - 2) {~\\
\cellcolor{green} & 1 & \verb~276~ & \verb~            localOffset += (current - 1).Value.Direction + (current - 1).Value~\\
\cellcolor{green} & 1 & \verb~277~ & \verb~            newCircle = current;~\\
\cellcolor{green} & 1 & \verb~278~ & \verb~          }~\\
\cellcolor{green} & 7 & \verb~279~ & \verb~          (current - 2).Remove ();~\\
\cellcolor{green} & 7 & \verb~280~ & \verb~          (current - 1).Remove ();~\\
\cellcolor{green} & 7 & \verb~281~ & \verb~        }~\\
\cellcolor{green} & 42 & \verb~282~ & \verb~        ++ current;~\\
\cellcolor{green} & 42 & \verb~283~ & \verb~      }~\\
\cellcolor{green} & 42 & \verb~284~ & \verb~      while (current != newCircle);~\\
\cellcolor{gray} &  & \verb~285~ & \verb~~\\
\cellcolor{green} & 23 & \verb~286~ & \verb~      Log.Debug ("New Knot after Remove #", newCircle.Count, " = ", string.Joi~\\
\cellcolor{gray} &  & \verb~287~ & \verb~~\\
\cellcolor{green} & 3 & \verb~288~ & \verb~      if (!IsValidStructure (newCircle)) {~\\
\cellcolor{red} & 0 & \verb~289~ & \verb~        Log.Debug ("Error: newCircle ist keine valide Struktur");~\\
\cellcolor{red} & 0 & \verb~290~ & \verb~        newknot = null;~\\
\cellcolor{red} & 0 & \verb~291~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~292~ & \verb~      }~\\
\cellcolor{green} & 3 & \verb~293~ & \verb~      newknot = new Knot (MetaData, newCircle, selected, localOffset);~\\
\cellcolor{green} & 3 & \verb~294~ & \verb~      return true;~\\
\cellcolor{green} & 9 & \verb~295~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~296~ & \verb~~\\
\cellcolor{gray} &  & \verb~297~ & \verb~    public Vector3 MoveCenterToZero ()~\\
\cellcolor{green} & 1 & \verb~298~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~299~ & \verb~      Vector3 position3D = Vector3.Zero;~\\
\cellcolor{green} & 1 & \verb~300~ & \verb~      Dictionary<Vector3, Edge> occupancy = new Dictionary<Vector3, Edge>();~\\
\cellcolor{green} & 21 & \verb~301~ & \verb~      foreach (Edge edge in startElement) {~\\
\cellcolor{green} & 6 & \verb~302~ & \verb~        occupancy.Add (position3D + (edge.Direction / 2), edge);~\\
\cellcolor{green} & 6 & \verb~303~ & \verb~        position3D += edge;~\\
\cellcolor{green} & 6 & \verb~304~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~305~ & \verb~      Vector3 mid = Vector3.Zero;~\\
\cellcolor{green} & 21 & \verb~306~ & \verb~      foreach (KeyValuePair<Vector3,Edge> pos in occupancy) {~\\
\cellcolor{green} & 6 & \verb~307~ & \verb~        mid += pos.Key;~\\
\cellcolor{green} & 6 & \verb~308~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~309~ & \verb~      mid /= startElement.Count;~\\
\cellcolor{green} & 1 & \verb~310~ & \verb~      float minDistance = mid.Length ();~\\
\cellcolor{green} & 1 & \verb~311~ & \verb~      Edge newStart = startElement.Value;~\\
\cellcolor{green} & 21 & \verb~312~ & \verb~      foreach (KeyValuePair<Vector3,Edge> pos in occupancy) {~\\
\cellcolor{green} & 6 & \verb~313~ & \verb~        float testDistance = pos.Key.DistanceTo (mid);~\\
\cellcolor{green} & 8 & \verb~314~ & \verb~        if (testDistance < minDistance) {~\\
\cellcolor{green} & 2 & \verb~315~ & \verb~          newStart = pos.Value;~\\
\cellcolor{green} & 2 & \verb~316~ & \verb~          minDistance = testDistance;~\\
\cellcolor{green} & 2 & \verb~317~ & \verb~        }~\\
\cellcolor{green} & 6 & \verb~318~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~319~ & \verb~      Vector3 offset = Vector3.Zero;~\\
\cellcolor{green} & 6 & \verb~320~ & \verb~      foreach (Edge edge in startElement.WayTo (newStart)) {~\\
\cellcolor{green} & 1 & \verb~321~ & \verb~        offset += edge;~\\
\cellcolor{green} & 1 & \verb~322~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~323~ & \verb~      startElement.Contains (newStart, out startElement);~\\
\cellcolor{green} & 1 & \verb~324~ & \verb~      offset += OffSet;~\\
\cellcolor{green} & 1 & \verb~325~ & \verb~      OffSet = Vector3.Zero;~\\
\cellcolor{green} & 1 & \verb~326~ & \verb~      return offset;~\\
\cellcolor{green} & 1 & \verb~327~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~328~ & \verb~~\\
\cellcolor{gray} &  & \verb~329~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~330~ & \verb~    /// Verschiebt die aktuelle Kantenauswahl in die angegebene Richtung um di~\\
\cellcolor{gray} &  & \verb~331~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~332~ & \verb~    public bool Move (Direction direction, int distance)~\\
\cellcolor{green} & 9 & \verb~333~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~334~ & \verb~      Knot newKnot;~\\
\cellcolor{green} & 15 & \verb~335~ & \verb~      if (TryMove (direction, distance, out newKnot)) {~\\
\cellcolor{green} & 6 & \verb~336~ & \verb~        startElement = newKnot.startElement;~\\
\cellcolor{green} & 6 & \verb~337~ & \verb~        selectedEdges = newKnot.selectedEdges;~\\
\cellcolor{green} & 6 & \verb~338~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~339~ & \verb~      }~\\
\cellcolor{green} & 3 & \verb~340~ & \verb~      else {~\\
\cellcolor{green} & 3 & \verb~341~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~342~ & \verb~      }~\\
\cellcolor{green} & 9 & \verb~343~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~344~ & \verb~~\\
\cellcolor{gray} &  & \verb~345~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~346~ & \verb~    /// Gibt an ob ein Move in diese Richtung überhaupt möglich ist.~\\
\cellcolor{gray} &  & \verb~347~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~348~ & \verb~    public bool IsValidDirection (Direction direction)~\\
\cellcolor{green} & 6 & \verb~349~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~350~ & \verb~      // Nichts selektiert~\\
\cellcolor{green} & 6 & \verb~351~ & \verb~      if (selectedEdges.Count == 0) {~\\
\cellcolor{red} & 0 & \verb~352~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~353~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~354~ & \verb~      // Alles selektiert~\\
\cellcolor{green} & 6 & \verb~355~ & \verb~      if (selectedEdges.Count == startElement.Count) {~\\
\cellcolor{red} & 0 & \verb~356~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~357~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~358~ & \verb~~\\
\cellcolor{green} & 6 & \verb~359~ & \verb~      HashSet<Axis> axes = new HashSet<Axis> ();~\\
\cellcolor{green} & 76 & \verb~360~ & \verb~      foreach (Tuple<Edge, Edge, Edge> triple in startElement.Triples) {~\\
\cellcolor{green} & 20 & \verb~361~ & \verb~        Edge previousEdge = triple.Item1;~\\
\cellcolor{green} & 20 & \verb~362~ & \verb~        Edge currentEdge = triple.Item2;~\\
\cellcolor{green} & 20 & \verb~363~ & \verb~        Edge nextEdge = triple.Item3;~\\
\cellcolor{gray} &  & \verb~364~ & \verb~~\\
\cellcolor{gray} &  & \verb~365~ & \verb~        // Wenn Kante nach der Bewegung gelöscht werden müsste ist ein Zug nic~\\
\cellcolor{green} & 20 & \verb~366~ & \verb~        if (selectedEdges.Contains (currentEdge) && !selectedEdges.Contains (p~\\
\cellcolor{green} & 1 & \verb~367~ & \verb~                && currentEdge.Direction == direction.Reverse && previousEdge.~\\
\cellcolor{green} & 1 & \verb~368~ & \verb~          return false;~\\
\cellcolor{gray} &  & \verb~369~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~370~ & \verb~        // Wenn Kante nach der Bewegung gelöscht werden müsste ist ein Zug nic~\\
\cellcolor{green} & 19 & \verb~371~ & \verb~        if (selectedEdges.Contains (currentEdge) && !selectedEdges.Contains (n~\\
\cellcolor{green} & 1 & \verb~372~ & \verb~                && currentEdge.Direction == direction && nextEdge.Direction !=~\\
\cellcolor{green} & 1 & \verb~373~ & \verb~          return false;~\\
\cellcolor{gray} &  & \verb~374~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~375~ & \verb~~\\
\cellcolor{green} & 22 & \verb~376~ & \verb~        if (selectedEdges.Contains (currentEdge)) {~\\
\cellcolor{green} & 4 & \verb~377~ & \verb~          axes.Add (currentEdge.Direction.Axis);~\\
\cellcolor{green} & 4 & \verb~378~ & \verb~        }~\\
\cellcolor{green} & 18 & \verb~379~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~380~ & \verb~      // Wenn alle Kanten entlang einer Achse angeordnet sind und die Verschie~\\
\cellcolor{green} & 4 & \verb~381~ & \verb~      if (axes.Count == 1 && axes.Contains (direction.Axis)) {~\\
\cellcolor{red} & 0 & \verb~382~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~383~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~384~ & \verb~      return true;~\\
\cellcolor{green} & 6 & \verb~385~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~386~ & \verb~~\\
\cellcolor{gray} &  & \verb~387~ & \verb~    private void onEdgesChanged ()~\\
\cellcolor{red} & 0 & \verb~388~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~389~ & \verb~      CharakteristicCache = null;~\\
\cellcolor{red} & 0 & \verb~390~ & \verb~      EdgesChanged ();~\\
\cellcolor{red} & 0 & \verb~391~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~392~ & \verb~~\\
\cellcolor{gray} &  & \verb~393~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~394~ & \verb~    /// Gibt die doppelt-verkettete Kantenliste als Enumerator zurück.~\\
\cellcolor{gray} &  & \verb~395~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~396~ & \verb~    public IEnumerator<Edge> GetEnumerator ()~\\
\cellcolor{green} & 36 & \verb~397~ & \verb~    {~\\
\cellcolor{green} & 36 & \verb~398~ & \verb~      return startElement.GetEnumerator ();~\\
\cellcolor{green} & 36 & \verb~399~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~400~ & \verb~~\\
\cellcolor{gray} &  & \verb~401~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~402~ & \verb~    /// Speichert den Knoten unter dem Dateinamen in dem Dateiformat, das in d~\\
\cellcolor{gray} &  & \verb~403~ & \verb~    /// Enthalten entweder die Dateiname-Eigenschaft, die Dateiformat-Eigensch~\\
\cellcolor{gray} &  & \verb~404~ & \verb~    /// oder beide den Wert \glqq null\grqq, dann wird eine IOException geworf~\\
\cellcolor{gray} &  & \verb~405~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~406~ & \verb~    public void Save ()~\\
\cellcolor{red} & 0 & \verb~407~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~408~ & \verb~      if (MetaData.Format == null) {~\\
\cellcolor{red} & 0 & \verb~409~ & \verb~        throw new IOException ("Error: Knot: MetaData.Format is null!");~\\
\cellcolor{gray} &  & \verb~410~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~411~ & \verb~      else if (MetaData.Filename == null) {~\\
\cellcolor{red} & 0 & \verb~412~ & \verb~        throw new IOException ("Error: Knot: MetaData.Filename is null!");~\\
\cellcolor{gray} &  & \verb~413~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~414~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~415~ & \verb~        MetaData.Format.Save (this);~\\
\cellcolor{red} & 0 & \verb~416~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~417~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~418~ & \verb~~\\
\cellcolor{gray} &  & \verb~419~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~420~ & \verb~    /// Erstellt eine vollständige Kopie des Knotens, inklusive der Kanten-Dat~\\
\cellcolor{gray} &  & \verb~421~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~422~ & \verb~    public object Clone ()~\\
\cellcolor{green} & 2 & \verb~423~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~424~ & \verb~      CircleEntry<Edge> newCircle = new CircleEntry<Edge> (startElement as IEn~\\
\cellcolor{green} & 2 & \verb~425~ & \verb~      KnotMetaData metaData = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~426~ & \verb~          name: MetaData.Name,~\\
\cellcolor{red} & 0 & \verb~427~ & \verb~          countEdges: () => 0,~\\
\cellcolor{gray} &  & \verb~428~ & \verb~          format: MetaData.Format,~\\
\cellcolor{gray} &  & \verb~429~ & \verb~          filename: MetaData.Filename~\\
\cellcolor{gray} &  & \verb~430~ & \verb~      );~\\
\cellcolor{green} & 2 & \verb~431~ & \verb~      return new Knot (metaData: metaData, edges: newCircle) {~\\
\cellcolor{gray} &  & \verb~432~ & \verb~        selectedEdges = new HashSet<Edge> (selectedEdges),~\\
\cellcolor{gray} &  & \verb~433~ & \verb~        EdgesChanged = null,~\\
\cellcolor{gray} &  & \verb~434~ & \verb~        SelectionChanged = null,~\\
\cellcolor{gray} &  & \verb~435~ & \verb~      };~\\
\cellcolor{green} & 2 & \verb~436~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~437~ & \verb~~\\
\cellcolor{gray} &  & \verb~438~ & \verb~    private void OnSelectionChanged ()~\\
\cellcolor{green} & 11 & \verb~439~ & \verb~    {~\\
\cellcolor{green} & 11 & \verb~440~ & \verb~      SelectionChanged ();~\\
\cellcolor{green} & 11 & \verb~441~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~442~ & \verb~~\\
\cellcolor{gray} &  & \verb~443~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~444~ & \verb~    /// Fügt die angegebene Kante zur aktuellen Kantenauswahl hinzu.~\\
\cellcolor{gray} &  & \verb~445~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~446~ & \verb~    public void AddToSelection (Edge edge)~\\
\cellcolor{green} & 5 & \verb~447~ & \verb~    {~\\
\cellcolor{green} & 5 & \verb~448~ & \verb~      IEnumerable<CircleEntry<Edge>> found = startElement.Find (edge);~\\
\cellcolor{green} & 10 & \verb~449~ & \verb~      if (found.Any ()) {~\\
\cellcolor{green} & 10 & \verb~450~ & \verb~        if (!selectedEdges.Contains (edge)) {~\\
\cellcolor{green} & 5 & \verb~451~ & \verb~          selectedEdges.Add (edge);~\\
\cellcolor{green} & 5 & \verb~452~ & \verb~        }~\\
\cellcolor{green} & 5 & \verb~453~ & \verb~        lastSelected = found.ElementAt (0);~\\
\cellcolor{green} & 5 & \verb~454~ & \verb~      }~\\
\cellcolor{green} & 5 & \verb~455~ & \verb~      OnSelectionChanged ();~\\
\cellcolor{green} & 5 & \verb~456~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~457~ & \verb~~\\
\cellcolor{gray} &  & \verb~458~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~459~ & \verb~    /// Entfernt die angegebene Kante von der aktuellen Kantenauswahl.~\\
\cellcolor{gray} &  & \verb~460~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~461~ & \verb~    public void RemoveFromSelection (Edge edge)~\\
\cellcolor{green} & 2 & \verb~462~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~463~ & \verb~      selectedEdges.Remove (edge);~\\
\cellcolor{green} & 3 & \verb~464~ & \verb~      if (lastSelected.Value == edge) {~\\
\cellcolor{green} & 1 & \verb~465~ & \verb~        lastSelected = null;~\\
\cellcolor{green} & 1 & \verb~466~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~467~ & \verb~      OnSelectionChanged ();~\\
\cellcolor{green} & 2 & \verb~468~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~469~ & \verb~~\\
\cellcolor{gray} &  & \verb~470~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~471~ & \verb~    /// Hebt die aktuelle Kantenauswahl auf.~\\
\cellcolor{gray} &  & \verb~472~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~473~ & \verb~    public void ClearSelection ()~\\
\cellcolor{green} & 2 & \verb~474~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~475~ & \verb~      selectedEdges.Clear ();~\\
\cellcolor{green} & 2 & \verb~476~ & \verb~      lastSelected = null;~\\
\cellcolor{green} & 2 & \verb~477~ & \verb~      OnSelectionChanged ();~\\
\cellcolor{green} & 2 & \verb~478~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~479~ & \verb~~\\
\cellcolor{gray} &  & \verb~480~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~481~ & \verb~    /// Fügt alle Kanten auf dem kürzesten Weg zwischen der zuletzt ausgewählt~\\
\cellcolor{gray} &  & \verb~482~ & \verb~    /// zur aktuellen Kantenauswahl hinzu. Sind beide Wege gleich lang,~\\
\cellcolor{gray} &  & \verb~483~ & \verb~    /// wird der Weg in Richtung der ersten Kante ausgewählt.~\\
\cellcolor{gray} &  & \verb~484~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~485~ & \verb~    public void AddRangeToSelection (Edge selectedEdge)~\\
\cellcolor{green} & 3 & \verb~486~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~487~ & \verb~      if (lastSelected == null) {~\\
\cellcolor{green} & 1 & \verb~488~ & \verb~        AddToSelection (selectedEdge);~\\
\cellcolor{green} & 1 & \verb~489~ & \verb~        return;~\\
\cellcolor{gray} &  & \verb~490~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~491~ & \verb~      CircleEntry<Edge> selectedCircle = null;~\\
\cellcolor{green} & 4 & \verb~492~ & \verb~      if (startElement.Contains (selectedEdge, out selectedCircle) && selected~\\
\cellcolor{green} & 2 & \verb~493~ & \verb~        List<Edge> forward = new List<Edge> (lastSelected.RangeTo (selectedCir~\\
\cellcolor{green} & 2 & \verb~494~ & \verb~        List<Edge> backward = new List<Edge> (selectedCircle.RangeTo (lastSele~\\
\cellcolor{gray} &  & \verb~495~ & \verb~~\\
\cellcolor{green} & 3 & \verb~496~ & \verb~        if (forward.Count < backward.Count) {~\\
\cellcolor{green} & 12 & \verb~497~ & \verb~          foreach (Edge e in forward) {~\\
\cellcolor{green} & 5 & \verb~498~ & \verb~            if (!selectedEdges.Contains (e)) {~\\
\cellcolor{green} & 2 & \verb~499~ & \verb~              selectedEdges.Add (e);~\\
\cellcolor{green} & 2 & \verb~500~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~501~ & \verb~          }~\\
\cellcolor{green} & 1 & \verb~502~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~503~ & \verb~        else {~\\
\cellcolor{green} & 9 & \verb~504~ & \verb~          foreach (Edge e in backward) {~\\
\cellcolor{green} & 3 & \verb~505~ & \verb~            if (!selectedEdges.Contains (e)) {~\\
\cellcolor{green} & 1 & \verb~506~ & \verb~              selectedEdges.Add (e);~\\
\cellcolor{green} & 1 & \verb~507~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~508~ & \verb~          }~\\
\cellcolor{green} & 1 & \verb~509~ & \verb~        }~\\
\cellcolor{green} & 2 & \verb~510~ & \verb~        lastSelected = selectedCircle;~\\
\cellcolor{green} & 2 & \verb~511~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~512~ & \verb~      OnSelectionChanged ();~\\
\cellcolor{green} & 3 & \verb~513~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~514~ & \verb~~\\
\cellcolor{gray} &  & \verb~515~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~516~ & \verb~    /// Prüft, ob die angegebene Kante in der aktuellen Kantenauswahl enthalte~\\
\cellcolor{gray} &  & \verb~517~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~518~ & \verb~    public Boolean IsSelected (Edge edge)~\\
\cellcolor{red} & 0 & \verb~519~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~520~ & \verb~      return selectedEdges.Contains (edge);~\\
\cellcolor{red} & 0 & \verb~521~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~522~ & \verb~~\\
\cellcolor{gray} &  & \verb~523~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~524~ & \verb~    /// Gibt die doppelt-verkettete Kantenliste als Enumerator zurück.~\\
\cellcolor{gray} &  & \verb~525~ & \verb~    /// [name=IEnumerable.GetEnumerator]~\\
\cellcolor{gray} &  & \verb~526~ & \verb~    /// [keywords= ]~\\
\cellcolor{gray} &  & \verb~527~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~528~ & \verb~    IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{green} & 2 & \verb~529~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~530~ & \verb~      return GetEnumerator (); // just return the generic version~\\
\cellcolor{green} & 2 & \verb~531~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~532~ & \verb~~\\
\cellcolor{gray} &  & \verb~533~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~534~ & \verb~    /// Speichert den Knoten unter dem angegebenen Dateinamen in dem angegeben~\\
\cellcolor{gray} &  & \verb~535~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~536~ & \verb~    public void Save (IKnotIO format, string filename)~\\
\cellcolor{red} & 0 & \verb~537~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~538~ & \verb~      KnotMetaData metaData = new KnotMetaData (MetaData.Name, () => MetaData.~\\
\cellcolor{red} & 0 & \verb~539~ & \verb~      Knot knotToSave = new Knot (metaData, startElement);~\\
\cellcolor{red} & 0 & \verb~540~ & \verb~      format.Save (knotToSave);~\\
\cellcolor{red} & 0 & \verb~541~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~542~ & \verb~~\\
\cellcolor{gray} &  & \verb~543~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~544~ & \verb~    /// Prüft, ob die räumliche Struktur identisch ist, unabhängig von dem Sta~\\
\cellcolor{gray} &  & \verb~545~ & \verb~    /// [parameters=Knot other]~\\
\cellcolor{gray} &  & \verb~546~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~547~ & \verb~    public bool Equals (Knot other)~\\
\cellcolor{green} & 12 & \verb~548~ & \verb~    {~\\
\cellcolor{green} & 12 & \verb~549~ & \verb~      KnotCharakteristic thisCharakteristik = Charakteristic ();~\\
\cellcolor{green} & 12 & \verb~550~ & \verb~      KnotCharakteristic otherCharakteristik = other.Charakteristic ();~\\
\cellcolor{green} & 18 & \verb~551~ & \verb~      if (thisCharakteristik.CountEdges != otherCharakteristik.CountEdges) {~\\
\cellcolor{green} & 6 & \verb~552~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~553~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~554~ & \verb~      // Bei Struktur im gleicher Richtung~\\
\cellcolor{green} & 12 & \verb~555~ & \verb~      if (thisCharakteristik.CharacteristicalEdge.Value.Direction == otherChar~\\
\cellcolor{green} & 6 & \verb~556~ & \verb~        CircleEntry<Edge> currentThisElement = thisCharakteristik.Characterist~\\
\cellcolor{green} & 6 & \verb~557~ & \verb~        CircleEntry<Edge> currentOtherElement = otherCharakteristik.Characteri~\\
\cellcolor{green} & 66 & \verb~558~ & \verb~        while (currentThisElement != thisCharakteristik.CharacteristicalEdge) ~\\
\cellcolor{green} & 30 & \verb~559~ & \verb~          if (currentThisElement.Value.Direction != currentOtherElement.Value.~\\
\cellcolor{red} & 0 & \verb~560~ & \verb~            return false;~\\
\cellcolor{gray} &  & \verb~561~ & \verb~          }~\\
\cellcolor{green} & 30 & \verb~562~ & \verb~          currentThisElement++;~\\
\cellcolor{green} & 30 & \verb~563~ & \verb~          currentOtherElement++;~\\
\cellcolor{green} & 30 & \verb~564~ & \verb~        }~\\
\cellcolor{green} & 6 & \verb~565~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~566~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~567~ & \verb~      // Bei Struktur in entgegengesetzter Richtung~\\
\cellcolor{red} & 0 & \verb~568~ & \verb~      else if (thisCharakteristik.CharacteristicalEdge.Value.Direction == othe~\\
\cellcolor{red} & 0 & \verb~569~ & \verb~        CircleEntry<Edge> currentThisElement = thisCharakteristik.Characterist~\\
\cellcolor{red} & 0 & \verb~570~ & \verb~        CircleEntry<Edge> currentOtherElement = otherCharakteristik.Characteri~\\
\cellcolor{red} & 0 & \verb~571~ & \verb~        while (currentThisElement != thisCharakteristik.CharacteristicalEdge) ~\\
\cellcolor{red} & 0 & \verb~572~ & \verb~          if (currentThisElement.Value.Direction != currentOtherElement.Value.~\\
\cellcolor{red} & 0 & \verb~573~ & \verb~            return false;~\\
\cellcolor{gray} &  & \verb~574~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~575~ & \verb~          currentThisElement++;~\\
\cellcolor{red} & 0 & \verb~576~ & \verb~          currentOtherElement++;~\\
\cellcolor{red} & 0 & \verb~577~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~578~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~579~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~580~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~581~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~582~ & \verb~      }~\\
\cellcolor{green} & 12 & \verb~583~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~584~ & \verb~~\\
\cellcolor{gray} &  & \verb~585~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~586~ & \verb~    /// Gibt chrakteristische Werte zurück, die bei gleichen Knoten gleich sin~\\
\cellcolor{gray} &  & \verb~587~ & \verb~    /// Einmal als Key ein eindeutiges Circle\<Edge\> Element und als Value~\\
\cellcolor{gray} &  & \verb~588~ & \verb~    /// einen Charakteristischen Integer. Momentan die Anzahl der Kanten.~\\
\cellcolor{gray} &  & \verb~589~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~590~ & \verb~    private KnotCharakteristic Charakteristic ()~\\
\cellcolor{green} & 24 & \verb~591~ & \verb~    {~\\
\cellcolor{green} & 35 & \verb~592~ & \verb~      if (CharakteristicCache.HasValue) {~\\
\cellcolor{green} & 11 & \verb~593~ & \verb~        return CharakteristicCache.Value;~\\
\cellcolor{gray} &  & \verb~594~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~595~ & \verb~~\\
\cellcolor{green} & 13 & \verb~596~ & \verb~      CircleEntry<Edge> charakteristikElement = startElement;~\\
\cellcolor{green} & 13 & \verb~597~ & \verb~      Vector3 position3D = startElement.Value.Direction;~\\
\cellcolor{green} & 13 & \verb~598~ & \verb~      Vector3 bestPosition3D = startElement.Value.Direction / 2;~\\
\cellcolor{green} & 13 & \verb~599~ & \verb~      CircleEntry<Edge> edgePointer = startElement.Next;~\\
\cellcolor{gray} &  & \verb~600~ & \verb~~\\
\cellcolor{green} & 13 & \verb~601~ & \verb~      int edgeCount = 1;~\\
\cellcolor{green} & 257 & \verb~602~ & \verb~      for (edgeCount = 1; edgePointer != startElement; edgePointer++, edgeCoun~\\
\cellcolor{green} & 77 & \verb~603~ & \verb~        Vector3 nextPosition3D = position3D + edgePointer.Value.Direction / 2;~\\
\cellcolor{green} & 77 & \verb~604~ & \verb~        if ((nextPosition3D.X < bestPosition3D.X)~\\
\cellcolor{gray} &  & \verb~605~ & \verb~                || (nextPosition3D.X == bestPosition3D.X && nextPosition3D.Y <~\\
\cellcolor{green} & 27 & \verb~606~ & \verb~                || (nextPosition3D.X == bestPosition3D.X && nextPosition3D.Y =~\\
\cellcolor{green} & 27 & \verb~607~ & \verb~          bestPosition3D = position3D + edgePointer.Value.Direction / 2;~\\
\cellcolor{green} & 27 & \verb~608~ & \verb~          charakteristikElement = edgePointer;~\\
\cellcolor{green} & 27 & \verb~609~ & \verb~        }~\\
\cellcolor{green} & 77 & \verb~610~ & \verb~        position3D += edgePointer.Value.Direction;~\\
\cellcolor{green} & 77 & \verb~611~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~612~ & \verb~~\\
\cellcolor{green} & 13 & \verb~613~ & \verb~      CharakteristicCache = new KnotCharakteristic (charakteristikElement, edg~\\
\cellcolor{green} & 13 & \verb~614~ & \verb~      return CharakteristicCache.Value;~\\
\cellcolor{green} & 24 & \verb~615~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~616~ & \verb~~\\
\cellcolor{gray} &  & \verb~617~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 1 & \verb~618~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~619~ & \verb~      return "Knot (name=" + Name + ",#edgecount=" + startElement.Count.ToStri~\\
\cellcolor{gray} &  & \verb~620~ & \verb~             + ",format=" + (MetaData.Format != null ? MetaData.ToString () : ~\\
\cellcolor{gray} &  & \verb~621~ & \verb~             + ")";~\\
\cellcolor{green} & 1 & \verb~622~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~623~ & \verb~~\\
\cellcolor{gray} &  & \verb~624~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~625~ & \verb~~\\
\cellcolor{gray} &  & \verb~626~ & \verb~    #region Classes and Structs~\\
\cellcolor{gray} &  & \verb~627~ & \verb~~\\
\cellcolor{gray} &  & \verb~628~ & \verb~    private struct KnotCharakteristic {~\\
\cellcolor{gray} &  & \verb~629~ & \verb~      public CircleEntry<Edge> CharacteristicalEdge { get; private set; }~\\
\cellcolor{gray} &  & \verb~630~ & \verb~~\\
\cellcolor{gray} &  & \verb~631~ & \verb~      public int CountEdges { get; private set; }~\\
\cellcolor{gray} &  & \verb~632~ & \verb~~\\
\cellcolor{gray} &  & \verb~633~ & \verb~      public KnotCharakteristic (CircleEntry<Edge> characteristicalEdge, int c~\\
\cellcolor{green} & 13 & \verb~634~ & \verb~      : this ()~\\
\cellcolor{green} & 13 & \verb~635~ & \verb~      {~\\
\cellcolor{green} & 13 & \verb~636~ & \verb~        CharacteristicalEdge = characteristicalEdge;~\\
\cellcolor{green} & 13 & \verb~637~ & \verb~        CountEdges = countEdges;~\\
\cellcolor{green} & 13 & \verb~638~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~639~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~640~ & \verb~~\\
\cellcolor{gray} &  & \verb~641~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~642~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~643~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.KnotFileIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.KnotFileIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash KnotFileIO.cs}\end{minipage} \\
\textbf{Coverage:} & 20.5\%\\
\textbf{Covered lines:} & 8\\
\textbf{Uncovered lines:} & 31\\
\textbf{Coverable lines:} & 39\\
\textbf{Total lines:} & 154\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 1 & 100 & 100\\
\hline
\textbf{Save(...)} & 2 & 0 & 0\\
\hline
\textbf{Load(...)} & 2 & 0 & 0\\
\hline
\textbf{LoadMetaData(...)} & 2 & 0 & 0\\
\hline
\textbf{ToString()} & 1 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 50 & 40\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash KnotFileIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// Implementiert das Speicherformat für Knoten.~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  public sealed class KnotFileIO : IKnotIO~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Die für eine Knoten-Datei gültigen Dateiendungen.~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// </summary>~\\
\cellcolor{green} & 64 & \verb~69~ & \verb~    public IEnumerable<string> FileExtensions~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    {~\\
\cellcolor{green} & 64 & \verb~71~ & \verb~      get {~\\
\cellcolor{green} & 64 & \verb~72~ & \verb~        yield return ".knot";~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~        yield return ".knt";~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{green} & 32 & \verb~77~ & \verb~    private Dictionary<string, Knot> KnotCache = new Dictionary<string, Knot> ~\\
\cellcolor{green} & 32 & \verb~78~ & \verb~    private Dictionary<string, KnotMetaData> KnotMetaDataCache = new Dictionar~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// Erstellt ein KnotFileIO-Objekt.~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// </summary>~\\
\cellcolor{green} & 32 & \verb~87~ & \verb~    public KnotFileIO ()~\\
\cellcolor{green} & 32 & \verb~88~ & \verb~    {~\\
\cellcolor{green} & 32 & \verb~89~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    /// Speichert einen Knoten in dem Dateinamen, der in dem Knot-Objekt entha~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    public void Save (Knot knot)~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~      KnotStringIO parser = new KnotStringIO (knot);~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~      Log.Debug ("KnotFileIO.Save (", knot, ") = #", parser.Content.Length);~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~      if (knot.MetaData.Filename == null) {~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~        throw new IOException ("Error! knot has no filename: " + knot);~\\
\cellcolor{gray} &  & \verb~104~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~        File.WriteAllText (knot.MetaData.Filename, parser.Content);~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    /// Lädt eines Knotens aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    public Knot Load (string filename)~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~      if (KnotCache.ContainsKey (filename)) {~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~        return KnotCache [filename];~\\
\cellcolor{gray} &  & \verb~117~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~        Log.Debug ("Load knot from ", filename);~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~        KnotStringIO parser = new KnotStringIO (content: string.Join ("\n", Fi~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~        return KnotCache [filename] = new Knot (~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~            new KnotMetaData (parser.Name, () => parser.CountEdges, this, file~\\
\cellcolor{gray} &  & \verb~123~ & \verb~            parser.Edges~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~125~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~129~ & \verb~    /// Lädt die Metadaten eines Knotens aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~130~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~131~ & \verb~    public KnotMetaData LoadMetaData (string filename)~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~      if (KnotMetaDataCache.ContainsKey (filename)) {~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~        return KnotMetaDataCache [filename];~\\
\cellcolor{gray} &  & \verb~135~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~        KnotStringIO parser = new KnotStringIO (content: string.Join ("\n", Fi~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~        return KnotMetaDataCache [filename] = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~139~ & \verb~            name: parser.Name,~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~            countEdges: () => parser.CountEdges,~\\
\cellcolor{gray} &  & \verb~141~ & \verb~            format: this,~\\
\cellcolor{gray} &  & \verb~142~ & \verb~            filename: filename~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~144~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~    public override string ToString ()~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~      return "KnotFileIO";~\\
\cellcolor{red} & 0 & \verb~150~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~151~ & \verb~~\\
\cellcolor{gray} &  & \verb~152~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~153~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.KnotMetaData}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.KnotMetaData\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash KnotMetaData.cs}\end{minipage} \\
\textbf{Coverage:} & 60.3\%\\
\textbf{Covered lines:} & 32\\
\textbf{Uncovered lines:} & 21\\
\textbf{Coverable lines:} & 53\\
\textbf{Total lines:} & 194\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 3 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 0 & 0\\
\hline
\textbf{Equals(...)} & 2 & 0 & 0\\
\hline
\textbf{GetHashCode()} & 2 & 0 & 0\\
\hline
\textbf{op\_Equality(...)} & 4 & 0 & 0\\
\hline
\textbf{op\_Inequality(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash KnotMetaData.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Platform;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~57~ & \verb~{~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// Enthält Metadaten eines Knotens, die aus einer Spielstand-Datei schnelle~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// als der vollständige Knoten. Dieses Objekt enthält keine Datenstruktur z~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// sondern nur Informationen über den Namen des Knoten und die Anzahl seine~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  /// dazugehöriges Knoten-Objekt existieren, aber jedes Knoten-Objekt enthält~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  public class KnotMetaData : IEquatable<KnotMetaData>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Der Anzeigename des Knotens, welcher auch leer sein kann.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// Beim Speichern muss der Spieler in diesem Fall zwingend~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// einen nichtleeren Namen wählen. Wird ein neuer Anzeigename festgelegt,~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// dann wird der Dateiname ebenfalls auf einen neuen Wert gesetzt, unabhä~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// ob er bereits einen Wert enthält oder \glqq null\grqq ist.~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// Diese Eigenschaft kann öffentlich gelesen und gesetzt werden.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    public string Name~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    {~\\
\cellcolor{green} & 39 & \verb~78~ & \verb~      get {~\\
\cellcolor{green} & 39 & \verb~79~ & \verb~        return name;~\\
\cellcolor{green} & 39 & \verb~80~ & \verb~      }~\\
\cellcolor{green} & 33 & \verb~81~ & \verb~      set {~\\
\cellcolor{green} & 33 & \verb~82~ & \verb~        name = value;~\\
\cellcolor{green} & 65 & \verb~83~ & \verb~        if (Format == null) {~\\
\cellcolor{green} & 32 & \verb~84~ & \verb~          Format = new KnotFileIO ();~\\
\cellcolor{green} & 32 & \verb~85~ & \verb~        }~\\
\cellcolor{green} & 65 & \verb~86~ & \verb~        if (name != null && name.Length > 0) {~\\
\cellcolor{gray} &  & \verb~87~ & \verb~          string extension;~\\
\cellcolor{green} & 64 & \verb~88~ & \verb~          if (Format.FileExtensions.Any ()) {~\\
\cellcolor{green} & 32 & \verb~89~ & \verb~            extension = Format.FileExtensions.ElementAt (0);~\\
\cellcolor{green} & 32 & \verb~90~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~          else {~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~            throw new ArgumentException ("Every implementation of IKnotIO must~\\
\cellcolor{gray} &  & \verb~93~ & \verb~          }~\\
\cellcolor{green} & 32 & \verb~94~ & \verb~          Filename = SystemInfo.SavegameDirectory + SystemInfo.PathSeparator.T~\\
\cellcolor{green} & 32 & \verb~95~ & \verb~        }~\\
\cellcolor{green} & 33 & \verb~96~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    private string name;~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// Das Format, aus dem die Metadaten geladen wurden.~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    /// Es ist genau dann \glqq null\grqq, wenn die Metadaten nicht aus einer ~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// </summary>~\\
\cellcolor{green} & 220 & \verb~105~ & \verb~    public IKnotIO Format { get; private set; }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    /// Ein Delegate, das die Anzahl der Kanten zurückliefert.~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    /// Falls dieses Metadaten-Objekt Teil eines Knotens ist, gibt es dynamisc~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    /// Kanten des Knoten-Objektes zurück. Anderenfalls gibt es eine statische~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    /// die beim Einlesen der Metadaten vor dem Erstellen dieses Objektes gele~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// </summary>~\\
\cellcolor{green} & 3 & \verb~113~ & \verb~    public int CountEdges { get { return countEdges (); } }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    private Func<int> countEdges;~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// Falls die Metadaten aus einer Datei eingelesen wurden, enthält dieses ~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    /// sonst \glqq null\grqq.~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    /// </summary>~\\
\cellcolor{green} & 122 & \verb~121~ & \verb~    public string Filename { get; private set; }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    /// Erstellt ein neues Knoten-Metadaten-Objekt mit einem angegebenen Knote~\\
\cellcolor{gray} &  & \verb~129~ & \verb~    /// und einer angegebenen Funktion, welche eine Kantenanzahl zurück gibt.~\\
\cellcolor{gray} &  & \verb~130~ & \verb~    /// Zusätzlich wird der Dateiname oder das Speicherformat angegeben, aus d~\\
\cellcolor{gray} &  & \verb~131~ & \verb~    /// </summary>~\\
\cellcolor{green} & 32 & \verb~132~ & \verb~    public KnotMetaData (string name, Func<int> countEdges, IKnotIO format, st~\\
\cellcolor{green} & 32 & \verb~133~ & \verb~    {~\\
\cellcolor{green} & 32 & \verb~134~ & \verb~      Name = name;~\\
\cellcolor{green} & 32 & \verb~135~ & \verb~      this.countEdges = countEdges;~\\
\cellcolor{green} & 32 & \verb~136~ & \verb~      Format = format ?? Format;~\\
\cellcolor{green} & 32 & \verb~137~ & \verb~      Filename = filename ?? Filename;~\\
\cellcolor{green} & 32 & \verb~138~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~141~ & \verb~    /// Erstellt ein neues Knoten-Metadaten-Objekt mit einem angegebenen Knote~\\
\cellcolor{gray} &  & \verb~142~ & \verb~    /// und einer angegebenen Funktion, welche eine Kantenanzahl zurück gibt.~\\
\cellcolor{gray} &  & \verb~143~ & \verb~    /// </summary>~\\
\cellcolor{green} & 7 & \verb~144~ & \verb~    public KnotMetaData (string name, Func<int> countEdges)~\\
\cellcolor{green} & 7 & \verb~145~ & \verb~    {~\\
\cellcolor{green} & 7 & \verb~146~ & \verb~      this.name = name;~\\
\cellcolor{green} & 7 & \verb~147~ & \verb~      this.countEdges = countEdges;~\\
\cellcolor{green} & 7 & \verb~148~ & \verb~      Format = null;~\\
\cellcolor{green} & 7 & \verb~149~ & \verb~      Filename = null;~\\
\cellcolor{green} & 7 & \verb~150~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~151~ & \verb~~\\
\cellcolor{gray} &  & \verb~152~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    public bool Equals (KnotMetaData other)~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~158~ & \verb~      return other != null && name == other.name && countEdges () == other.cou~\\
\cellcolor{red} & 0 & \verb~159~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~160~ & \verb~~\\
\cellcolor{gray} &  & \verb~161~ & \verb~    public override bool Equals (object other)~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~      return other != null && Equals (other as KnotMetaData);~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~      return (countEdges ().ToString () + (name ?? String.Empty)).GetHashCode ~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~    public static bool operator == (KnotMetaData a, KnotMetaData b)~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~173~ & \verb~      // If both are null, or both are same instance, return true.~\\
\cellcolor{red} & 0 & \verb~174~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~175~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~176~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~177~ & \verb~~\\
\cellcolor{gray} &  & \verb~178~ & \verb~      // If one is null, but not both, return false.~\\
\cellcolor{red} & 0 & \verb~179~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{red} & 0 & \verb~180~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~181~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~182~ & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & \verb~      // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~      return a.Equals (b);~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{gray} &  & \verb~187~ & \verb~    public static bool operator != (KnotMetaData a, KnotMetaData b)~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~189~ & \verb~      return !(a == b);~\\
\cellcolor{red} & 0 & \verb~190~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~193~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~194~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.KnotStringIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.KnotStringIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash KnotStringIO.cs}\end{minipage} \\
\textbf{Coverage:} & 40.1\%\\
\textbf{Covered lines:} & 49\\
\textbf{Uncovered lines:} & 73\\
\textbf{Coverable lines:} & 122\\
\textbf{Total lines:} & 264\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 63.64 & 100\\
\hline
\textbf{DecodeEdge(...)} & 8 & 30 & 33.33\\
\hline
\textbf{EncodeEdge(...)} & 7 & 63.64 & 61.54\\
\hline
\textbf{EncodeColor(...)} & 1 & 100 & 100\\
\hline
\textbf{DecodeColor(...)} & 4 & 0 & 0\\
\hline
\textbf{ToString()} & 1 & 0 & 0\\
\hline
\textbf{MoveNext()} & 8 & 27.27 & 20\\
\hline
\textbf{MoveNext()} & 5 & 100 & 71.43\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash KnotStringIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~57~ & \verb~{~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// Diese Klasse repräsentiert einen Parser für das Knoten-Austauschformat u~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// eingelesenen Informationen wie den Namen des Knotens und die Kantenliste~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  public sealed class KnotStringIO~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Der Name der eingelesenen Knotendatei oder des zugewiesenen Knotenobje~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// </summary>~\\
\cellcolor{green} & 16 & \verb~69~ & \verb~    public string Name { get; set; }~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    private IEnumerable<string> edgeLines;~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// Die Kanten der eingelesenen Knotendatei oder des zugewiesenen Knotenob~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// </summary>~\\
\cellcolor{green} & 2 & \verb~76~ & \verb~    public IEnumerable<Edge> Edges~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~78~ & \verb~      get {~\\
\cellcolor{green} & 2 & \verb~79~ & \verb~        Log.Debug ("KnotStringIO.Edges[get] = ", edgeLines.Count ());~\\
\cellcolor{green} & 10 & \verb~80~ & \verb~        foreach (string _line in edgeLines) {~\\
\cellcolor{green} & 2 & \verb~81~ & \verb~          string line = _line;~\\
\cellcolor{green} & 2 & \verb~82~ & \verb~          Edge edge = DecodeEdge (line [0]);~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~          line = line.Substring (1);~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~          if (line.StartsWith ("#")) {~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~            line = line.Substring (1);~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~          edge.Color = DecodeColor (line.Substring (0, 8));~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~          line = line.Substring (8);~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~          if (line.StartsWith ("#")) {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~            line = line.Substring (1);~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~          if (line.Length > 0) {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~            foreach (int rect in line.Split (',').Select (int.Parse).ToList ()~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~              edge.Rectangles.Add (rect);~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~          yield return edge;~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~      set {~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~        Log.Debug ("KnotStringIO.Edges[set] = #", value.Count ());~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~        try {~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~          edgeLines = ToLines (value);~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~        catch (Exception ex) {~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~          Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    /// Die Anzahl der Kanten der eingelesenen Knotendatei oder des zugewiesen~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~114~ & \verb~    public int CountEdges~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~        return edgeLines.Where ((l) => l.Trim ().Length > 0).Count ();~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~120~ & \verb~~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~122~ & \verb~    /// Erstellt aus den \glqq Name\grqq - und \glqq Edges\grqq -Eigenschaften~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    /// die als Dateiinhalt in einer Datei eines Spielstandes einen gültigen K~\\
\cellcolor{gray} &  & \verb~124~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    public string Content~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    {~\\
\cellcolor{green} & 10 & \verb~127~ & \verb~      get {~\\
\cellcolor{green} & 10 & \verb~128~ & \verb~        return Name + "\n" + string.Join ("\n", edgeLines);~\\
\cellcolor{green} & 10 & \verb~129~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~130~ & \verb~      set {~\\
\cellcolor{green} & 8 & \verb~131~ & \verb~        if (value.Trim ().Contains ("\n")) {~\\
\cellcolor{green} & 4 & \verb~132~ & \verb~          string[] parts = value.Split (new char[] {'\r','\n'}, StringSplitOpt~\\
\cellcolor{green} & 4 & \verb~133~ & \verb~          Name = parts [0];~\\
\cellcolor{green} & 4 & \verb~134~ & \verb~          edgeLines = parts.Skip (1);~\\
\cellcolor{green} & 4 & \verb~135~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~          Name = value;~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~          edgeLines = new string[] {};~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~        }~\\
\cellcolor{green} & 4 & \verb~140~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~148~ & \verb~    /// Liest das in der angegebenen Zeichenkette enthaltene Dateiformat ein. ~\\
\cellcolor{gray} &  & \verb~149~ & \verb~    /// so werden die \glqq Name\grqq - und \glqq Edges\grqq -Eigenschaften au~\\
\cellcolor{gray} &  & \verb~150~ & \verb~    /// Enthält es einen ungültigen Knoten, so wird eine IOException geworfen ~\\
\cellcolor{gray} &  & \verb~151~ & \verb~    /// </summary>~\\
\cellcolor{green} & 4 & \verb~152~ & \verb~    public KnotStringIO (string content)~\\
\cellcolor{green} & 4 & \verb~153~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~154~ & \verb~      Content = content;~\\
\cellcolor{green} & 4 & \verb~155~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~156~ & \verb~~\\
\cellcolor{gray} &  & \verb~157~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~158~ & \verb~    /// Erstellt ein neues Objekt und setzt die \glqq Name\grqq - und \glqq Ed~\\
\cellcolor{gray} &  & \verb~159~ & \verb~    /// im angegebenen Knoten enthaltenen Werte.~\\
\cellcolor{gray} &  & \verb~160~ & \verb~    /// </summary>~\\
\cellcolor{green} & 2 & \verb~161~ & \verb~    public KnotStringIO (Knot knot)~\\
\cellcolor{green} & 2 & \verb~162~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~163~ & \verb~      Name = knot.Name;~\\
\cellcolor{green} & 2 & \verb~164~ & \verb~      try {~\\
\cellcolor{green} & 2 & \verb~165~ & \verb~        edgeLines = ToLines (knot);~\\
\cellcolor{green} & 2 & \verb~166~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~      catch (Exception ex) {~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~        Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~170~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~171~ & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~173~ & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~175~ & \verb~~\\
\cellcolor{gray} &  & \verb~176~ & \verb~    private static IEnumerable<string> ToLines (IEnumerable<Edge> edges)~\\
\cellcolor{green} & 6 & \verb~177~ & \verb~    {~\\
\cellcolor{green} & 738 & \verb~178~ & \verb~      foreach (Edge edge in edges) {~\\
\cellcolor{green} & 240 & \verb~179~ & \verb~        yield return EncodeEdge (edge) + "#" + EncodeColor (edge.Color) + "#" ~\\
\cellcolor{green} & 240 & \verb~180~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~181~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~182~ & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & \verb~    private static Edge DecodeEdge (char c)~\\
\cellcolor{green} & 2 & \verb~184~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~185~ & \verb~      switch (c) {~\\
\cellcolor{gray} &  & \verb~186~ & \verb~      case 'X':~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~        return Edge.Right;~\\
\cellcolor{gray} &  & \verb~188~ & \verb~      case 'x':~\\
\cellcolor{red} & 0 & \verb~189~ & \verb~        return Edge.Left;~\\
\cellcolor{gray} &  & \verb~190~ & \verb~      case 'Y':~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~        return Edge.Up;~\\
\cellcolor{gray} &  & \verb~192~ & \verb~      case 'y':~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~        return Edge.Down;~\\
\cellcolor{gray} &  & \verb~194~ & \verb~      case 'Z':~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~        return Edge.Backward;~\\
\cellcolor{gray} &  & \verb~196~ & \verb~      case 'z':~\\
\cellcolor{red} & 0 & \verb~197~ & \verb~        return Edge.Forward;~\\
\cellcolor{gray} &  & \verb~198~ & \verb~      default:~\\
\cellcolor{green} & 2 & \verb~199~ & \verb~        throw new IOException ("Failed to decode Edge: '" + c + "'!");~\\
\cellcolor{gray} &  & \verb~200~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~202~ & \verb~~\\
\cellcolor{gray} &  & \verb~203~ & \verb~    private static char EncodeEdge (Edge edge)~\\
\cellcolor{green} & 240 & \verb~204~ & \verb~    {~\\
\cellcolor{green} & 300 & \verb~205~ & \verb~      if (edge.Direction == Direction.Right) {~\\
\cellcolor{green} & 60 & \verb~206~ & \verb~        return 'X';~\\
\cellcolor{gray} &  & \verb~207~ & \verb~      }~\\
\cellcolor{green} & 240 & \verb~208~ & \verb~      else if (edge.Direction == Direction.Left) {~\\
\cellcolor{green} & 60 & \verb~209~ & \verb~        return  'x';~\\
\cellcolor{gray} &  & \verb~210~ & \verb~      }~\\
\cellcolor{green} & 180 & \verb~211~ & \verb~      else if (edge.Direction == Direction.Up) {~\\
\cellcolor{green} & 60 & \verb~212~ & \verb~        return  'Y';~\\
\cellcolor{gray} &  & \verb~213~ & \verb~      }~\\
\cellcolor{green} & 120 & \verb~214~ & \verb~      else if (edge.Direction == Direction.Down) {~\\
\cellcolor{green} & 60 & \verb~215~ & \verb~        return  'y';~\\
\cellcolor{gray} &  & \verb~216~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~217~ & \verb~      else if (edge.Direction == Direction.Backward) {~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~        return  'Z';~\\
\cellcolor{gray} &  & \verb~219~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~      else if (edge.Direction == Direction.Forward) {~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~        return  'z';~\\
\cellcolor{gray} &  & \verb~222~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~223~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~224~ & \verb~        throw new IOException ("Failed to encode Edge: '" + edge + "'!");~\\
\cellcolor{gray} &  & \verb~225~ & \verb~      }~\\
\cellcolor{green} & 240 & \verb~226~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~227~ & \verb~~\\
\cellcolor{gray} &  & \verb~228~ & \verb~    private static String EncodeColor (Color c)~\\
\cellcolor{green} & 240 & \verb~229~ & \verb~    {~\\
\cellcolor{green} & 240 & \verb~230~ & \verb~      return c.R.ToString ("X2") + c.G.ToString ("X2") + c.B.ToString ("X2") +~\\
\cellcolor{green} & 240 & \verb~231~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~232~ & \verb~~\\
\cellcolor{gray} &  & \verb~233~ & \verb~    private static Color DecodeColor (string hexString)~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~      if (hexString.StartsWith ("#")) {~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~        hexString = hexString.Substring (1);~\\
\cellcolor{red} & 0 & \verb~237~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~238~ & \verb~      uint hex = uint.Parse (hexString, System.Globalization.NumberStyles.HexN~\\
\cellcolor{red} & 0 & \verb~239~ & \verb~      Color color = Color.White;~\\
\cellcolor{red} & 0 & \verb~240~ & \verb~      if (hexString.Length == 8) {~\\
\cellcolor{red} & 0 & \verb~241~ & \verb~        color.R = (byte)(hex >> 24);~\\
\cellcolor{red} & 0 & \verb~242~ & \verb~        color.G = (byte)(hex >> 16);~\\
\cellcolor{red} & 0 & \verb~243~ & \verb~        color.B = (byte)(hex >> 8);~\\
\cellcolor{red} & 0 & \verb~244~ & \verb~        color.A = (byte)(hex);~\\
\cellcolor{red} & 0 & \verb~245~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~246~ & \verb~      else if (hexString.Length == 6) {~\\
\cellcolor{red} & 0 & \verb~247~ & \verb~        color.R = (byte)(hex >> 16);~\\
\cellcolor{red} & 0 & \verb~248~ & \verb~        color.G = (byte)(hex >> 8);~\\
\cellcolor{red} & 0 & \verb~249~ & \verb~        color.B = (byte)(hex);~\\
\cellcolor{red} & 0 & \verb~250~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~251~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~252~ & \verb~        throw new IOException ("Invald hex representation of an ARGB or RGB co~\\
\cellcolor{gray} &  & \verb~253~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~254~ & \verb~      return color;~\\
\cellcolor{red} & 0 & \verb~255~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~256~ & \verb~~\\
\cellcolor{gray} &  & \verb~257~ & \verb~    public override string ToString ()~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~259~ & \verb~      return "KnotStringIO (length=" + Content.Length + ")";~\\
\cellcolor{red} & 0 & \verb~260~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~261~ & \verb~~\\
\cellcolor{gray} &  & \verb~262~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~263~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~264~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.Node}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.Node\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Node.cs}\end{minipage} \\
\textbf{Coverage:} & 76.1\%\\
\textbf{Covered lines:} & 51\\
\textbf{Uncovered lines:} & 16\\
\textbf{Coverable lines:} & 67\\
\textbf{Total lines:} & 208\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{CenterBetween(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Addition(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 0 & 0\\
\hline
\textbf{GetHashCode()} & 1 & 100 & 100\\
\hline
\textbf{ToString()} & 1 & 100 & 100\\
\hline
\textbf{Clone()} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 6 & 55.56 & 54.55\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 100 & 60\\
\hline
\textbf{Equals(...)} & 2 & 71.43 & 66.67\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash Node.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Eine Position im 3D-Raster. Die Werte für alle drei Koordinaten sind Int~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Eine Skalierung auf Koordinaten im 3D-Raum und damit einhergehend eine K~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public sealed class Node : IEquatable<Node>, ICloneable~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// X steht für eine x-Koordinate im dreidimensionalen Raster.~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// </summary>~\\
\cellcolor{green} & 152 & \verb~67~ & \verb~    public int X { get; private set; }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// Y steht für eine y-Koordinate im dreidimensionalen Raster.~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    /// </summary>~\\
\cellcolor{green} & 152 & \verb~72~ & \verb~    public int Y { get; private set; }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// Z steht für eine z-Koordinate im dreidimensionalen Raster.~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// </summary>~\\
\cellcolor{green} & 152 & \verb~77~ & \verb~    public int Z { get; private set; }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// Ein Skalierungswert.~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// </summary>~\\
\cellcolor{green} & 1 & \verb~82~ & \verb~    public static readonly int Scale = 100;~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    /// Erzeugt eine neue Instanz eines Node-Objekts und initialisiert diese m~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    /// für die x-, y- und z-Koordinate.~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// </summary>~\\
\cellcolor{green} & 22 & \verb~92~ & \verb~    public Node (int x, int y, int z)~\\
\cellcolor{green} & 22 & \verb~93~ & \verb~    {~\\
\cellcolor{green} & 22 & \verb~94~ & \verb~      X = x;~\\
\cellcolor{green} & 22 & \verb~95~ & \verb~      Y = y;~\\
\cellcolor{green} & 22 & \verb~96~ & \verb~      Z = z;~\\
\cellcolor{green} & 22 & \verb~97~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~104~ & \verb~    /// Liefert die x-, y- und z-Koordinaten im 3D-Raum als ein Vektor3 der Fo~\\
\cellcolor{gray} &  & \verb~105~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    public Vector3 Vector~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    {~\\
\cellcolor{green} & 22 & \verb~108~ & \verb~      get {~\\
\cellcolor{green} & 22 & \verb~109~ & \verb~        return new Vector3 (X * Scale, Y * Scale, Z * Scale);~\\
\cellcolor{green} & 22 & \verb~110~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~112~ & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & \verb~    public static implicit operator Vector3 (Node node)~\\
\cellcolor{green} & 14 & \verb~114~ & \verb~    {~\\
\cellcolor{green} & 14 & \verb~115~ & \verb~      return node.Vector;~\\
\cellcolor{green} & 14 & \verb~116~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    public Vector3 CenterBetween (Node other)~\\
\cellcolor{green} & 4 & \verb~119~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~120~ & \verb~      Vector3 positionFrom = this.Vector;~\\
\cellcolor{green} & 4 & \verb~121~ & \verb~      Vector3 positionTo = other.Vector;~\\
\cellcolor{green} & 4 & \verb~122~ & \verb~      return positionFrom + (positionTo - positionFrom) / 2;~\\
\cellcolor{green} & 4 & \verb~123~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    public static Node operator + (Node a, Vector3 b)~\\
\cellcolor{green} & 1 & \verb~126~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~127~ & \verb~      return new Node (a.X + (int)b.X, a.Y + (int)b.Y, a.Z + (int)b.Z);~\\
\cellcolor{green} & 1 & \verb~128~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & \verb~    public static Vector3 operator - (Node a, Node b)~\\
\cellcolor{green} & 1 & \verb~131~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~132~ & \verb~      return new Vector3 (a.X - b.X, a.Y - b.Y, a.Z - b.Z);~\\
\cellcolor{green} & 1 & \verb~133~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~134~ & \verb~~\\
\cellcolor{gray} &  & \verb~135~ & \verb~    public static Node operator + (Node a, Direction b)~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~      return new Node (a.X + (int)b.Vector.X, a.Y + (int)b.Vector.Y, a.Z + (in~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    public static Node operator - (Node a, Direction b)~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~      return new Node (a.X - (int)b.Vector.X, a.Y - (int)b.Vector.Y, a.Z - (in~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & \verb~    public static Node operator + (Direction a, Node b)~\\
\cellcolor{red} & 0 & \verb~146~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~147~ & \verb~      return b+a;~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~149~ & \verb~~\\
\cellcolor{gray} &  & \verb~150~ & \verb~    public static Node operator - (Direction a, Node b)~\\
\cellcolor{red} & 0 & \verb~151~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~      return b-a;~\\
\cellcolor{red} & 0 & \verb~153~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{green} & 35 & \verb~156~ & \verb~    {~\\
\cellcolor{green} & 35 & \verb~157~ & \verb~      return X * 10000 + Y * 100 + Z;~\\
\cellcolor{green} & 35 & \verb~158~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~    public override string ToString ()~\\
\cellcolor{green} & 1 & \verb~161~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~162~ & \verb~      return "(" + X.ToString () + "," + Y.ToString () + "," + Z.ToString () +~\\
\cellcolor{green} & 1 & \verb~163~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public object Clone ()~\\
\cellcolor{green} & 1 & \verb~166~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~167~ & \verb~      return new Node (X, Y, Z);~\\
\cellcolor{green} & 1 & \verb~168~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~169~ & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & \verb~    public static bool operator == (Node a, Node b)~\\
\cellcolor{green} & 2 & \verb~171~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~172~ & \verb~      // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 2 & \verb~173~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~174~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~175~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~      // If one is null, but not both, return false.~\\
\cellcolor{green} & 2 & \verb~178~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{red} & 0 & \verb~179~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~180~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~181~ & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & \verb~      // Return true if the fields match:~\\
\cellcolor{green} & 2 & \verb~183~ & \verb~      return a.X == b.X && a.Y == b.Y && a.Z == b.Z;~\\
\cellcolor{green} & 2 & \verb~184~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~185~ & \verb~~\\
\cellcolor{gray} &  & \verb~186~ & \verb~    public static bool operator != (Node a, Node b)~\\
\cellcolor{green} & 1 & \verb~187~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~188~ & \verb~      return !(a == b);~\\
\cellcolor{green} & 1 & \verb~189~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~190~ & \verb~~\\
\cellcolor{gray} &  & \verb~191~ & \verb~    public bool Equals (Node other)~\\
\cellcolor{green} & 32 & \verb~192~ & \verb~    {~\\
\cellcolor{green} & 32 & \verb~193~ & \verb~      return this.X == other.X && this.Y == other.Y && this.Z == other.Z;~\\
\cellcolor{green} & 32 & \verb~194~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~195~ & \verb~~\\
\cellcolor{gray} &  & \verb~196~ & \verb~    public override bool Equals (object obj)~\\
\cellcolor{green} & 2 & \verb~197~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~198~ & \verb~      if (obj is Node) {~\\
\cellcolor{green} & 2 & \verb~199~ & \verb~        return Equals ((Node)obj);~\\
\cellcolor{gray} &  & \verb~200~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~202~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~203~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~204~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~207~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~208~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.NodeMap}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.NodeMap\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash NodeMap.cs}\end{minipage} \\
\textbf{Coverage:} & 88.5\%\\
\textbf{Covered lines:} & 54\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 61\\
\textbf{Total lines:} & 175\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 2 & 100 & 66.67\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{NodeBeforeEdge(...)} & 1 & 100 & 100\\
\hline
\textbf{NodeAfterEdge(...)} & 1 & 100 & 100\\
\hline
\textbf{JunctionsAtNode(...)} & 1 & 100 & 100\\
\hline
\textbf{JunctionsBeforeEdge(} & 1 & 100 & 100\\
\hline
\textbf{JunctionsAfterEdge(.} & 1 & 100 & 100\\
\hline
\textbf{OnEdgesChanged()} & 1 & 0 & 0\\
\hline
\textbf{BuildIndex()} & 5 & 100 & 77.78\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash NodeMap.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// Eine Zuordnung zwischen Kanten und den dreidimensionalen Rasterpunkten, ~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public sealed class NodeMap : INodeMap~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{green} & 1 & \verb~64~ & \verb~    private Hashtable fromMap = new Hashtable ();~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~    private Hashtable toMap = new Hashtable ();~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~    private Dictionary<Node, List<IJunction>> junctionMap = new Dictionary<Nod~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Die Skalierung, die bei einer Konvertierung in einen Vector3 des XNA-F~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    public int Scale { get; set; }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{green} & 11 & \verb~73~ & \verb~    public IEnumerable<Edge> Edges { get; set; }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{green} & 3 & \verb~75~ & \verb~    public Vector3 Offset { get; set; }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{green} & 11 & \verb~77~ & \verb~    public Action IndexRebuilt { get; set; }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{green} & 1 & \verb~83~ & \verb~    public NodeMap ()~\\
\cellcolor{green} & 1 & \verb~84~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~85~ & \verb~      IndexRebuilt = () => {};~\\
\cellcolor{green} & 1 & \verb~86~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{green} & 1 & \verb~88~ & \verb~    public NodeMap (IEnumerable<Edge> edges)~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    : this ()~\\
\cellcolor{green} & 1 & \verb~90~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~91~ & \verb~      Edges = edges;~\\
\cellcolor{green} & 1 & \verb~92~ & \verb~      BuildIndex ();~\\
\cellcolor{green} & 1 & \verb~93~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// Gibt die Rasterposition des Übergangs am Anfang der Kante zurück.~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    public Node NodeBeforeEdge (Edge edge)~\\
\cellcolor{green} & 8 & \verb~103~ & \verb~    {~\\
\cellcolor{green} & 8 & \verb~104~ & \verb~      return (Node)fromMap [edge];~\\
\cellcolor{green} & 8 & \verb~105~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    /// Gibt die Rasterposition des Übergangs am Ende der Kante zurück.~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    public Node NodeAfterEdge (Edge edge)~\\
\cellcolor{green} & 32 & \verb~111~ & \verb~    {~\\
\cellcolor{green} & 32 & \verb~112~ & \verb~      return (Node)toMap [edge];~\\
\cellcolor{green} & 32 & \verb~113~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    public List<IJunction> JunctionsAtNode (Node node)~\\
\cellcolor{green} & 16 & \verb~116~ & \verb~    {~\\
\cellcolor{green} & 16 & \verb~117~ & \verb~      return junctionMap [node];~\\
\cellcolor{green} & 16 & \verb~118~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~119~ & \verb~~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    public List<IJunction> JunctionsBeforeEdge (Edge edge)~\\
\cellcolor{green} & 4 & \verb~121~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~122~ & \verb~      return junctionMap [NodeBeforeEdge (edge)];~\\
\cellcolor{green} & 4 & \verb~123~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~    public List<IJunction> JunctionsAfterEdge (Edge edge)~\\
\cellcolor{green} & 4 & \verb~126~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~127~ & \verb~      return junctionMap [NodeAfterEdge (edge)];~\\
\cellcolor{green} & 4 & \verb~128~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & \verb~    public IEnumerable<Node> Nodes~\\
\cellcolor{gray} &  & \verb~131~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~      get {~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~        return junctionMap.Keys;~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~136~ & \verb~~\\
\cellcolor{gray} &  & \verb~137~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    /// Aktualisiert die Zuordnung, wenn sich die Kanten geändert haben.~\\
\cellcolor{gray} &  & \verb~139~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    public void OnEdgesChanged ()~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~      BuildIndex ();~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & \verb~    private void BuildIndex ()~\\
\cellcolor{green} & 1 & \verb~146~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~147~ & \verb~      fromMap.Clear ();~\\
\cellcolor{green} & 1 & \verb~148~ & \verb~      toMap.Clear ();~\\
\cellcolor{green} & 3 & \verb~149~ & \verb~      float x = Offset.X, y = Offset.Y, z = Offset.Z;~\\
\cellcolor{green} & 15 & \verb~150~ & \verb~      foreach (Edge edge in Edges) {~\\
\cellcolor{green} & 4 & \verb~151~ & \verb~        fromMap [edge] = new Node ((int)x, (int)y, (int)z);~\\
\cellcolor{green} & 4 & \verb~152~ & \verb~        Vector3 v = edge.Direction.Vector;~\\
\cellcolor{green} & 4 & \verb~153~ & \verb~        x += v.X;~\\
\cellcolor{green} & 4 & \verb~154~ & \verb~        y += v.Y;~\\
\cellcolor{green} & 4 & \verb~155~ & \verb~        z += v.Z;~\\
\cellcolor{green} & 4 & \verb~156~ & \verb~        toMap [edge] = new Node ((int)x, (int)y, (int)z);~\\
\cellcolor{green} & 4 & \verb~157~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{green} & 2 & \verb~159~ & \verb~      IndexRebuilt = () => {};~\\
\cellcolor{green} & 1 & \verb~160~ & \verb~      junctionMap.Clear ();~\\
\cellcolor{green} & 1 & \verb~161~ & \verb~      List<Edge> EdgeList = Edges.ToList ();~\\
\cellcolor{green} & 14 & \verb~162~ & \verb~      for (int n = 0; n < EdgeList.Count; n++) {~\\
\cellcolor{green} & 4 & \verb~163~ & \verb~        Edge edgeA = Edges.At (n);~\\
\cellcolor{green} & 4 & \verb~164~ & \verb~        Edge edgeB = Edges.At (n + 1);~\\
\cellcolor{green} & 4 & \verb~165~ & \verb~        Node node = NodeAfterEdge (edgeA);~\\
\cellcolor{green} & 4 & \verb~166~ & \verb~        IJunction junction = new NodeModelInfo (nodeMap: this, from: edgeA, to~\\
\cellcolor{green} & 4 & \verb~167~ & \verb~        junctionMap.Add (node, junction);~\\
\cellcolor{green} & 4 & \verb~168~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~169~ & \verb~~\\
\cellcolor{green} & 1 & \verb~170~ & \verb~      IndexRebuilt ();~\\
\cellcolor{green} & 1 & \verb~171~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~172~ & \verb~~\\
\cellcolor{gray} &  & \verb~173~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~174~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~175~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.PrinterIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.PrinterIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash PrinterIO.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 10\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 110\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 1 & 0 & 0\\
\hline
\textbf{Save(...)} & 1 & 0 & 0\\
\hline
\textbf{Load(...)} & 1 & 0 & 0\\
\hline
\textbf{LoadMetaData(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash PrinterIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~55~ & \verb~{~\\
\cellcolor{gray} &  & \verb~56~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  /// Ein Exportformat für 3D-Drucker.~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public class PrinterIO : IKnotIO~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// Die gültigen Dateiendungen für das 3D-Drucker-Format.~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~    public IEnumerable<string> FileExtensions { get; set; }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    /// Erstellt ein neues PrinterIO-Objekt.~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// </summary>~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    public PrinterIO ()~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      throw new System.NotImplementedException ();~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    /// Exportiert den Knoten in einem gültigen 3D-Drucker-Format.~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    public virtual void Save (Knot knot)~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~      throw new System.NotImplementedException ();~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// Gibt eine IOException zurück.~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    public virtual Knot Load (string filename)~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      throw new System.NotImplementedException ();~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    /// Gibt eine IOException zurück.~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    public virtual KnotMetaData LoadMetaData (string filename)~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~      throw new System.NotImplementedException ();~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~109~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.RectangleMap}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.RectangleMap\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash RectangleMap.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 53\\
\textbf{Coverable lines:} & 53\\
\textbf{Total lines:} & 172\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{AddEdge(...)} & 1 & 0 & 0\\
\hline
\textbf{AddEdge(...)} & 3 & 0 & 0\\
\hline
\textbf{ContainsEdge(...)} & 7 & 0 & 0\\
\hline
\textbf{MoveNext()} & 13 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash RectangleMap.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public sealed class RectangleMap~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    private INodeMap NodeMap;~\\
\cellcolor{red} & 0 & \verb~62~ & \verb~    private Dictionary<Vector3, List<PossibleRectanglePosition>> positions~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        = new Dictionary<Vector3, List<PossibleRectanglePosition>> ();~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~    public RectangleMap (INodeMap nodeMap)~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      NodeMap = nodeMap;~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~75~ & \verb~~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~    public void AddEdge (Edge edge, bool isVirtual)~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~      Node a = NodeMap.NodeBeforeEdge (edge);~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~      Node b = NodeMap.NodeAfterEdge (edge);~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~      AddEdge (edge, a, b, isVirtual);~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    public void AddEdge (Edge edge, Node nodeA, Node nodeB, bool isVirtual)~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~      Vector3 edgeCenter = nodeA.CenterBetween (nodeB);~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~      foreach (Direction direction in Direction.Values) {~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~        if (direction.Axis != edge.Direction.Axis) {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~          Vector3 rectangleCenter = edgeCenter + direction * Node.Scale / 2;~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~          PossibleRectanglePosition rectanglePosition = new PossibleRectangleP~\\
\cellcolor{gray} &  & \verb~92~ & \verb~            Edge = edge,~\\
\cellcolor{gray} &  & \verb~93~ & \verb~            NodeA = nodeA,~\\
\cellcolor{gray} &  & \verb~94~ & \verb~            NodeB = nodeB,~\\
\cellcolor{gray} &  & \verb~95~ & \verb~            Position = rectangleCenter,~\\
\cellcolor{gray} &  & \verb~96~ & \verb~            IsVirtual = isVirtual~\\
\cellcolor{gray} &  & \verb~97~ & \verb~          };~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~          positions.Add (rectangleCenter, rectanglePosition);~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~    public bool ContainsEdge (Node a, Node b)~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~      foreach (List<PossibleRectanglePosition> many in positions.Values) {~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~        foreach (PossibleRectanglePosition position in many) {~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~          if ((position.NodeA == a && position.NodeB == b) || (position.NodeA ~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~            return true;~\\
\cellcolor{gray} &  & \verb~109~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~      return false;~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    public IEnumerable<ValidRectanglePosition> ValidPositions ()~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~      foreach (List<PossibleRectanglePosition> many in positions.Values) {~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~        foreach (var pair in many.SelectMany ((value, index) => many.Skip (ind~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~        (first, second) => new { first, second })) {~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~          List<PossibleRectanglePosition> pos~\\
\cellcolor{gray} &  & \verb~121~ & \verb~              = new PossibleRectanglePosition[] { pair.first, pair.second } .T~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~          if (pos.Count == 2) {~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~            for (int i = 0; i <= 1; ++i) {~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~              int first = i % 2;~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~              int second = (i + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~              Edge edgeAB = pos [first].Edge;~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~              Edge edgeCD = pos [second].Edge;~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~              Node nodeA = pos [first].NodeA;~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~              Node nodeB = pos [first].NodeB;~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~              Node nodeC = pos [second].NodeA;~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~              Node nodeD = pos [second].NodeB;~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~              if (nodeB == nodeC || (nodeA-nodeB) == (nodeC-nodeD)) {~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~                var valid = new ValidRectanglePosition {~\\
\cellcolor{gray} &  & \verb~134~ & \verb~                  EdgeAB = edgeAB,~\\
\cellcolor{gray} &  & \verb~135~ & \verb~                  EdgeCD = edgeCD,~\\
\cellcolor{gray} &  & \verb~136~ & \verb~                  NodeA = nodeA,~\\
\cellcolor{gray} &  & \verb~137~ & \verb~                  NodeB = nodeB,~\\
\cellcolor{gray} &  & \verb~138~ & \verb~                  NodeC = nodeC,~\\
\cellcolor{gray} &  & \verb~139~ & \verb~                  NodeD = nodeD,~\\
\cellcolor{gray} &  & \verb~140~ & \verb~                  Position = pos[first].Position,~\\
\cellcolor{gray} &  & \verb~141~ & \verb~                  IsVirtual = pos[first].IsVirtual || pos[second].IsVirtual~\\
\cellcolor{gray} &  & \verb~142~ & \verb~                };~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~                yield return valid;~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~              }~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~146~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~147~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~152~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~  public struct PossibleRectanglePosition {~\\
\cellcolor{gray} &  & \verb~155~ & \verb~    public Edge Edge;~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    public Node NodeA;~\\
\cellcolor{gray} &  & \verb~157~ & \verb~    public Node NodeB;~\\
\cellcolor{gray} &  & \verb~158~ & \verb~    public Vector3 Position;~\\
\cellcolor{gray} &  & \verb~159~ & \verb~    public bool IsVirtual;~\\
\cellcolor{gray} &  & \verb~160~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~161~ & \verb~~\\
\cellcolor{gray} &  & \verb~162~ & \verb~  public struct ValidRectanglePosition {~\\
\cellcolor{gray} &  & \verb~163~ & \verb~    public Edge EdgeAB;~\\
\cellcolor{gray} &  & \verb~164~ & \verb~    public Edge EdgeCD;~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public Node NodeA;~\\
\cellcolor{gray} &  & \verb~166~ & \verb~    public Node NodeB;~\\
\cellcolor{gray} &  & \verb~167~ & \verb~    public Node NodeC;~\\
\cellcolor{gray} &  & \verb~168~ & \verb~    public Node NodeD;~\\
\cellcolor{gray} &  & \verb~169~ & \verb~    public Vector3 Position;~\\
\cellcolor{gray} &  & \verb~170~ & \verb~    public bool IsVirtual;~\\
\cellcolor{gray} &  & \verb~171~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~172~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Data.ZipHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Data.ZipHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash ChallengeFileIO.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 7\\
\textbf{Total lines:} & 261\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ReadContent(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Data\textbackslash ChallengeFileIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Ionic.Zip;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~namespace Knot3.Data~\\
\cellcolor{gray} &  & \verb~60~ & \verb~{~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  /// Implementiert das Speicherformat für Challenges.~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~  public sealed class ChallengeFileIO : IChallengeIO~\\
\cellcolor{gray} &  & \verb~65~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    /// Die für eine Knoten-Datei gültigen Dateiendungen.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    public IEnumerable<string> FileExtensions~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~73~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        yield return ".challenge";~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        yield return ".chl";~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        yield return ".chn";~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        yield return ".chg";~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        yield return ".chlng";~\\
\cellcolor{gray} &  & \verb~79~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    #region Constructors~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    /// Erstellt ein ChallengeFileIO-Objekt.~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    public ChallengeFileIO ()~\\
\cellcolor{gray} &  & \verb~90~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~    /// Speichert eine Challenge in dem Dateinamen, der in dem Challenge-Objek~\\
\cellcolor{gray} &  & \verb~99~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    public void Save (Challenge challenge)~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~102~ & \verb~      using (ZipFile zip = new ZipFile ()) {~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        // Namen~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        zip.AddEntry ("name.txt", challenge.Name);~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        // Startknoten~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        KnotStringIO parser = new KnotStringIO (challenge.Start);~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        zip.AddEntry ("start.knot", parser.Content);~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        // Zielknoten~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        parser = new KnotStringIO (challenge.Target);~\\
\cellcolor{gray} &  & \verb~110~ & \verb~        zip.AddEntry ("target.knot", parser.Content);~\\
\cellcolor{gray} &  & \verb~111~ & \verb~        // Highscore~\\
\cellcolor{gray} &  & \verb~112~ & \verb~        zip.AddEntry ("highscore.txt", string.Join ("\n", printHighscore (chal~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        // ZIP-Datei speichern~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        zip.Save (challenge.MetaData.Filename);~\\
\cellcolor{gray} &  & \verb~115~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~119~ & \verb~    /// Lädt eine Challenge aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~120~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    public Challenge Load (string filename)~\\
\cellcolor{gray} &  & \verb~122~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~123~ & \verb~      ChallengeMetaData meta = LoadMetaData (filename: filename);~\\
\cellcolor{gray} &  & \verb~124~ & \verb~      Knot start = null;~\\
\cellcolor{gray} &  & \verb~125~ & \verb~      Knot target = null;~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~      using (ZipFile zip = ZipFile.Read (filename)) {~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        foreach (ZipEntry entry in zip) {~\\
\cellcolor{gray} &  & \verb~129~ & \verb~          string content = entry.ReadContent ();~\\
\cellcolor{gray} &  & \verb~130~ & \verb~~\\
\cellcolor{gray} &  & \verb~131~ & \verb~          // für die Datei mit dem Startknoten~\\
\cellcolor{gray} &  & \verb~132~ & \verb~          if (entry.FileName.ToLower ().Contains ("start")) {~\\
\cellcolor{gray} &  & \verb~133~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{gray} &  & \verb~134~ & \verb~            start = new Knot (~\\
\cellcolor{gray} &  & \verb~135~ & \verb~                new KnotMetaData (parser.Name, () => parser.CountEdges, null, ~\\
\cellcolor{gray} &  & \verb~136~ & \verb~                parser.Edges~\\
\cellcolor{gray} &  & \verb~137~ & \verb~            );~\\
\cellcolor{gray} &  & \verb~138~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~          // für die Datei mit dem Zielknoten~\\
\cellcolor{gray} &  & \verb~141~ & \verb~          else if (entry.FileName.ToLower ().Contains ("target")) {~\\
\cellcolor{gray} &  & \verb~142~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{gray} &  & \verb~143~ & \verb~            target = new Knot (~\\
\cellcolor{gray} &  & \verb~144~ & \verb~                new KnotMetaData (parser.Name, () => parser.CountEdges, null, ~\\
\cellcolor{gray} &  & \verb~145~ & \verb~                parser.Edges~\\
\cellcolor{gray} &  & \verb~146~ & \verb~            );~\\
\cellcolor{gray} &  & \verb~147~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~149~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~      if (meta != null && start != null && target != null) {~\\
\cellcolor{gray} &  & \verb~152~ & \verb~        return new Challenge (meta, start, target);~\\
\cellcolor{gray} &  & \verb~153~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~155~ & \verb~        throw new IOException (~\\
\cellcolor{gray} &  & \verb~156~ & \verb~            "Error! Invalid challenge file: " + filename~\\
\cellcolor{gray} &  & \verb~157~ & \verb~            + " (meta=" + meta + ",start=" + start + ",target=" + target + ")"~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~159~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~160~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~161~ & \verb~~\\
\cellcolor{gray} &  & \verb~162~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~163~ & \verb~    /// Lädt die Metadaten einer Challenge aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~164~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~165~ & \verb~    public ChallengeMetaData LoadMetaData (string filename)~\\
\cellcolor{gray} &  & \verb~166~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~167~ & \verb~      string name = null;~\\
\cellcolor{gray} &  & \verb~168~ & \verb~      KnotMetaData start = null;~\\
\cellcolor{gray} &  & \verb~169~ & \verb~      KnotMetaData target = null;~\\
\cellcolor{gray} &  & \verb~170~ & \verb~      IEnumerable<KeyValuePair<string, int>> highscore = null;~\\
\cellcolor{gray} &  & \verb~171~ & \verb~      using (ZipFile zip = ZipFile.Read (filename)) {~\\
\cellcolor{gray} &  & \verb~172~ & \verb~        foreach (ZipEntry entry in zip) {~\\
\cellcolor{gray} &  & \verb~173~ & \verb~          string content = entry.ReadContent ();~\\
\cellcolor{gray} &  & \verb~174~ & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & \verb~          // für die Datei mit dem Startknoten~\\
\cellcolor{gray} &  & \verb~176~ & \verb~          if (entry.FileName.ToLower ().Contains ("start")) {~\\
\cellcolor{gray} &  & \verb~177~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{gray} &  & \verb~178~ & \verb~            start = new KnotMetaData (parser.Name, () => parser.CountEdges, nu~\\
\cellcolor{gray} &  & \verb~179~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~          // für die Datei mit dem Zielknoten~\\
\cellcolor{gray} &  & \verb~182~ & \verb~          else if (entry.FileName.ToLower ().Contains ("target")) {~\\
\cellcolor{gray} &  & \verb~183~ & \verb~            KnotStringIO parser = new KnotStringIO (content: content);~\\
\cellcolor{gray} &  & \verb~184~ & \verb~            target = new KnotMetaData (parser.Name, () => parser.CountEdges, n~\\
\cellcolor{gray} &  & \verb~185~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{gray} &  & \verb~187~ & \verb~          // für die Datei mit dem Namen~\\
\cellcolor{gray} &  & \verb~188~ & \verb~          else if (entry.FileName.ToLower ().Contains ("name")) {~\\
\cellcolor{gray} &  & \verb~189~ & \verb~            name = content.Trim ();~\\
\cellcolor{gray} &  & \verb~190~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & \verb~          // für die Datei mit den Highscores~\\
\cellcolor{gray} &  & \verb~193~ & \verb~          else if (entry.FileName.ToLower ().Contains ("highscore")) {~\\
\cellcolor{gray} &  & \verb~194~ & \verb~            highscore = parseHighscore (content.Split (new char[] {'\r','\n'},~\\
\cellcolor{gray} &  & \verb~195~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~198~ & \verb~      if (name != null && start != null && target != null) {~\\
\cellcolor{gray} &  & \verb~199~ & \verb~        Log.Debug ("Load challenge file: ", filename, " (name=", name, ",start~\\
\cellcolor{gray} &  & \verb~200~ & \verb~        return new ChallengeMetaData (~\\
\cellcolor{gray} &  & \verb~201~ & \verb~                   name: name,~\\
\cellcolor{gray} &  & \verb~202~ & \verb~                   start: start,~\\
\cellcolor{gray} &  & \verb~203~ & \verb~                   target: target,~\\
\cellcolor{gray} &  & \verb~204~ & \verb~                   filename: filename,~\\
\cellcolor{gray} &  & \verb~205~ & \verb~                   format: this,~\\
\cellcolor{gray} &  & \verb~206~ & \verb~                   highscore: highscore~\\
\cellcolor{gray} &  & \verb~207~ & \verb~               );~\\
\cellcolor{gray} &  & \verb~208~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~209~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~210~ & \verb~        throw new IOException (~\\
\cellcolor{gray} &  & \verb~211~ & \verb~            "Error! Invalid challenge file: " + filename~\\
\cellcolor{gray} &  & \verb~212~ & \verb~            + " (name=" + name + ",start=" + start + ",target=" + target + ",h~\\
\cellcolor{gray} &  & \verb~213~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~214~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~215~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~216~ & \verb~~\\
\cellcolor{gray} &  & \verb~217~ & \verb~    IEnumerable<string> printHighscore (IEnumerable<KeyValuePair<string, int>>~\\
\cellcolor{gray} &  & \verb~218~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~219~ & \verb~      foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{gray} &  & \verb~220~ & \verb~        Log.Debug (~\\
\cellcolor{gray} &  & \verb~221~ & \verb~            "Save Highscore: "~\\
\cellcolor{gray} &  & \verb~222~ & \verb~            + entry.Value.ToString ()~\\
\cellcolor{gray} &  & \verb~223~ & \verb~            + ":"~\\
\cellcolor{gray} &  & \verb~224~ & \verb~            + entry.Key.ToString ()~\\
\cellcolor{gray} &  & \verb~225~ & \verb~        );~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & \verb~        yield return entry.Value + ":" + entry.Key;~\\
\cellcolor{gray} &  & \verb~228~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~229~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & \verb~    IEnumerable<KeyValuePair<string, int>> parseHighscore (IEnumerable<string>~\\
\cellcolor{gray} &  & \verb~232~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~233~ & \verb~      foreach (string line in highscore) {~\\
\cellcolor{gray} &  & \verb~234~ & \verb~        Log.Debug ("Load Highscore: ",line);~\\
\cellcolor{gray} &  & \verb~235~ & \verb~        if (line.Contains (":")) {~\\
\cellcolor{gray} &  & \verb~236~ & \verb~          string[] entry = line.Split (new char[] {':'}, 2, StringSplitOptions~\\
\cellcolor{gray} &  & \verb~237~ & \verb~          string name = entry [1].Trim ();~\\
\cellcolor{gray} &  & \verb~238~ & \verb~          int time;~\\
\cellcolor{gray} &  & \verb~239~ & \verb~          if (Int32.TryParse (entry [0], out time)) {~\\
\cellcolor{gray} &  & \verb~240~ & \verb~            Log.Debug ("=> ", name, ":", time);~\\
\cellcolor{gray} &  & \verb~241~ & \verb~            yield return new KeyValuePair<string, int> (name, time);~\\
\cellcolor{gray} &  & \verb~242~ & \verb~          }~\\
\cellcolor{gray} &  & \verb~243~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~244~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~245~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~246~ & \verb~~\\
\cellcolor{gray} &  & \verb~247~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~248~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~249~ & \verb~~\\
\cellcolor{gray} &  & \verb~250~ & \verb~  static class ZipHelper~\\
\cellcolor{gray} &  & \verb~251~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~252~ & \verb~    public static string ReadContent (this ZipEntry entry)~\\
\cellcolor{red} & 0 & \verb~253~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~254~ & \verb~      MemoryStream memory = new MemoryStream ();~\\
\cellcolor{red} & 0 & \verb~255~ & \verb~      entry.Extract (memory);~\\
\cellcolor{red} & 0 & \verb~256~ & \verb~      memory.Position = 0;~\\
\cellcolor{red} & 0 & \verb~257~ & \verb~      var sr = new StreamReader (memory);~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~      return sr.ReadToEnd ();~\\
\cellcolor{red} & 0 & \verb~259~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~260~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~261~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Platform.SystemInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Platform.SystemInfo\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Platform\textbackslash SystemInfo.cs\\\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Platform\textbackslash SystemInfo-XNA.cs}\end{minipage} \\
\textbf{Coverage:} & 88.6\%\\
\textbf{Covered lines:} & 70\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 79\\
\textbf{Total lines:} & 259\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{IsRunningOnMono()} & 1 & 100 & 100\\
\hline
\textbf{IsRunningOnMonogame(} & 1 & 100 & 100\\
\hline
\textbf{IsRunningOnLinux()} & 1 & 100 & 100\\
\hline
\textbf{IsRunningOnWindows()} & 1 & 100 & 100\\
\hline
\textbf{findBaseDirectory()} & 3 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Platform\textbackslash SystemInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Security.Cryptography;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Utilities;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Platform~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public static partial class SystemInfo~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    #region Properties~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    /// Das Einstellungsverzeichnis.~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    public static string SettingsDirectory~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    {~\\
\cellcolor{green} & 35 & \verb~68~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        string directory;~\\
\cellcolor{green} & 35 & \verb~70~ & \verb~        if (SystemInfo.IsRunningOnLinux ()) {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~          directory = Environment.GetEnvironmentVariable ("HOME") + "/.knot3/"~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~        }~\\
\cellcolor{green} & 35 & \verb~73~ & \verb~        else {~\\
\cellcolor{green} & 35 & \verb~74~ & \verb~          directory = Environment.GetFolderPath (System.Environment.SpecialFol~\\
\cellcolor{green} & 35 & \verb~75~ & \verb~        }~\\
\cellcolor{green} & 35 & \verb~76~ & \verb~        Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 35 & \verb~77~ & \verb~        return directory;~\\
\cellcolor{green} & 35 & \verb~78~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    /// Das Spielstandverzeichnis.~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    public static string SavegameDirectory~\\
\cellcolor{gray} &  & \verb~85~ & \verb~    {~\\
\cellcolor{green} & 33 & \verb~86~ & \verb~      get {~\\
\cellcolor{green} & 33 & \verb~87~ & \verb~        string directory = SettingsDirectory + "Savegames";~\\
\cellcolor{green} & 33 & \verb~88~ & \verb~        Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 33 & \verb~89~ & \verb~        return directory;~\\
\cellcolor{green} & 33 & \verb~90~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    /// Das Bildschirmfotoverzeichnis.~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    public static string ScreenshotDirectory~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~98~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        string directory;~\\
\cellcolor{green} & 1 & \verb~100~ & \verb~        if (SystemInfo.IsRunningOnLinux ()) {~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~          directory = Environment.GetEnvironmentVariable ("HOME");~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~103~ & \verb~        else {~\\
\cellcolor{green} & 1 & \verb~104~ & \verb~          directory = Environment.GetFolderPath (System.Environment.SpecialFol~\\
\cellcolor{green} & 1 & \verb~105~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~106~ & \verb~        Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 1 & \verb~107~ & \verb~        return directory;~\\
\cellcolor{green} & 1 & \verb~108~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    public static string DecodedMusicCache~\\
\cellcolor{gray} &  & \verb~112~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~113~ & \verb~      get {~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        string directory;~\\
\cellcolor{green} & 1 & \verb~115~ & \verb~        if (SystemInfo.IsRunningOnLinux ()) {~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~          directory = "/var/tmp/knot3/";~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~118~ & \verb~        else {~\\
\cellcolor{green} & 1 & \verb~119~ & \verb~          directory = Environment.GetFolderPath (System.Environment.SpecialFol~\\
\cellcolor{green} & 1 & \verb~120~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~121~ & \verb~        Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 1 & \verb~122~ & \verb~        return directory;~\\
\cellcolor{green} & 1 & \verb~123~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~125~ & \verb~~\\
\cellcolor{gray} &  & \verb~126~ & \verb~    public static string BaseDirectory~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    {~\\
\cellcolor{green} & 2 & \verb~128~ & \verb~      get {~\\
\cellcolor{green} & 4 & \verb~129~ & \verb~        if (baseDirectory != null) {~\\
\cellcolor{green} & 2 & \verb~130~ & \verb~          return baseDirectory;~\\
\cellcolor{gray} &  & \verb~131~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~          findBaseDirectory ();~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~          return baseDirectory;~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        }~\\
\cellcolor{green} & 2 & \verb~136~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~~\\
\cellcolor{gray} &  & \verb~139~ & \verb~    public static string RelativeBaseDirectory~\\
\cellcolor{gray} &  & \verb~140~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~141~ & \verb~      get {~\\
\cellcolor{green} & 5 & \verb~142~ & \verb~        if (relativeBaseDirectory != null) {~\\
\cellcolor{green} & 2 & \verb~143~ & \verb~          return relativeBaseDirectory;~\\
\cellcolor{gray} &  & \verb~144~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~145~ & \verb~        else {~\\
\cellcolor{green} & 1 & \verb~146~ & \verb~          findBaseDirectory ();~\\
\cellcolor{green} & 1 & \verb~147~ & \verb~          return relativeBaseDirectory;~\\
\cellcolor{gray} &  & \verb~148~ & \verb~        }~\\
\cellcolor{green} & 3 & \verb~149~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~151~ & \verb~~\\
\cellcolor{gray} &  & \verb~152~ & \verb~    private static void findBaseDirectory ()~\\
\cellcolor{green} & 1 & \verb~153~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~154~ & \verb~      string baseDir = Directory.GetCurrentDirectory ();~\\
\cellcolor{green} & 1 & \verb~155~ & \verb~      string relBaseDir = "." + PathSeparator;~\\
\cellcolor{green} & 1 & \verb~156~ & \verb~      string[] binDirectories = new string[] {~\\
\cellcolor{gray} &  & \verb~157~ & \verb~        "Debug",~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        "Release",~\\
\cellcolor{gray} &  & \verb~159~ & \verb~        "x86",~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        "bin"~\\
\cellcolor{gray} &  & \verb~161~ & \verb~      };~\\
\cellcolor{green} & 15 & \verb~162~ & \verb~      foreach (string dir in binDirectories) {~\\
\cellcolor{green} & 6 & \verb~163~ & \verb~        if (baseDir.ToLower ().EndsWith (dir.ToLower ())) {~\\
\cellcolor{green} & 2 & \verb~164~ & \verb~          baseDir = baseDir.Substring (0, baseDir.Length - dir.Length - 1);~\\
\cellcolor{green} & 2 & \verb~165~ & \verb~          relBaseDir += ".." + PathSeparator;~\\
\cellcolor{green} & 2 & \verb~166~ & \verb~        }~\\
\cellcolor{green} & 4 & \verb~167~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~168~ & \verb~      Log.Debug ("Base directory: ", baseDir);~\\
\cellcolor{green} & 1 & \verb~169~ & \verb~      baseDirectory = baseDir;~\\
\cellcolor{green} & 1 & \verb~170~ & \verb~      Log.Debug ("Base directory (relative): ", relBaseDir);~\\
\cellcolor{green} & 1 & \verb~171~ & \verb~      relativeBaseDirectory = relBaseDir;~\\
\cellcolor{green} & 1 & \verb~172~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~173~ & \verb~~\\
\cellcolor{green} & 1 & \verb~174~ & \verb~    private static string relativeBaseDirectory = null;~\\
\cellcolor{green} & 1 & \verb~175~ & \verb~    private static string baseDirectory = null;~\\
\cellcolor{green} & 1 & \verb~176~ & \verb~    public readonly static char PathSeparator = Path.DirectorySeparatorChar;~\\
\cellcolor{gray} &  & \verb~177~ & \verb~~\\
\cellcolor{gray} &  & \verb~178~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~179~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~}~\\
\end{longtable}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Platform\textbackslash SystemInfo-XNA.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Platform~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public static partial class SystemInfo~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~    public static bool IsRunningOnMono ()~\\
\cellcolor{green} & 1 & \verb~60~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~61~ & \verb~      return false;~\\
\cellcolor{green} & 1 & \verb~62~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    public static bool IsRunningOnMonogame ()~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~      return false;~\\
\cellcolor{green} & 1 & \verb~67~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    public static bool IsRunningOnLinux ()~\\
\cellcolor{green} & 86 & \verb~70~ & \verb~    {~\\
\cellcolor{green} & 86 & \verb~71~ & \verb~      return false;~\\
\cellcolor{green} & 86 & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    public static bool IsRunningOnWindows ()~\\
\cellcolor{green} & 1 & \verb~75~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~76~ & \verb~      return true;~\\
\cellcolor{green} & 1 & \verb~77~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.BoundingCylinder}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.BoundingCylinder\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash BoundingCylinder.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 24\\
\textbf{Coverable lines:} & 24\\
\textbf{Total lines:} & 85\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Equality(...)} & 4 & 0 & 0\\
\hline
\textbf{op\_Inequality(...)} & 1 & 0 & 0\\
\hline
\textbf{Equals(...)} & 3 & 0 & 0\\
\hline
\textbf{Equals(...)} & 2 & 0 & 0\\
\hline
\textbf{GetHashCode()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash BoundingCylinder.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~  public struct BoundingCylinder : IEquatable<BoundingCylinder> {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    public Vector3 SideA;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    public Vector3 SideB;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    public float Radius;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    public BoundingCylinder (Vector3 sideA, Vector3 sideB, float radius)~\\
\cellcolor{red} & 0 & \verb~47~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~48~ & \verb~      this.SideA = sideA;~\\
\cellcolor{red} & 0 & \verb~49~ & \verb~      this.SideB = sideB;~\\
\cellcolor{red} & 0 & \verb~50~ & \verb~      this.Radius = radius;~\\
\cellcolor{red} & 0 & \verb~51~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~    public static bool operator == (BoundingCylinder a, BoundingCylinder b)~\\
\cellcolor{red} & 0 & \verb~54~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~55~ & \verb~      if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~56~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~57~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~58~ & \verb~      if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{red} & 0 & \verb~59~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~60~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~61~ & \verb~      return a.Equals (b);~\\
\cellcolor{red} & 0 & \verb~62~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    public static bool operator != (BoundingCylinder a, BoundingCylinder b)~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~      return !(a == b);~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    public bool Equals (BoundingCylinder other)~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      return SideA == other.SideA && SideB == other.SideB && Radius == other.R~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    public override bool Equals (object other)~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~      return other != null && Equals ((BoundingCylinder)other);~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    public override int GetHashCode ()~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~81~ & \verb~      // irgendwas möglichst eindeutiges~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~      return (Radius * (SideA + SideB)).GetHashCode ();~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.ColorHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.ColorHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash ColorHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 10\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 75\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{Mix(...)} & 1 & 0 & 0\\
\hline
\textbf{Luminance(...)} & 1 & 0 & 0\\
\hline
\textbf{SortColorsByLuminanc} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash ColorHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public static class ColorHelper~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~    public static Color Mix (this Color a, Color b, float percent = 0.5f)~\\
\cellcolor{red} & 0 & \verb~60~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~61~ & \verb~      percent = MathHelper.Clamp (percent, 0f, 1f);~\\
\cellcolor{red} & 0 & \verb~62~ & \verb~      return new Color (a.ToVector3 () * (1f - percent) + b.ToVector3 () * per~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    public static int Luminance (this Color color)~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~      return (color.R * 3 + color.B + color.G * 4) >> 3;~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~    public static int SortColorsByLuminance (Color left, Color right)~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      return left.Luminance ().CompareTo (right.Luminance ());~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~75~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.DictionaryHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.DictionaryHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash DictionaryHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 6\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 6\\
\textbf{Total lines:} & 69\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{Add(...)} & 4 & 100 & 60\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash DictionaryHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public static class DictionaryHelper~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~    public static void Add<KeyType, ListType, ValueType> (this Dictionary<KeyT~\\
\cellcolor{gray} &  & \verb~60~ & \verb~            KeyType key, ValueType value)~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    where ListType : IList<ValueType>, new ()~\\
\cellcolor{green} & 4 & \verb~62~ & \verb~    {~\\
\cellcolor{green} & 8 & \verb~63~ & \verb~      if (!dict.ContainsKey (key)) {~\\
\cellcolor{green} & 4 & \verb~64~ & \verb~        dict.Add (key, new ListType ());~\\
\cellcolor{green} & 4 & \verb~65~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~66~ & \verb~      dict [key].Add (value);~\\
\cellcolor{green} & 4 & \verb~67~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.EnumHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.EnumHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash EnumHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 14.2\%\\
\textbf{Covered lines:} & 7\\
\textbf{Uncovered lines:} & 42\\
\textbf{Coverable lines:} & 49\\
\textbf{Total lines:} & 140\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{GetDescriptionTable(} & 3 & 0 & 0\\
\hline
\textbf{ToEnumValues()} & 1 & 0 & 0\\
\hline
\textbf{ToEnumDescription(..} & 4 & 0 & 0\\
\hline
\textbf{ToEnumValue(...)} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 6 & 84.62 & 66.67\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash EnumHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.ComponentModel;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Reflection;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~57~ & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~59~ & \verb~{~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  public static class EnumHelper~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    public static IEnumerable<string> ToEnumDescriptions<T> (this IEnumerable<~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~      foreach (T val in enumValues) {~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~        yield return val.ToEnumDescription<T> ();~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    public static Hashtable GetDescriptionTable<T> ()~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      Hashtable table = new Hashtable ();~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      foreach (T val in ToEnumValues<T>()) {~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~        string descr = val.ToEnumDescription<T> ();~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~        table [val] = descr;~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~        table [descr] = val;~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      return table;~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    public static IEnumerable<T> ToEnumValues<T> ()~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~      Type enumType = typeof (T);~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      return enumType.ToEnumValues<T> ();~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    public static IEnumerable<T> ToEnumValues<T> (this Type enumType)~\\
\cellcolor{green} & 3 & \verb~88~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~89~ & \verb~      if (enumType.BaseType != typeof (Enum)) {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        throw new ArgumentException ("T must be of type System.Enum");~\\
\cellcolor{gray} &  & \verb~91~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{green} & 3 & \verb~93~ & \verb~      Array enumValArray = Enum.GetValues (enumType);~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{green} & 63 & \verb~95~ & \verb~      foreach (int val in enumValArray) {~\\
\cellcolor{green} & 18 & \verb~96~ & \verb~        yield return (T)Enum.Parse (enumType, val.ToString ());~\\
\cellcolor{green} & 18 & \verb~97~ & \verb~      }~\\
\cellcolor{green} & 3 & \verb~98~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    public static string ToEnumDescription<T> (this T value)~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~      Type enumType = typeof (T);~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~      if (enumType.BaseType != typeof (Enum)) {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~        throw new ArgumentException ("T must be of type System.Enum");~\\
\cellcolor{gray} &  & \verb~106~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~      FieldInfo fi = value.GetType ().GetField (value.ToString ());~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~      DescriptionAttribute[] attributes =~\\
\cellcolor{gray} &  & \verb~111~ & \verb~          (DescriptionAttribute[])fi.GetCustomAttributes (~\\
\cellcolor{gray} &  & \verb~112~ & \verb~              typeof (DescriptionAttribute),~\\
\cellcolor{gray} &  & \verb~113~ & \verb~              false);~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~      if (attributes != null && attributes.Length > 0) {~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~        return attributes [0].Description;~\\
\cellcolor{gray} &  & \verb~117~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~        return value.ToString ();~\\
\cellcolor{gray} &  & \verb~120~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~    public static T ToEnumValue<T> (this string value)~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~      Type enumType = typeof (T);~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~      if (enumType.BaseType != typeof (Enum)) {~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~        throw new ArgumentException ("T must be of type System.Enum");~\\
\cellcolor{gray} &  & \verb~128~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~      T returnValue = default (T);~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~      foreach (T enumVal in ToEnumValues<T>()) {~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~        if (enumVal.ToEnumDescription<T> () == value) {~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~          returnValue = enumVal;~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~          break;~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~      return returnValue;~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~140~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.FileIndex}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.FileIndex\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash FileIndex.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 24\\
\textbf{Coverable lines:} & 24\\
\textbf{Total lines:} & 99\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{Add(...)} & 1 & 0 & 0\\
\hline
\textbf{Remove(...)} & 1 & 0 & 0\\
\hline
\textbf{Contains(...)} & 1 & 0 & 0\\
\hline
\textbf{Save()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash FileIndex.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.ComponentModel;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using System.Reflection;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~60~ & \verb~{~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  public class FileIndex~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    private HashSet<string> hashes;~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    private string filename;~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~    public FileIndex (string filename)~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~      this.filename = filename;~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~      try {~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~        hashes = new HashSet<string> (FileUtility.ReadFrom (filename));~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      catch (IOException) {~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~        hashes = new HashSet<string> ();~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    public void Add (string hash)~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~      hashes.Add (hash);~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~      Save ();~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    public void Remove (string hash)~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~      hashes.Remove (hash);~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~      Save ();~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~88~ & \verb~~\\
\cellcolor{gray} &  & \verb~89~ & \verb~    public bool Contains (string hash)~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~      return hashes.Contains (hash);~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    private void Save ()~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~      File.WriteAllText (filename, string.Join ("\n", hashes));~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.FileUtility}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.FileUtility\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash FileUtility.cs}\end{minipage} \\
\textbf{Coverage:} & 36.1\%\\
\textbf{Covered lines:} & 13\\
\textbf{Uncovered lines:} & 23\\
\textbf{Coverable lines:} & 36\\
\textbf{Total lines:} & 129\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ConvertToFileName(..} & 2 & 100 & 100\\
\hline
\textbf{GetHash(...)} & 1 & 0 & 0\\
\hline
\textbf{ToMD5Hash(...)} & 2 & 0 & 0\\
\hline
\textbf{SearchFiles(...)} & 3 & 0 & 0\\
\hline
\textbf{SearchFiles(...)} & 3 & 100 & 80\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash FileUtility.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Security.Cryptography;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  /// Eine Hilfsklasse für Dateioperationen.~\\
\cellcolor{gray} &  & \verb~61~ & \verb~  /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~  public static class FileUtility~\\
\cellcolor{gray} &  & \verb~63~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    #region Methods~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    /// Konvertiert einen Namen eines Knotens oder einer Challenge in einen gü~\\
\cellcolor{gray} &  & \verb~68~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~    public static string ConvertToFileName (string name)~\\
\cellcolor{green} & 32 & \verb~70~ & \verb~    {~\\
\cellcolor{green} & 32 & \verb~71~ & \verb~      char[] arr = name.ToCharArray ();~\\
\cellcolor{green} & 182 & \verb~72~ & \verb~      arr = Array.FindAll<char> (arr, (c => (char.IsLetterOrDigit (c)~\\
\cellcolor{gray} &  & \verb~73~ & \verb~                                             || char.IsWhiteSpace (c)~\\
\cellcolor{gray} &  & \verb~74~ & \verb~                                             || c == '-'))~\\
\cellcolor{gray} &  & \verb~75~ & \verb~                                );~\\
\cellcolor{green} & 32 & \verb~76~ & \verb~      return new string (arr);~\\
\cellcolor{green} & 32 & \verb~77~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~    /// Liefert einen Hash-Wert zu der durch filename spezifizierten Datei.~\\
\cellcolor{gray} &  & \verb~81~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~    public static string GetHash (string filename)~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      return string.Join ("\n", FileUtility.ReadFrom (filename)).ToMD5Hash ();~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~    public static string ToMD5Hash (this string TextToHash)~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~      if (string.IsNullOrEmpty (TextToHash)) {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        return string.Empty;~\\
\cellcolor{gray} &  & \verb~91~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~      MD5 md5 = new MD5CryptoServiceProvider ();~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~      byte[] textToHash = Encoding.Default.GetBytes (TextToHash);~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~      byte[] result = md5.ComputeHash (textToHash);~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      return System.BitConverter.ToString (result);~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    public static IEnumerable<string> ReadFrom (string file)~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~102~ & \verb~      string line;~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~      using (var reader = File.OpenText (file)) {~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~        while ((line = reader.ReadLine ()) != null) {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~          yield return line;~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    public static void SearchFiles (IEnumerable<string> directories, IEnumerab~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~      foreach (string directory in directories) {~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~        SearchFiles (directory, extensions, add);~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~    public static void SearchFiles (string directory, IEnumerable<string> exte~\\
\cellcolor{green} & 6 & \verb~118~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~119~ & \verb~      Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 6 & \verb~120~ & \verb~      var files = Directory.GetFiles (directory, "*.*", SearchOption.AllDirect~\\
\cellcolor{green} & 36 & \verb~121~ & \verb~                  .Where (s => extensions.Any (e => s.EndsWith (e)));~\\
\cellcolor{green} & 36 & \verb~122~ & \verb~      foreach (string file in files) {~\\
\cellcolor{green} & 6 & \verb~123~ & \verb~        add (file);~\\
\cellcolor{green} & 6 & \verb~124~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~125~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~128~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.FrustumHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.FrustumHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash FrustumHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 85\\
\textbf{Coverable lines:} & 85\\
\textbf{Total lines:} & 172\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{GetNegativeVertex(..} & 4 & 0 & 0\\
\hline
\textbf{GetPositiveVertex(..} & 4 & 0 & 0\\
\hline
\textbf{FastIntersects(...)} & 2 & 0 & 0\\
\hline
\textbf{FastIntersects(...)} & 8 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash FrustumHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public static class FrustumHelper~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~    public static Vector3 GetNegativeVertex (this BoundingBox aabb, ref Vector~\\
\cellcolor{red} & 0 & \verb~60~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~61~ & \verb~      Vector3 p = aabb.Max;~\\
\cellcolor{red} & 0 & \verb~62~ & \verb~      if (normal.X >= 0) {~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~        p.X = aabb.Min.X;~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~      if (normal.Y >= 0) {~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~        p.Y = aabb.Min.Y;~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~      if (normal.Z >= 0) {~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~        p.Z = aabb.Min.Z;~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      return p;~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    public static Vector3 GetPositiveVertex (this BoundingBox aabb, ref Vector~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      Vector3 p = aabb.Min;~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~      if (normal.X >= 0) {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~        p.X = aabb.Max.X;~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~      if (normal.Y >= 0) {~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~        p.Y = aabb.Max.Y;~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      if (normal.Z >= 0) {~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~        p.Z = aabb.Max.Z;~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~      return p;~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    public static bool FastIntersects (this BoundingFrustum boundingfrustum, r~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~      if (boundingfrustum == null) {~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~95~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~      var box = BoundingBox.CreateFromSphere (aabb);~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      return boundingfrustum.FastIntersects (ref box);~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~    public static bool FastIntersects (this BoundingFrustum boundingfrustum, r~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~      if (boundingfrustum == null) {~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~104~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & \verb~      Plane plane;~\\
\cellcolor{gray} &  & \verb~107~ & \verb~      Vector3 normal, p;~\\
\cellcolor{gray} &  & \verb~108~ & \verb~~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~      plane = boundingfrustum.Bottom;~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~      normal = plane.Normal;~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~      normal.X = -normal.X;~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~      normal.Y = -normal.Y;~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~      normal.Z = -normal.Z;~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~      p = aabb.GetPositiveVertex (ref normal);~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~      if (-plane.D + normal.X * p.X + normal.Y * p.Y + normal.Z * p.Z < 0) {~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~117~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~118~ & \verb~~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~      plane = boundingfrustum.Far;~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~      normal = plane.Normal;~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~      normal.X = -normal.X;~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~      normal.Y = -normal.Y;~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~      normal.Z = -normal.Z;~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~      p = aabb.GetPositiveVertex (ref normal);~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~      if (-plane.D + normal.X * p.X + normal.Y * p.Y + normal.Z * p.Z < 0) {~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~127~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~      plane = boundingfrustum.Left;~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~      normal = plane.Normal;~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~      normal.X = -normal.X;~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~      normal.Y = -normal.Y;~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~      normal.Z = -normal.Z;~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~      p = aabb.GetPositiveVertex (ref normal);~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~      if (-plane.D + normal.X * p.X + normal.Y * p.Y + normal.Z * p.Z < 0) {~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~137~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~      plane = boundingfrustum.Near;~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~      normal = plane.Normal;~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~      normal.X = -normal.X;~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~      normal.Y = -normal.Y;~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~      normal.Z = -normal.Z;~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~      p = aabb.GetPositiveVertex (ref normal);~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~      if (-plane.D + normal.X * p.X + normal.Y * p.Y + normal.Z * p.Z < 0) {~\\
\cellcolor{red} & 0 & \verb~146~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~147~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~      plane = boundingfrustum.Right;~\\
\cellcolor{red} & 0 & \verb~150~ & \verb~      normal = plane.Normal;~\\
\cellcolor{red} & 0 & \verb~151~ & \verb~      normal.X = -normal.X;~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~      normal.Y = -normal.Y;~\\
\cellcolor{red} & 0 & \verb~153~ & \verb~      normal.Z = -normal.Z;~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~      p = aabb.GetPositiveVertex (ref normal);~\\
\cellcolor{red} & 0 & \verb~155~ & \verb~      if (-plane.D + normal.X * p.X + normal.Y * p.Y + normal.Z * p.Z < 0) {~\\
\cellcolor{red} & 0 & \verb~156~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~157~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{red} & 0 & \verb~159~ & \verb~      plane = boundingfrustum.Top;~\\
\cellcolor{red} & 0 & \verb~160~ & \verb~      normal = plane.Normal;~\\
\cellcolor{red} & 0 & \verb~161~ & \verb~      normal.X = -normal.X;~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~      normal.Y = -normal.Y;~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~      normal.Z = -normal.Z;~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~      p = aabb.GetPositiveVertex (ref normal);~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~      if (-plane.D + normal.X * p.X + normal.Y * p.Y + normal.Z * p.Z < 0) {~\\
\cellcolor{red} & 0 & \verb~166~ & \verb~        return false;~\\
\cellcolor{gray} &  & \verb~167~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~168~ & \verb~~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~      return true;~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~171~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~172~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.IniFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.IniFile\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash IniFile.cs}\end{minipage} \\
\textbf{Coverage:} & 81.1\%\\
\textbf{Covered lines:} & 56\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 69\\
\textbf{Total lines:} & 129\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 9 & 100 & 70.59\\
\hline
\textbf{Dispose()} & 1 & 0 & 0\\
\hline
\textbf{Dispose(...)} & 2 & 0 & 0\\
\hline
\textbf{Save()} & 8 & 100 & 80\\
\hline
\textbf{StripComments(...)} & 3 & 66.67 & 60\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash IniFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Globalization;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~  public sealed class IniFile : IDisposable~\\
\cellcolor{gray} &  & \verb~41~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    private string Filename;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    public Dictionary<string, Dictionary<string, string>> Data;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{green} & 3 & \verb~45~ & \verb~    public IniFile (string filename)~\\
\cellcolor{green} & 3 & \verb~46~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~47~ & \verb~      Data = new Dictionary<string, Dictionary<string, string>> ();~\\
\cellcolor{green} & 3 & \verb~48~ & \verb~      Filename = filename;~\\
\cellcolor{green} & 6 & \verb~49~ & \verb~      if (File.Exists (filename)) {~\\
\cellcolor{green} & 6 & \verb~50~ & \verb~        using (StreamReader reader = new StreamReader (filename)) {~\\
\cellcolor{green} & 3 & \verb~51~ & \verb~          string section = null;~\\
\cellcolor{green} & 2705 & \verb~52~ & \verb~          while (reader.Peek () != -1) {~\\
\cellcolor{green} & 1351 & \verb~53~ & \verb~            string line = StripComments (reader.ReadLine ().Trim ());~\\
\cellcolor{green} & 1702 & \verb~54~ & \verb~            if (line.StartsWith ("[") && line.EndsWith ("]")) {~\\
\cellcolor{green} & 351 & \verb~55~ & \verb~              section = line.Substring (1, line.Length - 2);~\\
\cellcolor{green} & 702 & \verb~56~ & \verb~              if (!Data.ContainsKey (section)) {~\\
\cellcolor{green} & 351 & \verb~57~ & \verb~                Data [section] = new Dictionary<string,string> ();~\\
\cellcolor{green} & 351 & \verb~58~ & \verb~              }~\\
\cellcolor{green} & 351 & \verb~59~ & \verb~            }~\\
\cellcolor{green} & 2000 & \verb~60~ & \verb~            else if (line.Contains ("=")) {~\\
\cellcolor{green} & 1000 & \verb~61~ & \verb~              string[] parts = line.Split ('=');~\\
\cellcolor{green} & 2000 & \verb~62~ & \verb~              if (section != null) {~\\
\cellcolor{green} & 1000 & \verb~63~ & \verb~                Data [section] [parts [0].Trim ()] = parts [1].Trim ();~\\
\cellcolor{green} & 1000 & \verb~64~ & \verb~              }~\\
\cellcolor{green} & 1000 & \verb~65~ & \verb~            }~\\
\cellcolor{green} & 1351 & \verb~66~ & \verb~          }~\\
\cellcolor{green} & 3 & \verb~67~ & \verb~        }~\\
\cellcolor{green} & 3 & \verb~68~ & \verb~      }~\\
\cellcolor{green} & 3 & \verb~69~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    public void Dispose ()~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~      Dispose (true);~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      GC.SuppressFinalize (this);~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    private void Dispose (bool disposing)~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~      if (disposing) {~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~        Save ();~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    public void Save ()~\\
\cellcolor{green} & 404 & \verb~85~ & \verb~    {~\\
\cellcolor{green} & 808 & \verb~86~ & \verb~      using (StreamWriter writer = new StreamWriter (Filename)) {~\\
\cellcolor{green} & 13708 & \verb~87~ & \verb~        foreach (string section in Data.Keys.OrderBy (x => x)) {~\\
\cellcolor{green} & 3124 & \verb~88~ & \verb~          writer.WriteLine ("[" + section + "]");~\\
\cellcolor{green} & 132308 & \verb~89~ & \verb~          foreach (string key  in Data[section].Keys.OrderBy (x => x)) {~\\
\cellcolor{green} & 30734 & \verb~90~ & \verb~            writer.WriteLine (key + "=" + Data [section] [key]);~\\
\cellcolor{green} & 30734 & \verb~91~ & \verb~          }~\\
\cellcolor{green} & 3124 & \verb~92~ & \verb~        }~\\
\cellcolor{green} & 404 & \verb~93~ & \verb~      }~\\
\cellcolor{green} & 404 & \verb~94~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~    private static string StripComments (string line)~\\
\cellcolor{green} & 1351 & \verb~97~ & \verb~    {~\\
\cellcolor{green} & 2702 & \verb~98~ & \verb~      if (line != null) {~\\
\cellcolor{green} & 1351 & \verb~99~ & \verb~        if (line.IndexOf (';') != -1) {~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~          return line.Remove (line.IndexOf (';')).Trim ();~\\
\cellcolor{gray} &  & \verb~101~ & \verb~        }~\\
\cellcolor{green} & 1351 & \verb~102~ & \verb~        return line.Trim ();~\\
\cellcolor{gray} &  & \verb~103~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~      return string.Empty;~\\
\cellcolor{green} & 1351 & \verb~105~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~    public string this [string section, string key, string defaultValue = null~\\
\cellcolor{gray} &  & \verb~108~ & \verb~    {~\\
\cellcolor{green} & 525 & \verb~109~ & \verb~      get {~\\
\cellcolor{green} & 535 & \verb~110~ & \verb~        if (!Data.ContainsKey (section)) {~\\
\cellcolor{green} & 10 & \verb~111~ & \verb~          Data [section] = new Dictionary<string,string> ();~\\
\cellcolor{green} & 10 & \verb~112~ & \verb~        }~\\
\cellcolor{green} & 625 & \verb~113~ & \verb~        if (!Data [section].ContainsKey (key)) {~\\
\cellcolor{green} & 100 & \verb~114~ & \verb~          Data [section] [key] = defaultValue;~\\
\cellcolor{green} & 100 & \verb~115~ & \verb~          Save ();~\\
\cellcolor{green} & 100 & \verb~116~ & \verb~        }~\\
\cellcolor{green} & 525 & \verb~117~ & \verb~        string value = Data [section] [key];~\\
\cellcolor{green} & 525 & \verb~118~ & \verb~        return value;~\\
\cellcolor{green} & 525 & \verb~119~ & \verb~      }~\\
\cellcolor{green} & 304 & \verb~120~ & \verb~      set {~\\
\cellcolor{green} & 304 & \verb~121~ & \verb~        if (!Data.ContainsKey (section)) {~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~          Data [section] = new Dictionary<string,string> ();~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~        }~\\
\cellcolor{green} & 304 & \verb~124~ & \verb~        Data [section] [key] = value;~\\
\cellcolor{green} & 304 & \verb~125~ & \verb~        Save ();~\\
\cellcolor{green} & 304 & \verb~126~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.InputHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.InputHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash InputHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 10\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 82\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{IsDown(...)} & 3 & 0 & 0\\
\hline
\textbf{IsHeldDown(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash InputHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public static class InputHelper~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    /// Wurde die aktuelle Taste gedrückt und war sie im letzten Frame nicht g~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    public static bool IsDown (this Keys key)~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~64~ & \verb~      // Is the key down?~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~      if (InputManager.CurrentKeyboardState.IsKeyDown (key)) {~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        // If not down last update, key has just been pressed.~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~        if (!InputManager.PreviousKeyboardState.IsKeyDown (key)) {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~          return true;~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      return false;~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~    /// Wird die aktuelle Taste gedrückt gehalten?~\\
\cellcolor{gray} &  & \verb~76~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~77~ & \verb~    public static bool IsHeldDown (this Keys key)~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~      return InputManager.CurrentKeyboardState.IsKeyDown (key);~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.RayExtensions}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.RayExtensions\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash RayExtensions.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 50\\
\textbf{Coverable lines:} & 50\\
\textbf{Total lines:} & 146\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{Intersects(...)} & 21 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash RayExtensions.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~  public static class RayExtensions~\\
\cellcolor{gray} &  & \verb~42~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    public static float? Intersects (this Ray ray, BoundingCylinder cylinder)~\\
\cellcolor{red} & 0 & \verb~44~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~45~ & \verb~      Vector3 dirAB = cylinder.SideB - cylinder.SideA;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~      // Raystart innerhalb des Zylinders~\\
\cellcolor{red} & 0 & \verb~47~ & \verb~      if (Vector3.Cross ((ray.Position - cylinder.SideA), ray.Direction).Lengt~\\
\cellcolor{red} & 0 & \verb~48~ & \verb~        return 0.0f;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~50~ & \verb~      Vector3 perpendicular = Vector3.Cross (dirAB, ray.Direction);~\\
\cellcolor{gray} &  & \verb~51~ & \verb~      // if !(Ray Parallel zum Zylinder)~\\
\cellcolor{red} & 0 & \verb~52~ & \verb~      if (perpendicular.Length () > 0.0000001f) {~\\
\cellcolor{red} & 0 & \verb~53~ & \verb~        perpendicular.Normalize ();~\\
\cellcolor{red} & 0 & \verb~54~ & \verb~        if (Vector3.Dot (perpendicular, ray.Direction) > 0) {~\\
\cellcolor{red} & 0 & \verb~55~ & \verb~          perpendicular = -perpendicular;~\\
\cellcolor{red} & 0 & \verb~56~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~57~ & \verb~        Vector3 perpendicular2 = Vector3.Cross (dirAB, perpendicular);~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        // If (Ray Senkrecht zum Zylinder)~\\
\cellcolor{red} & 0 & \verb~59~ & \verb~        if (perpendicular2.Length () < 0.0000001f) {~\\
\cellcolor{red} & 0 & \verb~60~ & \verb~          if (Vector3.Dot (dirAB, ray.Position - cylinder.SideA) < 0 || Vector~\\
\cellcolor{red} & 0 & \verb~61~ & \verb~            return null;~\\
\cellcolor{gray} &  & \verb~62~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~          float? result = Vector3.Cross ((ray.Position - cylinder.SideA), ray.~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~          if (result < 0) {~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~            result = 0.0f;~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~          return result;~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~        if (Vector3.Dot (perpendicular2, ray.Direction) > 0) {~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~          perpendicular2 = -perpendicular2;~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~        perpendicular2.Normalize ();~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~        float minDist = Math.Abs (Vector3.Dot (cylinder.SideA - ray.Position, ~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~        if (minDist > cylinder.Radius) {~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~          return null;~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~        Vector3 plainNorm = perpendicular * minDist + (float)Math.Sqrt (cylind~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~        plainNorm.Normalize ();~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~        float? other_result = ray.Intersects (new Plane (plainNorm, Vector3.Do~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~        if (other_result == null) {~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~          return null;~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~        Vector3 cutA = ray.Position + ray.Direction * (float)other_result - cy~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~        Vector3 cutB = ray.Position + ray.Direction * (float)other_result - cy~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~        if (Vector3.Dot (dirAB, cutA) > 0 && Vector3.Dot (-dirAB, cutB) > 0) {~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~          return other_result;~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~      if (Vector3.Distance (ray.Position, cylinder.SideA) < Vector3.Distance (~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        dirAB.Normalize ();~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~        float? result = ray.Intersects (new Plane (dirAB, Vector3.Dot (dirAB, ~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~        if (result == null || Vector3.Distance (ray.Position + ray.Direction *~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~          return null;~\\
\cellcolor{gray} &  & \verb~94~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~        return result;~\\
\cellcolor{gray} &  & \verb~96~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~        dirAB.Normalize ();~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~        dirAB = -dirAB;~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~        float? result = ray.Intersects (new Plane (dirAB, Vector3.Dot (dirAB, ~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~        if (result == null || Vector3.Distance (ray.Position + ray.Direction *~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~          return null;~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~        return result;~\\
\cellcolor{gray} &  & \verb~105~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~      /*~\\
\cellcolor{gray} &  & \verb~107~ & \verb~      Vector3 diffA = capsule.CornerA - ray.Position;~\\
\cellcolor{gray} &  & \verb~108~ & \verb~      Vector3 diffB = capsule.CornerB - ray.Position;~\\
\cellcolor{gray} &  & \verb~109~ & \verb~      float diffASquared = diffA.LengthSquared ();~\\
\cellcolor{gray} &  & \verb~110~ & \verb~      float diffBSquared = diffB.LengthSquared ();~\\
\cellcolor{gray} &  & \verb~111~ & \verb~      float radiusSquared = capsule.Radius * capsule.Radius;~\\
\cellcolor{gray} &  & \verb~112~ & \verb~      // Startpunkt innerhalb der Eckkugeln~\\
\cellcolor{gray} &  & \verb~113~ & \verb~      if (diffASquared < radiusSquared || diffBSquared < radiusSquared)~\\
\cellcolor{gray} &  & \verb~114~ & \verb~      {~\\
\cellcolor{gray} &  & \verb~115~ & \verb~          return 0.0f;~\\
\cellcolor{gray} &  & \verb~116~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~      Vector3 dirBA = (capsule.CornerA - capsule.CornerB);~\\
\cellcolor{gray} &  & \verb~118~ & \verb~      float distAlongAB = Vector3.Dot (diffA, dirBA) / dirBA.Length ();~\\
\cellcolor{gray} &  & \verb~119~ & \verb~      // Startpunkt innerhalb des Zylinders~\\
\cellcolor{gray} &  & \verb~120~ & \verb~      if (distAlongAB > 0 && distAlongAB < dirBA.Length () && (distAlongAB * d~\\
\cellcolor{gray} &  & \verb~121~ & \verb~      {~\\
\cellcolor{gray} &  & \verb~122~ & \verb~          return 0.0f;~\\
\cellcolor{gray} &  & \verb~123~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~      float distAlongRayA = Vector3.Dot (ray.Direction, diffA);~\\
\cellcolor{gray} &  & \verb~125~ & \verb~      float distAlongRayB = Vector3.Dot (ray.Direction, diffB);~\\
\cellcolor{gray} &  & \verb~126~ & \verb~      // Richtung geht weg von der Kapsel~\\
\cellcolor{gray} &  & \verb~127~ & \verb~      if (distAlongRayA < 0 && distAlongRayB < 0)~\\
\cellcolor{gray} &  & \verb~128~ & \verb~          return null;~\\
\cellcolor{gray} &  & \verb~129~ & \verb~      Vector3 perpendicular = Vector3.Cross (ray.Direction, dirBA);~\\
\cellcolor{gray} &  & \verb~130~ & \verb~      perpendicular.Normalize ();~\\
\cellcolor{gray} &  & \verb~131~ & \verb~      float minDistance = Math.Abs (Vector3.Dot (diffA, perpendicular));~\\
\cellcolor{gray} &  & \verb~132~ & \verb~      // Kommt selbst der Geraden nie nahe genug.~\\
\cellcolor{gray} &  & \verb~133~ & \verb~      if (minDistance > capsule.Radius)~\\
\cellcolor{gray} &  & \verb~134~ & \verb~      {~\\
\cellcolor{gray} &  & \verb~135~ & \verb~          return null;~\\
\cellcolor{gray} &  & \verb~136~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~      Vector3 normDirAB = -dirBA;~\\
\cellcolor{gray} &  & \verb~138~ & \verb~      normDirAB.Normalize ();~\\
\cellcolor{gray} &  & \verb~139~ & \verb~      Vector3 extensionToBase = Vector3.Cross (normDirAB, perpendicular);~\\
\cellcolor{gray} &  & \verb~140~ & \verb~      extensionToBase.Normalize ();~\\
\cellcolor{gray} &  & \verb~141~ & \verb~      Matrix transformation = new Matrix (normDirAB.X, normDirAB.Y, normDirAB.~\\
\cellcolor{gray} &  & \verb~142~ & \verb~      transformation = Matrix.Invert (transformation);~\\
\cellcolor{gray} &  & \verb~143~ & \verb~       */~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.SavegameLoader`2}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.SavegameLoader`2\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash SavegameLoader.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 31\\
\textbf{Coverable lines:} & 31\\
\textbf{Total lines:} & 129\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{FindSavegames(...)} & 1 & 0 & 0\\
\hline
\textbf{AddFileToList(...)} & 3 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash SavegameLoader.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Platform;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public class SavegameLoader<Savegame, SavegameMetaData>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    public ISavegameIO<Savegame, SavegameMetaData> FileFormat { get; set; }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~    public FileIndex fileIndex { get; private set; }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~    public string IndexName;~\\
\cellcolor{gray} &  & \verb~66~ & \verb~    private Action<string, SavegameMetaData> OnSavegameFound;~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~    public SavegameLoader (ISavegameIO<Savegame, SavegameMetaData> fileFormat,~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      FileFormat = fileFormat;~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      IndexName = indexName;~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~    public void FindSavegames (Action<string, SavegameMetaData> onSavegameFoun~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~76~ & \verb~      // Erstelle einen neuen Index, der eine Datei mit dem angegeben Indexnam~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~      fileIndex = new FileIndex (SystemInfo.SavegameDirectory + SystemInfo.Pat~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~      // Diese Verzeichnisse werden nach Spielständen durchsucht~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~      string[] searchDirectories = new string[] {~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        SystemInfo.BaseDirectory,~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        SystemInfo.SavegameDirectory~\\
\cellcolor{gray} &  & \verb~83~ & \verb~      };~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~      Log.Debug ("Search for Savegames: ", string.Join (", ", searchDirectorie~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~      // Suche nach Spielstanddateien und fülle das Menü auf~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~      OnSavegameFound = onSavegameFound;~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~      FileUtility.SearchFiles (searchDirectories, FileFormat.FileExtensions, A~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~92~ & \verb~    /// Diese Methode wird für jede gefundene Spielstanddatei aufgerufen~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~94~ & \verb~    private void AddFileToList (string filename)~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~96~ & \verb~      // Lese die Datei ein und erstelle einen Hashcode~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      string hashcode = FileUtility.GetHash (filename);~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~      // Ist dieser Hashcode im Index enthalten?~\\
\cellcolor{gray} &  & \verb~100~ & \verb~      // Dann wäre der Spielstand gültig, sonst ungültig oder unbekannt.~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~      bool isValid = fileIndex.Contains (hashcode);~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~      // Wenn der Spielstand ungültig oder unbekannt ist...~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~      if (!isValid) {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~        try {~\\
\cellcolor{gray} &  & \verb~106~ & \verb~          // Lade den Knoten und prüfe, ob Exceptions auftreten~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~          FileFormat.Load (filename);~\\
\cellcolor{gray} &  & \verb~108~ & \verb~          // Keine Exceptions? Dann ist enthält die Datei einen gültigen Knote~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~          isValid = true;~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~          fileIndex.Add (hashcode);~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~        catch (Exception ex) {~\\
\cellcolor{gray} &  & \verb~113~ & \verb~          // Es ist eine Exception aufgetreten, der Knoten ist offenbar ungült~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~          Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~          isValid = false;~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~118~ & \verb~~\\
\cellcolor{gray} &  & \verb~119~ & \verb~      // Falls der Knoten gültig ist, entweder laut Index oder nach Überprüfun~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~      if (isValid) {~\\
\cellcolor{gray} &  & \verb~121~ & \verb~        // Lade die Metadaten~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~        SavegameMetaData meta = FileFormat.LoadMetaData (filename);~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        // Rufe die Callback-Funktion auf~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~        OnSavegameFound (filename, meta);~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.TextHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.TextHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash TextHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 222\\
\textbf{Coverable lines:} & 222\\
\textbf{Total lines:} & 343\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{TryTextInput(...)} & 13 & 0 & 0\\
\hline
\textbf{TryConvertKey(...)} & 59 & 0 & 0\\
\hline
\textbf{.cctor()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash TextHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~56~ & \verb~{~\\
\cellcolor{gray} &  & \verb~57~ & \verb~  public static class TextHelper~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  {~\\
\cellcolor{red} & 0 & \verb~59~ & \verb~    private static Keys lastKey = Keys.None;~\\
\cellcolor{red} & 0 & \verb~60~ & \verb~    private static double lastMillis = 0;~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    public static bool TryTextInput (ref string str, GameTime time)~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~      bool catched = false;~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~      if (lastKey != Keys.None) {~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~        if (InputManager.CurrentKeyboardState.IsKeyUp (lastKey)) {~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~          lastKey = Keys.None;~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~        else if ((time.TotalGameTime.TotalMilliseconds - lastMillis) > 100) {~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~          lastKey = Keys.None;~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~73~ & \verb~      Keys[] keys = InputManager.CurrentKeyboardState.GetPressedKeys ();~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      if (lastKey == Keys.None) {~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~        for (int i = 0; i < keys.Length; ++i) {~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~          if (keys [i] != Keys.LeftShift && keys [i] != Keys.RightShift) {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~            lastKey = keys [i];~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~        if (lastKey != Keys.None) {~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~          if (lastKey == Keys.Back) {~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~            if (str.Length != 0) {~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~              str = str.Substring (0, str.Length - 1);~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~            catched = true;~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~          else if (str.Length < 100) {~\\
\cellcolor{gray} &  & \verb~88~ & \verb~            char c;~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~            if (TryConvertKey (lastKey, out c)) {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~              str += c.ToString ();~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~            catched = true;~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~          }~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~        lastMillis = time.TotalGameTime.TotalMilliseconds;~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~      return catched;~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~    private static bool TryConvertKey (Keys keyPressed, out char key)~\\
\cellcolor{red} & 0 & \verb~102~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~      bool shift = Keys.LeftShift.IsHeldDown () || Keys.RightShift.IsHeldDown ~\\
\cellcolor{gray} &  & \verb~104~ & \verb~~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~      char c = (char)keyPressed.GetHashCode ();~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~      if (c >= 'A' && c <= 'Z') {~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~          key = char.ToUpper (c);~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~          key = char.ToLower (c);~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~114~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~      switch (keyPressed) {~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        //Decimal keys~\\
\cellcolor{gray} &  & \verb~118~ & \verb~      case Keys.D0:~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~          key = ')';~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~          key = '0';~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~126~ & \verb~      case Keys.D1:~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~          key = '!';~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~          key = '1';~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~134~ & \verb~      case Keys.D2:~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~          key = '@';~\\
\cellcolor{red} & 0 & \verb~137~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~          key = '2';~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~142~ & \verb~      case Keys.D3:~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~          key = '#';~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~146~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~147~ & \verb~          key = '3';~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~150~ & \verb~      case Keys.D4:~\\
\cellcolor{red} & 0 & \verb~151~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~          key = '$';~\\
\cellcolor{red} & 0 & \verb~153~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~155~ & \verb~          key = '4';~\\
\cellcolor{red} & 0 & \verb~156~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~158~ & \verb~      case Keys.D5:~\\
\cellcolor{red} & 0 & \verb~159~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~160~ & \verb~          key = '%';~\\
\cellcolor{red} & 0 & \verb~161~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~          key = '5';~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~166~ & \verb~      case Keys.D6:~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~          key = '^';~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~          key = '6';~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~173~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~174~ & \verb~      case Keys.D7:~\\
\cellcolor{red} & 0 & \verb~175~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~176~ & \verb~          key = '&';~\\
\cellcolor{red} & 0 & \verb~177~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~178~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~179~ & \verb~          key = '7';~\\
\cellcolor{red} & 0 & \verb~180~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~181~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~182~ & \verb~      case Keys.D8:~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~          key = '*';~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~186~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~          key = '8';~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~189~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~190~ & \verb~      case Keys.D9:~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~192~ & \verb~          key = '(';~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~          key = '9';~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~197~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~198~ & \verb~~\\
\cellcolor{gray} &  & \verb~199~ & \verb~        //Decimal numpad keys~\\
\cellcolor{gray} &  & \verb~200~ & \verb~      case Keys.NumPad0:~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~        key = '0';~\\
\cellcolor{red} & 0 & \verb~202~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~203~ & \verb~      case Keys.NumPad1:~\\
\cellcolor{red} & 0 & \verb~204~ & \verb~        key = '1';~\\
\cellcolor{red} & 0 & \verb~205~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~206~ & \verb~      case Keys.NumPad2:~\\
\cellcolor{red} & 0 & \verb~207~ & \verb~        key = '2';~\\
\cellcolor{red} & 0 & \verb~208~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~209~ & \verb~      case Keys.NumPad3:~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~        key = '3';~\\
\cellcolor{red} & 0 & \verb~211~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~212~ & \verb~      case Keys.NumPad4:~\\
\cellcolor{red} & 0 & \verb~213~ & \verb~        key = '4';~\\
\cellcolor{red} & 0 & \verb~214~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~215~ & \verb~      case Keys.NumPad5:~\\
\cellcolor{red} & 0 & \verb~216~ & \verb~        key = '5';~\\
\cellcolor{red} & 0 & \verb~217~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~218~ & \verb~      case Keys.NumPad6:~\\
\cellcolor{red} & 0 & \verb~219~ & \verb~        key = '6';~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~221~ & \verb~      case Keys.NumPad7:~\\
\cellcolor{red} & 0 & \verb~222~ & \verb~        key = '7';~\\
\cellcolor{red} & 0 & \verb~223~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~224~ & \verb~      case Keys.NumPad8:~\\
\cellcolor{red} & 0 & \verb~225~ & \verb~        key = '8';~\\
\cellcolor{red} & 0 & \verb~226~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~227~ & \verb~      case Keys.NumPad9:~\\
\cellcolor{red} & 0 & \verb~228~ & \verb~        key = '9';~\\
\cellcolor{red} & 0 & \verb~229~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~230~ & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & \verb~        //Special keys~\\
\cellcolor{gray} &  & \verb~232~ & \verb~      case Keys.OemTilde:~\\
\cellcolor{red} & 0 & \verb~233~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~          key = ' ';~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~237~ & \verb~          key = '`';~\\
\cellcolor{red} & 0 & \verb~238~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~239~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~240~ & \verb~      case Keys.OemSemicolon:~\\
\cellcolor{red} & 0 & \verb~241~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~242~ & \verb~          key = ':';~\\
\cellcolor{red} & 0 & \verb~243~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~244~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~245~ & \verb~          key = ';';~\\
\cellcolor{red} & 0 & \verb~246~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~247~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~248~ & \verb~      case Keys.OemQuotes:~\\
\cellcolor{red} & 0 & \verb~249~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~250~ & \verb~          key = '"';~\\
\cellcolor{red} & 0 & \verb~251~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~252~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~253~ & \verb~          key = '\'';~\\
\cellcolor{red} & 0 & \verb~254~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~255~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~256~ & \verb~      case Keys.OemQuestion:~\\
\cellcolor{red} & 0 & \verb~257~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~          key = '?';~\\
\cellcolor{red} & 0 & \verb~259~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~260~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~261~ & \verb~          key = '/';~\\
\cellcolor{red} & 0 & \verb~262~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~263~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~264~ & \verb~      case Keys.OemPlus:~\\
\cellcolor{red} & 0 & \verb~265~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~266~ & \verb~          key = '+';~\\
\cellcolor{red} & 0 & \verb~267~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~268~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~269~ & \verb~          key = '=';~\\
\cellcolor{red} & 0 & \verb~270~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~271~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~272~ & \verb~      case Keys.OemPipe:~\\
\cellcolor{red} & 0 & \verb~273~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~274~ & \verb~          key = '|';~\\
\cellcolor{red} & 0 & \verb~275~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~276~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~277~ & \verb~          key = '\\';~\\
\cellcolor{red} & 0 & \verb~278~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~279~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~280~ & \verb~      case Keys.OemPeriod:~\\
\cellcolor{red} & 0 & \verb~281~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~282~ & \verb~          key = '>';~\\
\cellcolor{red} & 0 & \verb~283~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~284~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~285~ & \verb~          key = '.';~\\
\cellcolor{red} & 0 & \verb~286~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~287~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~288~ & \verb~      case Keys.OemOpenBrackets:~\\
\cellcolor{red} & 0 & \verb~289~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~290~ & \verb~          key = '{';~\\
\cellcolor{red} & 0 & \verb~291~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~292~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~293~ & \verb~          key = '[';~\\
\cellcolor{red} & 0 & \verb~294~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~295~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~296~ & \verb~      case Keys.OemCloseBrackets:~\\
\cellcolor{red} & 0 & \verb~297~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~298~ & \verb~          key = '}';~\\
\cellcolor{red} & 0 & \verb~299~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~300~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~301~ & \verb~          key = ']';~\\
\cellcolor{red} & 0 & \verb~302~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~303~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~304~ & \verb~      case Keys.OemMinus:~\\
\cellcolor{red} & 0 & \verb~305~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~306~ & \verb~          key = '_';~\\
\cellcolor{red} & 0 & \verb~307~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~308~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~309~ & \verb~          key = '-';~\\
\cellcolor{red} & 0 & \verb~310~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~311~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~312~ & \verb~      case Keys.OemComma:~\\
\cellcolor{red} & 0 & \verb~313~ & \verb~        if (shift) {~\\
\cellcolor{red} & 0 & \verb~314~ & \verb~          key = '<';~\\
\cellcolor{red} & 0 & \verb~315~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~316~ & \verb~        else {~\\
\cellcolor{red} & 0 & \verb~317~ & \verb~          key = ',';~\\
\cellcolor{red} & 0 & \verb~318~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~319~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~320~ & \verb~      case Keys.Space:~\\
\cellcolor{red} & 0 & \verb~321~ & \verb~        key = ' ';~\\
\cellcolor{red} & 0 & \verb~322~ & \verb~        return true;~\\
\cellcolor{gray} &  & \verb~323~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~324~ & \verb~~\\
\cellcolor{red} & 0 & \verb~325~ & \verb~      key = (char)0;~\\
\cellcolor{red} & 0 & \verb~326~ & \verb~      return false;~\\
\cellcolor{red} & 0 & \verb~327~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~328~ & \verb~~\\
\cellcolor{red} & 0 & \verb~329~ & \verb~    public static List<Keys> ValidKeys = new List<Keys> (~\\
\cellcolor{gray} &  & \verb~330~ & \verb~    new Keys[] {~\\
\cellcolor{gray} &  & \verb~331~ & \verb~      Keys.A, Keys.B, Keys.C, Keys.D, Keys.E, Keys.F, Keys.G, Keys.H, Keys.I, ~\\
\cellcolor{gray} &  & \verb~332~ & \verb~      Keys.L, Keys.M, Keys.N, Keys.O, Keys.P, Keys.Q, Keys.R, Keys.S, Keys.T, ~\\
\cellcolor{gray} &  & \verb~333~ & \verb~      Keys.W, Keys.X, Keys.Y, Keys.Z,~\\
\cellcolor{gray} &  & \verb~334~ & \verb~      Keys.D0, Keys.D1, Keys.D2, Keys.D3, Keys.D4, Keys.D5, Keys.D6, Keys.D7, ~\\
\cellcolor{gray} &  & \verb~335~ & \verb~      Keys.NumPad0, Keys.NumPad1, Keys.NumPad2, Keys.NumPad3, Keys.NumPad4, Ke~\\
\cellcolor{gray} &  & \verb~336~ & \verb~      Keys.NumPad6, Keys.NumPad7, Keys.NumPad8, Keys.NumPad9,~\\
\cellcolor{gray} &  & \verb~337~ & \verb~      Keys.OemTilde, Keys.OemSemicolon, Keys.OemQuotes, Keys.OemQuestion, Keys~\\
\cellcolor{gray} &  & \verb~338~ & \verb~      Keys.OemPipe, Keys.OemPeriod, Keys.OemOpenBrackets, Keys.OemCloseBracket~\\
\cellcolor{gray} &  & \verb~339~ & \verb~      Keys.OemComma, Keys.Space, Keys.Back~\\
\cellcolor{gray} &  & \verb~340~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~341~ & \verb~    );~\\
\cellcolor{gray} &  & \verb~342~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~343~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.TextureHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.TextureHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash TextureHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 91\\
\textbf{Coverable lines:} & 91\\
\textbf{Total lines:} & 215\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{LoadTexture(...)} & 1 & 0 & 0\\
\hline
\textbf{LoadFont(...)} & 1 & 0 & 0\\
\hline
\textbf{Create(...)} & 1 & 0 & 0\\
\hline
\textbf{Create(...)} & 3 & 0 & 0\\
\hline
\textbf{CreateGradient(...)} & 2 & 0 & 0\\
\hline
\textbf{DrawColoredRectangle} & 1 & 0 & 0\\
\hline
\textbf{DrawStringInRectangl} & 1 & 0 & 0\\
\hline
\textbf{ScaleStringInRectang} & 2 & 0 & 0\\
\hline
\textbf{TextPosition(...)} & 4 & 0 & 0\\
\hline
\textbf{.cctor()} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash TextureHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~57~ & \verb~{~\\
\cellcolor{gray} &  & \verb~58~ & \verb~  public static class TextureHelper~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  {~\\
\cellcolor{gray} &  & \verb~60~ & \verb~    #region Real Textures~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~    public static Texture2D LoadTexture (this IGameScreen screen, string name)~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~      try {~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~        return screen.Content.Load<Texture2D> ("Textures/" + name);~\\
\cellcolor{gray} &  & \verb~66~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~      catch (ContentLoadException ex) {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~        Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~        return null;~\\
\cellcolor{gray} &  & \verb~70~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~    public static SpriteFont LoadFont (this IGameScreen screen, string name)~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~      try {~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~        return screen.Content.Load<SpriteFont> ("Fonts/" + name);~\\
\cellcolor{gray} &  & \verb~77~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~      catch (ContentLoadException ex) {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~        Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~        return null;~\\
\cellcolor{gray} &  & \verb~81~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~    #region Dummy Textures~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~    public static Texture2D Create (GraphicsDevice graphicsDevice, Color color~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~      return Create (graphicsDevice, 1, 1, color);~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~    private static Dictionary<string, Texture2D> textureCache = new Dictionary~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    public static Texture2D Create (GraphicsDevice graphicsDevice, int width, ~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~97~ & \verb~      string key = color.ToString () + width.ToString () + "x" + height.ToStri~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~      if (textureCache.ContainsKey (key)) {~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~        return textureCache [key];~\\
\cellcolor{gray} &  & \verb~100~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~102~ & \verb~        // create a texture with the specified size~\\
\cellcolor{red} & 0 & \verb~103~ & \verb~        Texture2D texture = new Texture2D (graphicsDevice, width, height);~\\
\cellcolor{gray} &  & \verb~104~ & \verb~~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        // fill it with the specified colors~\\
\cellcolor{red} & 0 & \verb~106~ & \verb~        Color[] colors = new Color[width * height];~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~        for (int i = 0; i < colors.Length; i++) {~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~          colors [i] = new Color (color.ToVector3 ());~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~        texture.SetData (colors);~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~        textureCache [key] = texture;~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~        return texture;~\\
\cellcolor{gray} &  & \verb~113~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    public static Texture2D CreateGradient (GraphicsDevice graphicsDevice, Col~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~      string key = color1.ToString () + color2.ToString () + "gradient";~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~      if (textureCache.ContainsKey (key)) {~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~        return textureCache [key];~\\
\cellcolor{gray} &  & \verb~121~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~      else {~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        // create a texture with the specified size~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~        Texture2D texture = new Texture2D (graphicsDevice, 2, 2);~\\
\cellcolor{gray} &  & \verb~125~ & \verb~~\\
\cellcolor{gray} &  & \verb~126~ & \verb~        // fill it with the specified colors~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~        Color[] colors = new Color[texture.Width * texture.Height];~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~        colors [0] = color1;~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~        colors [1] = color2;~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~        colors [2] = color2;~\\
\cellcolor{red} & 0 & \verb~131~ & \verb~        colors [3] = color1;~\\
\cellcolor{red} & 0 & \verb~132~ & \verb~        texture.SetData (colors);~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~        textureCache [key] = texture;~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~        return texture;~\\
\cellcolor{gray} &  & \verb~135~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~    public static void DrawColoredRectangle (this SpriteBatch spriteBatch, Col~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~      Texture2D texture = TextureHelper.Create (spriteBatch.GraphicsDevice, Co~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~      spriteBatch.Draw (~\\
\cellcolor{gray} &  & \verb~142~ & \verb~          texture, bounds, null, color, 0f, Vector2.Zero, SpriteEffects.None, ~\\
\cellcolor{gray} &  & \verb~143~ & \verb~      );~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & \verb~    public static void DrawStringInRectangle (this SpriteBatch spriteBatch, Sp~\\
\cellcolor{gray} &  & \verb~147~ & \verb~            string text, Color color, Rectangle bounds,~\\
\cellcolor{gray} &  & \verb~148~ & \verb~            HorizontalAlignment alignX, VerticalAlignment alignY)~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~150~ & \verb~      Vector2 scaledPosition = new Vector2 (bounds.X, bounds.Y);~\\
\cellcolor{red} & 0 & \verb~151~ & \verb~      Vector2 scaledSize = new Vector2 (bounds.Width, bounds.Height);~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~      try {~\\
\cellcolor{gray} &  & \verb~153~ & \verb~        // finde die richtige Skalierung~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~        Vector2 scale = spriteBatch.ScaleStringInRectangle (font, text, color,~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~        // finde die richtige Position~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~        Vector2 textPosition = TextPosition (~\\
\cellcolor{gray} &  & \verb~158~ & \verb~                                   font: font, text: text, scale: scale,~\\
\cellcolor{gray} &  & \verb~159~ & \verb~                                   position: scaledPosition, size: scaledSize,~\\
\cellcolor{gray} &  & \verb~160~ & \verb~                                   alignX: alignX, alignY: alignY~\\
\cellcolor{gray} &  & \verb~161~ & \verb~                               );~\\
\cellcolor{gray} &  & \verb~162~ & \verb~~\\
\cellcolor{gray} &  & \verb~163~ & \verb~        // zeichne die Schrift~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~        spriteBatch.DrawString (font, text, textPosition, color, 0, Vector2.Ze~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~166~ & \verb~      catch (ArgumentException exp) {~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~        Log.Debug (exp);~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~      catch (InvalidOperationException exp) {~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~        Log.Debug (exp);~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~173~ & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & \verb~    public static Vector2 ScaleStringInRectangle (this SpriteBatch spriteBatch~\\
\cellcolor{gray} &  & \verb~175~ & \verb~            string text, Color color, Rectangle bounds,~\\
\cellcolor{gray} &  & \verb~176~ & \verb~            HorizontalAlignment alignX, VerticalAlignment alignY)~\\
\cellcolor{red} & 0 & \verb~177~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~178~ & \verb~      Vector2 scaledSize = new Vector2 (bounds.Width, bounds.Height);~\\
\cellcolor{red} & 0 & \verb~179~ & \verb~      try {~\\
\cellcolor{gray} &  & \verb~180~ & \verb~        // finde die richtige Skalierung~\\
\cellcolor{red} & 0 & \verb~181~ & \verb~        Vector2 scale = scaledSize / font.MeasureString (text) * 0.9f;~\\
\cellcolor{red} & 0 & \verb~182~ & \verb~        if (!text.Contains ("\n")) {~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~          scale.Y = scale.X = MathHelper.Min (scale.X, scale.Y);~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~        return scale;~\\
\cellcolor{gray} &  & \verb~186~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~      catch (Exception exp) {~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~        Log.Debug (exp);~\\
\cellcolor{red} & 0 & \verb~189~ & \verb~        return Vector2.One;~\\
\cellcolor{gray} &  & \verb~190~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~192~ & \verb~~\\
\cellcolor{gray} &  & \verb~193~ & \verb~    public static Vector2 TextPosition (SpriteFont font, string text, Vector2 ~\\
\cellcolor{gray} &  & \verb~194~ & \verb~                                        HorizontalAlignment alignX, VerticalAl~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~      Vector2 textPosition = position;~\\
\cellcolor{red} & 0 & \verb~197~ & \verb~      Vector2 minimumSize = font.MeasureString (text);~\\
\cellcolor{red} & 0 & \verb~198~ & \verb~      switch (alignX) {~\\
\cellcolor{gray} &  & \verb~199~ & \verb~      case HorizontalAlignment.Left:~\\
\cellcolor{red} & 0 & \verb~200~ & \verb~        textPosition.Y += (size.Y - minimumSize.Y * scale.Y) / 2;~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~        break;~\\
\cellcolor{gray} &  & \verb~202~ & \verb~      case HorizontalAlignment.Center:~\\
\cellcolor{red} & 0 & \verb~203~ & \verb~        textPosition += (size - minimumSize * scale) / 2;~\\
\cellcolor{red} & 0 & \verb~204~ & \verb~        break;~\\
\cellcolor{gray} &  & \verb~205~ & \verb~      case HorizontalAlignment.Right:~\\
\cellcolor{red} & 0 & \verb~206~ & \verb~        textPosition.Y += (size.Y - minimumSize.Y * scale.Y) / 2;~\\
\cellcolor{red} & 0 & \verb~207~ & \verb~        textPosition.X += size.X - minimumSize.X * scale.X;~\\
\cellcolor{red} & 0 & \verb~208~ & \verb~        break;~\\
\cellcolor{gray} &  & \verb~209~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~      return textPosition;~\\
\cellcolor{red} & 0 & \verb~211~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~212~ & \verb~~\\
\cellcolor{gray} &  & \verb~213~ & \verb~    #endregion~\\
\cellcolor{gray} &  & \verb~214~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~215~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Utilities.VectorHelper}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Utilities.VectorHelper\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash VectorHelper.cs}\end{minipage} \\
\textbf{Coverage:} & 21.3\%\\
\textbf{Covered lines:} & 72\\
\textbf{Uncovered lines:} & 265\\
\textbf{Coverable lines:} & 337\\
\textbf{Total lines:} & 593\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ArcBallMove(...)} & 3 & 0 & 0\\
\hline
\textbf{MoveLinear(...)} & 1 & 0 & 0\\
\hline
\textbf{MoveLinear(...)} & 1 & 0 & 0\\
\hline
\textbf{AngleBetween(...)} & 3 & 0 & 0\\
\hline
\textbf{AngleBetween(...)} & 1 & 0 & 0\\
\hline
\textbf{RotateX(...)} & 1 & 0 & 0\\
\hline
\textbf{RotateY(...)} & 1 & 0 & 0\\
\hline
\textbf{RotateZ(...)} & 1 & 0 & 0\\
\hline
\textbf{RotateAroundVector(.} & 1 & 0 & 0\\
\hline
\textbf{Clamp(...)} & 1 & 0 & 0\\
\hline
\textbf{Clamp(...)} & 3 & 0 & 0\\
\hline
\textbf{PrimaryVector(...)} & 3 & 0 & 0\\
\hline
\textbf{PrimaryVector(...)} & 7 & 0 & 0\\
\hline
\textbf{PrimaryDirection(...} & 1 & 0 & 0\\
\hline
\textbf{PrimaryDirection(...} & 1 & 0 & 0\\
\hline
\textbf{PrimaryDirectionExce} & 4 & 0 & 0\\
\hline
\textbf{Abs(...)} & 1 & 100 & 100\\
\hline
\textbf{Clamp(...)} & 1 & 0 & 0\\
\hline
\textbf{Bounds(...)} & 2 & 0 & 0\\
\hline
\textbf{Bounds(...)} & 1 & 0 & 0\\
\hline
\textbf{Scale(...)} & 1 & 0 & 0\\
\hline
\textbf{Scale(...)} & 1 & 0 & 0\\
\hline
\textbf{Translate(...)} & 1 & 0 & 0\\
\hline
\textbf{Rotate(...)} & 1 & 0 & 0\\
\hline
\textbf{Scale(...)} & 1 & 0 & 0\\
\hline
\textbf{Translate(...)} & 1 & 0 & 0\\
\hline
\textbf{ToVector2(...)} & 1 & 0 & 0\\
\hline
\textbf{ToScreenPoint(...)} & 1 & 0 & 0\\
\hline
\textbf{ToPoint(...)} & 1 & 0 & 0\\
\hline
\textbf{ToVector2(...)} & 1 & 100 & 100\\
\hline
\textbf{Center(...)} & 1 & 0 & 0\\
\hline
\textbf{Length(...)} & 1 & 0 & 0\\
\hline
\textbf{ToVector2(...)} & 1 & 0 & 0\\
\hline
\textbf{ToPoint(...)} & 1 & 100 & 100\\
\hline
\textbf{Plus(...)} & 1 & 0 & 0\\
\hline
\textbf{Join(...)} & 2 & 0 & 0\\
\hline
\textbf{ScaleFactor(...)} & 1 & 0 & 0\\
\hline
\textbf{RelativeTo(...)} & 1 & 0 & 0\\
\hline
\textbf{Scale(...)} & 3 & 75 & 60\\
\hline
\textbf{Scale(...)} & 1 & 0 & 0\\
\hline
\textbf{Grow(...)} & 1 & 0 & 0\\
\hline
\textbf{Shrink(...)} & 1 & 0 & 0\\
\hline
\textbf{Grow(...)} & 1 & 0 & 0\\
\hline
\textbf{Shrink(...)} & 1 & 0 & 0\\
\hline
\textbf{Translate(...)} & 1 & 0 & 0\\
\hline
\textbf{Resize(...)} & 1 & 0 & 0\\
\hline
\textbf{Swap(...)} & 1 & 0 & 0\\
\hline
\textbf{Print(...)} & 1 & 0 & 0\\
\hline
\textbf{CylinderBounds(...)} & 2 & 100 & 100\\
\hline
\textbf{CreateRectangle(...)} & 1 & 0 & 0\\
\hline
\textbf{CreateRectangle(...)} & 1 & 0 & 0\\
\hline
\textbf{CreateRectangle(...)} & 3 & 0 & 0\\
\hline
\textbf{At(...)} & 4 & 0 & 0\\
\hline
\textbf{At(...)} & 4 & 81.25 & 85.71\\
\hline
\textbf{At(...)} & 4 & 0 & 0\\
\hline
\textbf{At(...)} & 5 & 0 & 0\\
\hline
\textbf{RandomIndex(...)} & 1 & 0 & 0\\
\hline
\textbf{RandomElement(...)} & 1 & 0 & 0\\
\hline
\textbf{SetCoordinates(...)} & 1 & 0 & 0\\
\hline
\textbf{ReverseDictionary(..} & 1 & 0 & 0\\
\hline
\textbf{DistanceTo(...)} & 1 & 100 & 100\\
\hline
\textbf{SetDistanceTo(...)} & 4 & 100 & 85.71\\
\hline
\textbf{Shuffle(...)} & 1 & 0 & 0\\
\hline
\textbf{Repeat(...)} & 2 & 0 & 0\\
\hline
\textbf{Repeat(...)} & 2 & 100 & 100\\
\hline
\textbf{Repeat(...)} & 2 & 100 & 100\\
\hline
\textbf{ForEach(...)} & 3 & 100 & 80\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 6 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 100 & 83.33\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash src\textbackslash Knot3\textbackslash Utilities\textbackslash VectorHelper.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~#region Copyright~\\
\cellcolor{gray} &  & \verb~2~ & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * Permission is hereby granted, free of charge, to any person obtaining a cop~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of this software and associated documentation files (the "Software"), to de~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ * in the Software without restriction, including without limitation the right~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ * copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ * furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ * The above copyright notice and this permission notice shall be included in ~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ * copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FRO~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ * SOFTWARE.~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~25~ & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~27~ & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & \verb~#region Using~\\
\cellcolor{gray} &  & \verb~29~ & \verb~~\\
\cellcolor{gray} &  & \verb~30~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.GamerServices;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Microsoft.Xna.Framework.Media;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Microsoft.Xna.Framework.Net;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Microsoft.Xna.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Core;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~using Knot3.Data;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~using Knot3.Development;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~using Knot3.GameObjects;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~using Knot3.Input;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~using Knot3.RenderEffects;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~using Knot3.Screens;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~using Knot3.Widgets;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~#endregion~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~namespace Knot3.Utilities~\\
\cellcolor{gray} &  & \verb~58~ & \verb~{~\\
\cellcolor{gray} &  & \verb~59~ & \verb~  public static class VectorHelper~\\
\cellcolor{gray} &  & \verb~60~ & \verb~  {~\\
\cellcolor{green} & 1 & \verb~61~ & \verb~    private static readonly float MinAngleY = 0.1f;~\\
\cellcolor{green} & 1 & \verb~62~ & \verb~    private static readonly float MaxAngleY = MathHelper.Pi - 0.1f;~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~    public static Vector3 ArcBallMove (this Vector3 position, Vector2 mouse, V~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~      Vector3 side = Vector3.Normalize (Vector3.Cross (up, forward));~\\
\cellcolor{gray} &  & \verb~67~ & \verb~      //Vector3 relUp = Vector3.Normalize (Vector3.Cross (side, forward));~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~      // horizontal rotation~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~      float diffAngleX = MathHelper.Pi / 300f * mouse.X;~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~      Vector3 rotated = position.RotateAroundVector (up, diffAngleX);~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~      // vertical rotation~\\
\cellcolor{red} & 0 & \verb~74~ & \verb~      float currentAngleY = position.AngleBetween (up);~\\
\cellcolor{red} & 0 & \verb~75~ & \verb~      float diffAngleY = MathHelper.Pi / 200f * mouse.Y;~\\
\cellcolor{red} & 0 & \verb~76~ & \verb~      if (currentAngleY + diffAngleY > MinAngleY && currentAngleY + diffAngleY~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~        rotated = rotated.RotateAroundVector (-side, diffAngleY);~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~      }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~      return rotated;~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~    public static Vector3 MoveLinear (this Vector3 vectorToMove, Vector3 mouse~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~85~ & \verb~      /*Vector3 side = Vector3.Cross (up, forward);~\\
\cellcolor{gray} &  & \verb~86~ & \verb~      side.Normalize ();~\\
\cellcolor{gray} &  & \verb~87~ & \verb~      Vector3 relUp = Vector3.Cross (side, forward);~\\
\cellcolor{gray} &  & \verb~88~ & \verb~      relUp.Normalize ();~\\
\cellcolor{gray} &  & \verb~89~ & \verb~      Vector3 movedVector = vectorToMove - side * mouse.X - relUp * mouse.Y - ~\\
\cellcolor{gray} &  & \verb~90~ & \verb~      return movedVector;*/~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~      Vector3 movedVector = Vector3.Zero;~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~      Profiler.ProfileDelegate ["gesamt"] = () => {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~        Vector3 side = Vector3.Zero;~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~        Profiler.ProfileDelegate ["Cross1"] = () => {~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~          side = Vector3.Cross (up, forward);~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~          side.Normalize ();~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        };~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~        Vector3 relUp = Vector3.Zero;~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~        Profiler.ProfileDelegate ["Cross2"] = () => {~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~          relUp = Vector3.Cross (side, forward);~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~          relUp.Normalize ();~\\
\cellcolor{gray} &  & \verb~102~ & \verb~        };~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{red} & 0 & \verb~104~ & \verb~        Profiler.ProfileDelegate ["PlusMinux"] = () => {~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~          movedVector = vectorToMove - side * mouse.X - relUp * mouse.Y - forw~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        };~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~      };~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~      return movedVector;~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~~\\
\cellcolor{gray} &  & \verb~111~ & \verb~    public static Vector3 MoveLinear (this Vector3 vectorToMove, Vector2 mouse~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~      return vectorToMove.MoveLinear (new Vector3 (mouse.X, mouse.Y, 0), up, f~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~    public static float AngleBetween (this Vector2 a, Vector2 b)~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~      return ((b.X - a.X) > 0 ? 1 : -1) * (float)Math.Acos ((double)Vector2.Do~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~120~ & \verb~~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    public static float AngleBetween (this Vector3 a, Vector3 b)~\\
\cellcolor{red} & 0 & \verb~122~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~      return //((b.X - a.X) > 0 ? 1 : -1) *~\\
\cellcolor{gray} &  & \verb~124~ & \verb~          (float)Math.Acos ((double)Vector3.Dot (Vector3.Normalize (a), Vector~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~    public static Vector3 RotateX (this Vector3 vectorToRotate, float angleRad~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~129~ & \verb~      return Vector3.Transform (vectorToRotate, Matrix.CreateRotationX (angleR~\\
\cellcolor{red} & 0 & \verb~130~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{gray} &  & \verb~132~ & \verb~    public static Vector3 RotateY (this Vector3 vectorToRotate, float angleRad~\\
\cellcolor{red} & 0 & \verb~133~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~      return Vector3.Transform (vectorToRotate, Matrix.CreateRotationY (angleR~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~136~ & \verb~~\\
\cellcolor{gray} &  & \verb~137~ & \verb~    public static Vector3 RotateZ (this Vector3 vectorToRotate, float angleRad~\\
\cellcolor{red} & 0 & \verb~138~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~139~ & \verb~      return Vector3.Transform (vectorToRotate, Matrix.CreateRotationZ (angleR~\\
\cellcolor{red} & 0 & \verb~140~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~~\\
\cellcolor{gray} &  & \verb~142~ & \verb~    public static Vector3 RotateAroundVector (this Vector3 vectorToRotate, Vec~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~      return Vector3.Transform (vectorToRotate, Quaternion.CreateFromAxisAngle~\\
\cellcolor{red} & 0 & \verb~145~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~    public static Vector3 Clamp (this Vector3 v, Vector3 lower, Vector3 higher~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~149~ & \verb~      return new Vector3 (~\\
\cellcolor{gray} &  & \verb~150~ & \verb~                 MathHelper.Clamp (v.X, lower.X, higher.X),~\\
\cellcolor{gray} &  & \verb~151~ & \verb~                 MathHelper.Clamp (v.Y, lower.Y, higher.Y),~\\
\cellcolor{gray} &  & \verb~152~ & \verb~                 MathHelper.Clamp (v.Z, lower.Z, higher.Z)~\\
\cellcolor{gray} &  & \verb~153~ & \verb~             );~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~    public static Vector3 Clamp (this Vector3 v, int minLength, int maxLength)~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~158~ & \verb~      if (v.Length () < minLength) {~\\
\cellcolor{red} & 0 & \verb~159~ & \verb~        return v * minLength / v.Length ();~\\
\cellcolor{gray} &  & \verb~160~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~161~ & \verb~      else if (v.Length () > maxLength) {~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~        return v * maxLength / v.Length ();~\\
\cellcolor{gray} &  & \verb~163~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~        return v;~\\
\cellcolor{gray} &  & \verb~166~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~168~ & \verb~~\\
\cellcolor{gray} &  & \verb~169~ & \verb~    public static Vector2 PrimaryVector (this Vector2 v)~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~      if (v.X.Abs () > v.Y.Abs ()) {~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~        return new Vector2 (v.X, 0);~\\
\cellcolor{gray} &  & \verb~173~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~174~ & \verb~      else if (v.Y.Abs () > v.X.Abs ()) {~\\
\cellcolor{red} & 0 & \verb~175~ & \verb~        return new Vector2 (0, v.Y);~\\
\cellcolor{gray} &  & \verb~176~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~177~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~178~ & \verb~        return new Vector2 (v.X, 0);~\\
\cellcolor{gray} &  & \verb~179~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~180~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~181~ & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & \verb~    public static Vector3 PrimaryVector (this Vector3 v)~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~      if (v.X.Abs () > v.Y.Abs () && v.X.Abs () > v.Z.Abs ()) {~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~        return new Vector3 (v.X, 0, 0);~\\
\cellcolor{gray} &  & \verb~186~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~      else if (v.Y.Abs () > v.X.Abs () && v.Y.Abs () > v.Z.Abs ()) {~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~        return new Vector3 (0, v.Y, 0);~\\
\cellcolor{gray} &  & \verb~189~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~190~ & \verb~      else if (v.Z.Abs () > v.Y.Abs () && v.Z.Abs () > v.X.Abs ()) {~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~        return new Vector3 (0, 0, v.Z);~\\
\cellcolor{gray} &  & \verb~192~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~        return new Vector3 (v.X, 0, 0);~\\
\cellcolor{gray} &  & \verb~195~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & \verb~    public static Vector2 PrimaryDirection (this Vector2 v)~\\
\cellcolor{red} & 0 & \verb~199~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~200~ & \verb~      Vector2 vector = v.PrimaryVector ();~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~      return new Vector2 (Math.Sign (vector.X), Math.Sign (vector.Y));~\\
\cellcolor{red} & 0 & \verb~202~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~203~ & \verb~~\\
\cellcolor{gray} &  & \verb~204~ & \verb~    public static Vector3 PrimaryDirection (this Vector3 v)~\\
\cellcolor{red} & 0 & \verb~205~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~206~ & \verb~      Vector3 vector = v.PrimaryVector ();~\\
\cellcolor{red} & 0 & \verb~207~ & \verb~      return new Vector3 (Math.Sign (vector.X), Math.Sign (vector.Y), Math.Sig~\\
\cellcolor{red} & 0 & \verb~208~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~209~ & \verb~~\\
\cellcolor{gray} &  & \verb~210~ & \verb~    public static Vector3 PrimaryDirectionExcept (this Vector3 v, Vector3 wron~\\
\cellcolor{red} & 0 & \verb~211~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~212~ & \verb~      Vector3 copy = v;~\\
\cellcolor{red} & 0 & \verb~213~ & \verb~      if (wrongDirection.X != 0) {~\\
\cellcolor{red} & 0 & \verb~214~ & \verb~        copy.X = 0;~\\
\cellcolor{red} & 0 & \verb~215~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~216~ & \verb~      else if (wrongDirection.Y != 0) {~\\
\cellcolor{red} & 0 & \verb~217~ & \verb~        copy.Y = 0;~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~219~ & \verb~      else if (wrongDirection.Z != 0) {~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~        copy.Z = 0;~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~222~ & \verb~      return copy.PrimaryDirection ();~\\
\cellcolor{red} & 0 & \verb~223~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~224~ & \verb~~\\
\cellcolor{gray} &  & \verb~225~ & \verb~    public static float Abs (this float v)~\\
\cellcolor{green} & 36 & \verb~226~ & \verb~    {~\\
\cellcolor{green} & 36 & \verb~227~ & \verb~      return Math.Abs (v);~\\
\cellcolor{green} & 36 & \verb~228~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~229~ & \verb~~\\
\cellcolor{gray} &  & \verb~230~ & \verb~    public static float Clamp (this float v, float min, float max)~\\
\cellcolor{red} & 0 & \verb~231~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~232~ & \verb~      return MathHelper.Clamp (v, min, max);~\\
\cellcolor{red} & 0 & \verb~233~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~234~ & \verb~~\\
\cellcolor{gray} &  & \verb~235~ & \verb~    public static BoundingSphere[] Bounds (this Model model)~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~237~ & \verb~      //Log.Debug (model);~\\
\cellcolor{red} & 0 & \verb~238~ & \verb~      BoundingSphere[] bounds = new BoundingSphere[model.Meshes.Count];~\\
\cellcolor{red} & 0 & \verb~239~ & \verb~      int i = 0;~\\
\cellcolor{red} & 0 & \verb~240~ & \verb~      foreach (ModelMesh mesh in model.Meshes) {~\\
\cellcolor{red} & 0 & \verb~241~ & \verb~        bounds [i++] = mesh.BoundingSphere;~\\
\cellcolor{red} & 0 & \verb~242~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~243~ & \verb~      return bounds;~\\
\cellcolor{red} & 0 & \verb~244~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~245~ & \verb~~\\
\cellcolor{gray} &  & \verb~246~ & \verb~    public static BoundingBox Bounds (this Vector3 a, Vector3 diff)~\\
\cellcolor{red} & 0 & \verb~247~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~248~ & \verb~      return new BoundingBox (a, a + diff);~\\
\cellcolor{red} & 0 & \verb~249~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~250~ & \verb~~\\
\cellcolor{gray} &  & \verb~251~ & \verb~    public static BoundingSphere Scale (this BoundingSphere sphere, float scal~\\
\cellcolor{red} & 0 & \verb~252~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~253~ & \verb~      return new BoundingSphere (sphere.Center, sphere.Radius * scale);~\\
\cellcolor{red} & 0 & \verb~254~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~255~ & \verb~~\\
\cellcolor{gray} &  & \verb~256~ & \verb~    public static BoundingSphere Scale (this BoundingSphere sphere, Vector3 sc~\\
\cellcolor{red} & 0 & \verb~257~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~      return new BoundingSphere (sphere.Center, sphere.Radius * scale.PrimaryV~\\
\cellcolor{red} & 0 & \verb~259~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~260~ & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & \verb~    public static BoundingSphere Translate (this BoundingSphere sphere, Vector~\\
\cellcolor{red} & 0 & \verb~262~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~263~ & \verb~      return new BoundingSphere (Vector3.Transform (sphere.Center, Matrix.Crea~\\
\cellcolor{red} & 0 & \verb~264~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~265~ & \verb~~\\
\cellcolor{gray} &  & \verb~266~ & \verb~    public static BoundingSphere Rotate (this BoundingSphere sphere, Angles3 r~\\
\cellcolor{red} & 0 & \verb~267~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~268~ & \verb~      return new BoundingSphere (Vector3.Transform (sphere.Center, Matrix.Crea~\\
\cellcolor{red} & 0 & \verb~269~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~270~ & \verb~~\\
\cellcolor{gray} &  & \verb~271~ & \verb~    public static BoundingBox Scale (this BoundingBox box, float scale)~\\
\cellcolor{red} & 0 & \verb~272~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~273~ & \verb~      return new BoundingBox (box.Min * scale, box.Max * scale);~\\
\cellcolor{red} & 0 & \verb~274~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~275~ & \verb~~\\
\cellcolor{gray} &  & \verb~276~ & \verb~    public static BoundingBox Translate (this BoundingBox box, Vector3 positio~\\
\cellcolor{red} & 0 & \verb~277~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~278~ & \verb~      Matrix translation = Matrix.CreateTranslation (position);~\\
\cellcolor{red} & 0 & \verb~279~ & \verb~      return new BoundingBox (Vector3.Transform (box.Min, translation), Vector~\\
\cellcolor{red} & 0 & \verb~280~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~281~ & \verb~~\\
\cellcolor{gray} &  & \verb~282~ & \verb~    public static Vector2 ToVector2 (this MouseState mouse)~\\
\cellcolor{red} & 0 & \verb~283~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~284~ & \verb~      return new Vector2 (mouse.X, mouse.Y);~\\
\cellcolor{red} & 0 & \verb~285~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~286~ & \verb~~\\
\cellcolor{gray} &  & \verb~287~ & \verb~    public static ScreenPoint ToScreenPoint (this MouseState mouse, IGameScree~\\
\cellcolor{red} & 0 & \verb~288~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~289~ & \verb~      Vector2 vector = mouse.ToVector2 () / screen.Viewport.ToVector2 ();~\\
\cellcolor{red} & 0 & \verb~290~ & \verb~      return new ScreenPoint (screen, vector);~\\
\cellcolor{red} & 0 & \verb~291~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~292~ & \verb~~\\
\cellcolor{gray} &  & \verb~293~ & \verb~    public static Point ToPoint (this MouseState mouse)~\\
\cellcolor{red} & 0 & \verb~294~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~295~ & \verb~      return new Point (mouse.X, mouse.Y);~\\
\cellcolor{red} & 0 & \verb~296~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~297~ & \verb~~\\
\cellcolor{gray} &  & \verb~298~ & \verb~    public static Vector2 ToVector2 (this Viewport viewport)~\\
\cellcolor{green} & 6 & \verb~299~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~300~ & \verb~      return new Vector2 (viewport.Width, viewport.Height);~\\
\cellcolor{green} & 6 & \verb~301~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~302~ & \verb~~\\
\cellcolor{gray} &  & \verb~303~ & \verb~    public static Vector2 Center (this Viewport viewport)~\\
\cellcolor{red} & 0 & \verb~304~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~305~ & \verb~      return new Vector2 (viewport.Width, viewport.Height) / 2;~\\
\cellcolor{red} & 0 & \verb~306~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~307~ & \verb~~\\
\cellcolor{gray} &  & \verb~308~ & \verb~    public static float Length (this Point p)~\\
\cellcolor{red} & 0 & \verb~309~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~310~ & \verb~      return p.ToVector2 ().Length ();~\\
\cellcolor{red} & 0 & \verb~311~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~312~ & \verb~~\\
\cellcolor{gray} &  & \verb~313~ & \verb~    public static Vector2 ToVector2 (this Point p)~\\
\cellcolor{red} & 0 & \verb~314~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~315~ & \verb~      return new Vector2 (p.X, p.Y);~\\
\cellcolor{red} & 0 & \verb~316~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~317~ & \verb~~\\
\cellcolor{gray} &  & \verb~318~ & \verb~    public static Point ToPoint (this Vector2 v)~\\
\cellcolor{green} & 6 & \verb~319~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~320~ & \verb~      return new Point ((int)v.X, (int)v.Y);~\\
\cellcolor{green} & 6 & \verb~321~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~322~ & \verb~~\\
\cellcolor{gray} &  & \verb~323~ & \verb~    public static Point Plus (this Point a, Point b)~\\
\cellcolor{red} & 0 & \verb~324~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~325~ & \verb~      return new Point (a.X + b.X, a.Y + b.Y);~\\
\cellcolor{red} & 0 & \verb~326~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~327~ & \verb~~\\
\cellcolor{gray} &  & \verb~328~ & \verb~    public static string Join (this string delimiter, List<int> list)~\\
\cellcolor{red} & 0 & \verb~329~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~330~ & \verb~      StringBuilder builder = new StringBuilder ();~\\
\cellcolor{red} & 0 & \verb~331~ & \verb~      foreach (int elem in list) {~\\
\cellcolor{gray} &  & \verb~332~ & \verb~        // Append each int to the StringBuilder overload.~\\
\cellcolor{red} & 0 & \verb~333~ & \verb~        builder.Append (elem).Append (delimiter);~\\
\cellcolor{red} & 0 & \verb~334~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~335~ & \verb~      return builder.ToString ();~\\
\cellcolor{red} & 0 & \verb~336~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~337~ & \verb~~\\
\cellcolor{gray} &  & \verb~338~ & \verb~    public static Vector2 ScaleFactor (this Viewport viewport)~\\
\cellcolor{red} & 0 & \verb~339~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~340~ & \verb~      Vector2 max = viewport.ToVector2 ();~\\
\cellcolor{red} & 0 & \verb~341~ & \verb~      return max / 1000f;~\\
\cellcolor{red} & 0 & \verb~342~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~343~ & \verb~~\\
\cellcolor{gray} &  & \verb~344~ & \verb~    public static Vector2 RelativeTo (this Vector2 v, Viewport viewport)~\\
\cellcolor{red} & 0 & \verb~345~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~346~ & \verb~      Vector2 max = viewport.ToVector2 ();~\\
\cellcolor{red} & 0 & \verb~347~ & \verb~      return v / max;~\\
\cellcolor{red} & 0 & \verb~348~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~349~ & \verb~~\\
\cellcolor{gray} &  & \verb~350~ & \verb~    public static Vector2 Scale (this Vector2 v, Viewport viewport)~\\
\cellcolor{green} & 6 & \verb~351~ & \verb~    {~\\
\cellcolor{green} & 6 & \verb~352~ & \verb~      Vector2 max = viewport.ToVector2 ();~\\
\cellcolor{green} & 6 & \verb~353~ & \verb~      if (v.X > 1 || v.Y > 1) {~\\
\cellcolor{red} & 0 & \verb~354~ & \verb~        return v / 1000f * max;~\\
\cellcolor{gray} &  & \verb~355~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~356~ & \verb~      else {~\\
\cellcolor{green} & 6 & \verb~357~ & \verb~        return v * max;~\\
\cellcolor{gray} &  & \verb~358~ & \verb~      }~\\
\cellcolor{green} & 6 & \verb~359~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~360~ & \verb~~\\
\cellcolor{gray} &  & \verb~361~ & \verb~    public static Rectangle Scale (this Rectangle rect, Viewport viewport)~\\
\cellcolor{red} & 0 & \verb~362~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~363~ & \verb~      Point max = viewport.ToVector2 ().ToPoint ();~\\
\cellcolor{gray} &  & \verb~364~ & \verb~~\\
\cellcolor{red} & 0 & \verb~365~ & \verb~      return new Rectangle (rect.X * max.X / 1000, rect.Y * max.Y / 1000, rect~\\
\cellcolor{red} & 0 & \verb~366~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~367~ & \verb~~\\
\cellcolor{gray} &  & \verb~368~ & \verb~    public static Rectangle Grow (this Rectangle rect, int x, int y)~\\
\cellcolor{red} & 0 & \verb~369~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~370~ & \verb~      return new Rectangle (rect.X - x, rect.Y - y, rect.Width + x * 2, rect.H~\\
\cellcolor{red} & 0 & \verb~371~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~372~ & \verb~~\\
\cellcolor{gray} &  & \verb~373~ & \verb~    public static Rectangle Shrink (this Rectangle rect, int x, int y)~\\
\cellcolor{red} & 0 & \verb~374~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~375~ & \verb~      return Grow (rect, -x, -y);~\\
\cellcolor{red} & 0 & \verb~376~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~377~ & \verb~~\\
\cellcolor{gray} &  & \verb~378~ & \verb~    public static Rectangle Grow (this Rectangle rect, int xy)~\\
\cellcolor{red} & 0 & \verb~379~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~380~ & \verb~      return Grow (rect, xy, xy);~\\
\cellcolor{red} & 0 & \verb~381~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~382~ & \verb~~\\
\cellcolor{gray} &  & \verb~383~ & \verb~    public static Rectangle Shrink (this Rectangle rect, int xy)~\\
\cellcolor{red} & 0 & \verb~384~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~385~ & \verb~      return Grow (rect, -xy, -xy);~\\
\cellcolor{red} & 0 & \verb~386~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~387~ & \verb~~\\
\cellcolor{gray} &  & \verb~388~ & \verb~    public static Rectangle Translate (this Rectangle rect, int x, int y)~\\
\cellcolor{red} & 0 & \verb~389~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~390~ & \verb~      return new Rectangle (rect.X + x, rect.Y + y, rect.Width, rect.Height);~\\
\cellcolor{red} & 0 & \verb~391~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~392~ & \verb~~\\
\cellcolor{gray} &  & \verb~393~ & \verb~    public static Rectangle Resize (this Rectangle rect, int w, int h)~\\
\cellcolor{red} & 0 & \verb~394~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~395~ & \verb~      return new Rectangle (rect.X, rect.Y, rect.Width + w, rect.Height + h);~\\
\cellcolor{red} & 0 & \verb~396~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~397~ & \verb~~\\
\cellcolor{gray} &  & \verb~398~ & \verb~    public static void Swap<T> (ref T lhs, ref T rhs)~\\
\cellcolor{red} & 0 & \verb~399~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~400~ & \verb~      T temp;~\\
\cellcolor{red} & 0 & \verb~401~ & \verb~      temp = lhs;~\\
\cellcolor{red} & 0 & \verb~402~ & \verb~      lhs = rhs;~\\
\cellcolor{red} & 0 & \verb~403~ & \verb~      rhs = temp;~\\
\cellcolor{red} & 0 & \verb~404~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~405~ & \verb~~\\
\cellcolor{gray} &  & \verb~406~ & \verb~    public static string Print (this Vector3 v)~\\
\cellcolor{red} & 0 & \verb~407~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~408~ & \verb~      return   "("~\\
\cellcolor{gray} &  & \verb~409~ & \verb~               + v.X.ToString ()~\\
\cellcolor{gray} &  & \verb~410~ & \verb~               + ","~\\
\cellcolor{gray} &  & \verb~411~ & \verb~               + v.Y.ToString ()~\\
\cellcolor{gray} &  & \verb~412~ & \verb~               + ","~\\
\cellcolor{gray} &  & \verb~413~ & \verb~               + v.Z.ToString ()~\\
\cellcolor{gray} &  & \verb~414~ & \verb~               + ")";~\\
\cellcolor{red} & 0 & \verb~415~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~416~ & \verb~~\\
\cellcolor{gray} &  & \verb~417~ & \verb~    public static BoundingSphere[] CylinderBounds (float length, float radius,~\\
\cellcolor{green} & 4 & \verb~418~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~419~ & \verb~      float distance = radius / 4;~\\
\cellcolor{green} & 4 & \verb~420~ & \verb~      BoundingSphere[] bounds = new BoundingSphere[(int)(length / distance)];~\\
\cellcolor{green} & 944 & \verb~421~ & \verb~      for (int offset = 0; offset < (int)(length / distance); ++offset) {~\\
\cellcolor{green} & 312 & \verb~422~ & \verb~        bounds [offset] = new BoundingSphere (position + direction * offset * ~\\
\cellcolor{gray} &  & \verb~423~ & \verb~        //Log.Debug ("sphere[", offset, "]=", Bounds [offset]);~\\
\cellcolor{green} & 312 & \verb~424~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~425~ & \verb~      return bounds;~\\
\cellcolor{green} & 4 & \verb~426~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~427~ & \verb~~\\
\cellcolor{gray} &  & \verb~428~ & \verb~    public static Rectangle CreateRectangle (this Vector2 topLeft, Vector2 siz~\\
\cellcolor{red} & 0 & \verb~429~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~430~ & \verb~      return CreateRectangle (0, topLeft.X, topLeft.Y, size.X, size.Y);~\\
\cellcolor{red} & 0 & \verb~431~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~432~ & \verb~~\\
\cellcolor{gray} &  & \verb~433~ & \verb~    public static Rectangle CreateRectangle (this Vector2 topLeft, Vector2 siz~\\
\cellcolor{red} & 0 & \verb~434~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~435~ & \verb~      return CreateRectangle (lineWidth, topLeft.X, topLeft.Y, size.X, size.Y)~\\
\cellcolor{red} & 0 & \verb~436~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~437~ & \verb~~\\
\cellcolor{gray} &  & \verb~438~ & \verb~    public static Rectangle CreateRectangle (int lineWidth, float x, float y, ~\\
\cellcolor{red} & 0 & \verb~439~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~440~ & \verb~      if (w == 0) {~\\
\cellcolor{red} & 0 & \verb~441~ & \verb~        return new Rectangle ((int)x - lineWidth / 2, (int)y - lineWidth / 2, ~\\
\cellcolor{gray} &  & \verb~442~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~443~ & \verb~      else if (h == 0) {~\\
\cellcolor{red} & 0 & \verb~444~ & \verb~        return new Rectangle ((int)x - lineWidth / 2, (int)y - lineWidth / 2, ~\\
\cellcolor{gray} &  & \verb~445~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~446~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~447~ & \verb~        return new Rectangle ((int)x, (int)y, (int)w, (int)h);~\\
\cellcolor{gray} &  & \verb~448~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~449~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~450~ & \verb~~\\
\cellcolor{gray} &  & \verb~451~ & \verb~    public static T At<T> (this List<T> list, int index)~\\
\cellcolor{red} & 0 & \verb~452~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~453~ & \verb~      if (list.Count == 0) {~\\
\cellcolor{red} & 0 & \verb~454~ & \verb~        return default (T);~\\
\cellcolor{gray} &  & \verb~455~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~456~ & \verb~      else {~\\
\cellcolor{red} & 0 & \verb~457~ & \verb~        while (index < 0) {~\\
\cellcolor{red} & 0 & \verb~458~ & \verb~          index += list.Count;~\\
\cellcolor{red} & 0 & \verb~459~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~460~ & \verb~        if (index >= list.Count) {~\\
\cellcolor{red} & 0 & \verb~461~ & \verb~          index = index % list.Count;~\\
\cellcolor{red} & 0 & \verb~462~ & \verb~        }~\\
\cellcolor{red} & 0 & \verb~463~ & \verb~        return list [index];~\\
\cellcolor{gray} &  & \verb~464~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~465~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~466~ & \verb~~\\
\cellcolor{gray} &  & \verb~467~ & \verb~    public static T At<T> (this IEnumerable<T> list, int index)~\\
\cellcolor{green} & 606 & \verb~468~ & \verb~    {~\\
\cellcolor{green} & 606 & \verb~469~ & \verb~      int count = list.Count ();~\\
\cellcolor{green} & 804 & \verb~470~ & \verb~      if (count == 0) {~\\
\cellcolor{green} & 198 & \verb~471~ & \verb~        return default (T);~\\
\cellcolor{gray} &  & \verb~472~ & \verb~      }~\\
\cellcolor{green} & 408 & \verb~473~ & \verb~      else {~\\
\cellcolor{green} & 408 & \verb~474~ & \verb~        while (index < 0) {~\\
\cellcolor{red} & 0 & \verb~475~ & \verb~          index += count;~\\
\cellcolor{red} & 0 & \verb~476~ & \verb~        }~\\
\cellcolor{green} & 409 & \verb~477~ & \verb~        if (index >= count) {~\\
\cellcolor{green} & 1 & \verb~478~ & \verb~          index = index % count;~\\
\cellcolor{green} & 1 & \verb~479~ & \verb~        }~\\
\cellcolor{green} & 408 & \verb~480~ & \verb~        return list.ElementAt (index);~\\
\cellcolor{gray} &  & \verb~481~ & \verb~      }~\\
\cellcolor{green} & 606 & \verb~482~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~483~ & \verb~~\\
\cellcolor{gray} &  & \verb~484~ & \verb~    public static T At<T> (this Tuple<T,T> tuple, int i)~\\
\cellcolor{red} & 0 & \verb~485~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~486~ & \verb~      return i == 0 ? tuple.Item1 : i == 1 ? tuple.Item2 : default (T);~\\
\cellcolor{red} & 0 & \verb~487~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~488~ & \verb~~\\
\cellcolor{gray} &  & \verb~489~ & \verb~    public static T At<T> (this Tuple<T,T,T> tuple, int i)~\\
\cellcolor{red} & 0 & \verb~490~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~491~ & \verb~      return i == 0 ? tuple.Item1 : i == 1 ? tuple.Item2 : i == 2 ? tuple.Item~\\
\cellcolor{red} & 0 & \verb~492~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~493~ & \verb~~\\
\cellcolor{gray} &  & \verb~494~ & \verb~    public static IEnumerable<T> ToEnumerable<T> (this Tuple<T,T> tuple)~\\
\cellcolor{red} & 0 & \verb~495~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~496~ & \verb~      yield return tuple.Item1;~\\
\cellcolor{red} & 0 & \verb~497~ & \verb~      yield return tuple.Item2;~\\
\cellcolor{red} & 0 & \verb~498~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~499~ & \verb~~\\
\cellcolor{gray} &  & \verb~500~ & \verb~    public static IEnumerable<T> ToEnumerable<T> (this Tuple<T,T,T> tuple)~\\
\cellcolor{red} & 0 & \verb~501~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~502~ & \verb~      yield return tuple.Item1;~\\
\cellcolor{red} & 0 & \verb~503~ & \verb~      yield return tuple.Item2;~\\
\cellcolor{red} & 0 & \verb~504~ & \verb~      yield return tuple.Item3;~\\
\cellcolor{red} & 0 & \verb~505~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~506~ & \verb~~\\
\cellcolor{green} & 1 & \verb~507~ & \verb~    private static Random random = new Random (Guid.NewGuid ().GetHashCode ())~\\
\cellcolor{gray} &  & \verb~508~ & \verb~~\\
\cellcolor{gray} &  & \verb~509~ & \verb~    public static int RandomIndex<T> (this IEnumerable<T> list)~\\
\cellcolor{red} & 0 & \verb~510~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~511~ & \verb~      int index = random.Next (list.Count ());~\\
\cellcolor{red} & 0 & \verb~512~ & \verb~      return index;~\\
\cellcolor{red} & 0 & \verb~513~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~514~ & \verb~~\\
\cellcolor{gray} &  & \verb~515~ & \verb~    public static T RandomElement<T> (this IEnumerable<T> list)~\\
\cellcolor{red} & 0 & \verb~516~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~517~ & \verb~      return list.At (list.RandomIndex ());~\\
\cellcolor{red} & 0 & \verb~518~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~519~ & \verb~~\\
\cellcolor{gray} &  & \verb~520~ & \verb~    public static void SetCoordinates (this Widget widget, float left, float t~\\
\cellcolor{red} & 0 & \verb~521~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~522~ & \verb~      widget.Bounds.Position = new ScreenPoint (widget.Screen, left, top);~\\
\cellcolor{red} & 0 & \verb~523~ & \verb~      widget.Bounds.Size = new ScreenPoint (widget.Screen, right - left, botto~\\
\cellcolor{red} & 0 & \verb~524~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~525~ & \verb~~\\
\cellcolor{gray} &  & \verb~526~ & \verb~    public static Dictionary<A, B> ReverseDictionary<A,B> (this Dictionary<B,A~\\
\cellcolor{red} & 0 & \verb~527~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~528~ & \verb~      return dict.ToDictionary (x => x.Value, x => x.Key);~\\
\cellcolor{red} & 0 & \verb~529~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~530~ & \verb~~\\
\cellcolor{gray} &  & \verb~531~ & \verb~    public static float DistanceTo (this Vector3 origin, Vector3 target)~\\
\cellcolor{green} & 37 & \verb~532~ & \verb~    {~\\
\cellcolor{green} & 37 & \verb~533~ & \verb~      Vector3 toPosition = origin - target;~\\
\cellcolor{green} & 37 & \verb~534~ & \verb~      return toPosition.Length ();~\\
\cellcolor{green} & 37 & \verb~535~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~536~ & \verb~~\\
\cellcolor{gray} &  & \verb~537~ & \verb~    public static Vector3 SetDistanceTo (this Vector3 origin, Vector3 target, ~\\
\cellcolor{green} & 4 & \verb~538~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~539~ & \verb~      Vector3 to = origin - target;~\\
\cellcolor{green} & 4 & \verb~540~ & \verb~      float oldDistance = to.Length ();~\\
\cellcolor{green} & 4 & \verb~541~ & \verb~      double scale = (double)distance / (double)to.Length ();~\\
\cellcolor{green} & 7 & \verb~542~ & \verb~      if (Math.Abs (oldDistance) > 1 && Math.Abs (oldDistance - distance) > 1 ~\\
\cellcolor{green} & 3 & \verb~543~ & \verb~        return target + to * (float)scale;~\\
\cellcolor{gray} &  & \verb~544~ & \verb~      }~\\
\cellcolor{green} & 1 & \verb~545~ & \verb~      else {~\\
\cellcolor{green} & 1 & \verb~546~ & \verb~        return origin;~\\
\cellcolor{gray} &  & \verb~547~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~548~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~549~ & \verb~~\\
\cellcolor{gray} &  & \verb~550~ & \verb~    public static IEnumerable<T> Shuffle<T> (this IEnumerable<T> source)~\\
\cellcolor{red} & 0 & \verb~551~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~552~ & \verb~      Random rnd = new Random ();~\\
\cellcolor{red} & 0 & \verb~553~ & \verb~      return source.OrderBy<T, int> ((item) => rnd.Next ());~\\
\cellcolor{red} & 0 & \verb~554~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~555~ & \verb~~\\
\cellcolor{gray} &  & \verb~556~ & \verb~    public static void Repeat (this int count, Action action)~\\
\cellcolor{red} & 0 & \verb~557~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~558~ & \verb~      for (int i = 0; i < count; i++) {~\\
\cellcolor{red} & 0 & \verb~559~ & \verb~        action ();~\\
\cellcolor{red} & 0 & \verb~560~ & \verb~      }~\\
\cellcolor{red} & 0 & \verb~561~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~562~ & \verb~~\\
\cellcolor{gray} &  & \verb~563~ & \verb~    public static void Repeat (this int count, Action<int> action)~\\
\cellcolor{green} & 70 & \verb~564~ & \verb~    {~\\
\cellcolor{green} & 3824 & \verb~565~ & \verb~      for (int i = 0; i < count; i++) {~\\
\cellcolor{green} & 1228 & \verb~566~ & \verb~        action (i);~\\
\cellcolor{green} & 1228 & \verb~567~ & \verb~      }~\\
\cellcolor{green} & 70 & \verb~568~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~569~ & \verb~~\\
\cellcolor{gray} &  & \verb~570~ & \verb~    public static IEnumerable<T> Repeat<T> (this int count, Func<int, T> func)~\\
\cellcolor{green} & 80 & \verb~571~ & \verb~    {~\\
\cellcolor{green} & 80 & \verb~572~ & \verb~      List<T> list = new List<T> ();~\\
\cellcolor{green} & 4990 & \verb~573~ & \verb~      for (int i = 0; i < count; i++) {~\\
\cellcolor{green} & 1610 & \verb~574~ & \verb~        list.Add (func (i));~\\
\cellcolor{green} & 1610 & \verb~575~ & \verb~      }~\\
\cellcolor{green} & 80 & \verb~576~ & \verb~      return list;~\\
\cellcolor{green} & 80 & \verb~577~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~578~ & \verb~~\\
\cellcolor{gray} &  & \verb~579~ & \verb~    public static IEnumerable<int> Range (this int count)~\\
\cellcolor{green} & 2 & \verb~580~ & \verb~    {~\\
\cellcolor{green} & 604 & \verb~581~ & \verb~      for (int i = 0; i < count; i++) {~\\
\cellcolor{green} & 200 & \verb~582~ & \verb~        yield return i;~\\
\cellcolor{green} & 200 & \verb~583~ & \verb~      }~\\
\cellcolor{green} & 2 & \verb~584~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~585~ & \verb~~\\
\cellcolor{gray} &  & \verb~586~ & \verb~    public static void ForEach<U> (this IEnumerable<U> enumerable, Action<U> a~\\
\cellcolor{green} & 4 & \verb~587~ & \verb~    {~\\
\cellcolor{green} & 132 & \verb~588~ & \verb~      foreach (U item in enumerable) {~\\
\cellcolor{green} & 40 & \verb~589~ & \verb~        action (item);~\\
\cellcolor{green} & 40 & \verb~590~ & \verb~      }~\\
\cellcolor{green} & 4 & \verb~591~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~592~ & \verb~  }~\\
\cellcolor{gray} &  & \verb~593~ & \verb~}~\\
\end{longtable}
\end{document}