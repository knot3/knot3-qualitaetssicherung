\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper,left=20mm,right=20mm,top=20mm,bottom=20mm]{geometry}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage[pdftex]{color}
\usepackage{colortbl}
\definecolor{green}{rgb}{0,1,0.12}
\definecolor{red}{rgb}{1,0,0}
\definecolor{gray}{rgb}{0.86,0.86,0.86}

\usepackage[pdftex,
            colorlinks=true, linkcolor=red, urlcolor=green, citecolor=red,%
            raiselinks=true,%
            bookmarks=true,%
            bookmarksopenlevel=1,%
            bookmarksopen=true,%
            bookmarksnumbered=true,%
            hyperindex=true,% 
            plainpages=false,% correct hyperlinks
            pdfpagelabels=true%,% view TeX pagenumber in PDF reader
            %pdfborder={0 0 0.5}
            ]{hyperref}

\hypersetup{pdftitle={Coverage Report},
            pdfauthor={ReportGenerator - 1.9.1.0}
           }

\pagestyle{fancy}
\fancyhead[LE,LO]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{ReportGenerator - 1.9.1.0}

\begin{document}

\setcounter{secnumdepth}{-1}
\section{Summary}
\begin{longtable}[l]{ll}
\textbf{Generated on:} & 09.03.2014 - 12:33:52\\
\textbf{Parser:} & OpenCoverParser\\
\textbf{Assemblies:} & 2\\
\textbf{Classes:} & 44\\
\textbf{Files:} & 44\\
\textbf{Coverage:} & 86.2\%\\
\textbf{Covered lines:} & 2097\\
\textbf{Uncovered lines:} & 335\\
\textbf{Coverable lines:} & 2432\\
\textbf{Total lines:} & 7153\\
\end{longtable}
\section{Assemblies}
\begin{longtable}[l]{ll}
\textbf{Knot3} & \textbf{89\%}\\
Knot3.Game.Audio.Knot3AudioManager & 100\%\\
Knot3.Game.Audio.Knot3Sound & 100\%\\
Knot3.Game.Data.Axis & 100\%\\
Knot3.Game.Data.Challenge & 70\%\\
Knot3.Game.Data.ChallengeFileIO & 90.5\%\\
Knot3.Game.Data.ChallengeMetaData & 89\%\\
Knot3.Game.Data.CircleEntry`1 & 92.3\%\\
Knot3.Game.Data.CircleExtensions & 100\%\\
Knot3.Game.Data.Direction & 100\%\\
Knot3.Game.Data.Edge & 100\%\\
Knot3.Game.Data.Knot & 84.8\%\\
Knot3.Game.Data.KnotFileIO & 85\%\\
Knot3.Game.Data.KnotMetaData & 86\%\\
Knot3.Game.Data.KnotStringIO & 86.2\%\\
Knot3.Game.Data.Node & 73.7\%\\
Knot3.Game.Data.NodeMap & 88.5\%\\
Knot3.Game.Utilities.FileIndex & 100\%\\
Knot3.Game.Utilities.SavegameLoader`2 & 100\%\\
\textbf{Knot3.Framework} & \textbf{83\%}\\
Knot3.Framework.Audio.AudioManager & 86.9\%\\
Knot3.Framework.Audio.LoopPlaylist & 69.2\%\\
Knot3.Framework.Audio.OggVorbisFile & 86\%\\
Knot3.Framework.Audio.SilentAudioManager & 0\%\\
Knot3.Framework.Audio.Sound & 100\%\\
Knot3.Framework.Core.Camera & 65.3\%\\
Knot3.Framework.Core.DisplayLayer & 98.1\%\\
Knot3.Framework.Core.TypesafeEnum`1 & 100\%\\
Knot3.Framework.Math.Angles3 & 100\%\\
Knot3.Framework.Math.BoundingCylinder & 90.4\%\\
Knot3.Framework.Math.Bounds & 94.5\%\\
Knot3.Framework.Math.RayExtensions & 68\%\\
Knot3.Framework.Math.ScreenPoint & 51.8\%\\
Knot3.Framework.Platform.SystemInfo & 100\%\\
Knot3.Framework.Storage.BooleanOption & 100\%\\
Knot3.Framework.Storage.Config & 66.6\%\\
Knot3.Framework.Storage.ConfigFile & 100\%\\
Knot3.Framework.Storage.DistinctOption & 100\%\\
Knot3.Framework.Storage.FileUtility & 97.2\%\\
Knot3.Framework.Storage.FloatOption & 92\%\\
Knot3.Framework.Storage.IniFile & 96.9\%\\
Knot3.Framework.Storage.KeyOption & 100\%\\
Knot3.Framework.Storage.Language & 87.8\%\\
Knot3.Framework.Storage.LanguageOption & 76.9\%\\
Knot3.Framework.Storage.Localizer & 87.5\%\\
Knot3.Framework.Storage.Option & 100\%\\
\end{longtable}
\newpage
\section{Knot3.Game.Audio.Knot3AudioManager}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Audio.Knot3AudioManager\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Audio\textbackslash Knot3AudioManager.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 11\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 11\\
\textbf{Total lines:} & 57\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{Initialize(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Audio\textbackslash Knot3AudioManager.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Knot3.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Game.Audio~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    public class Knot3AudioManager : AudioManager~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    {~\\
\cellcolor{green} & 4 & \verb~41~ & \verb~        public Knot3AudioManager (GameCore game)~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        : base (game)~\\
\cellcolor{green} & 4 & \verb~43~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~44~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public override void Initialize (string directory)~\\
\cellcolor{green} & 5 & \verb~47~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~48~ & \verb~            AudioDirectories [Knot3Sound.CreativeMusic] = "Music/Creative";~\\
\cellcolor{green} & 5 & \verb~49~ & \verb~            AudioDirectories [Knot3Sound.ChallengeMusic] = "Music/Challenge";~\\
\cellcolor{green} & 5 & \verb~50~ & \verb~            AudioDirectories [Knot3Sound.MenuMusic] = "Music/Menu";~\\
\cellcolor{green} & 5 & \verb~51~ & \verb~            AudioDirectories [Knot3Sound.PipeMoveSound] = "Sound/Pipe/Move";~\\
\cellcolor{green} & 5 & \verb~52~ & \verb~            AudioDirectories [Knot3Sound.PipeInvalidMoveSound] = "Sound/Pipe/I~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{green} & 5 & \verb~54~ & \verb~            base.Initialize (directory);~\\
\cellcolor{green} & 5 & \verb~55~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~57~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Audio.Knot3Sound}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Audio.Knot3Sound\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Audio\textbackslash Knot3Sound.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 5\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 5\\
\textbf{Total lines:} & 45\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Audio\textbackslash Knot3Sound.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using Knot3.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Game.Audio~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    public static class Knot3Sound~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~39~ & \verb~        public static readonly Sound CreativeMusic = new Sound ("CreativeMusic~\\
\cellcolor{green} & 1 & \verb~40~ & \verb~        public static readonly Sound ChallengeMusic = new Sound ("ChallengeMus~\\
\cellcolor{green} & 1 & \verb~41~ & \verb~        public static readonly Sound MenuMusic = new Sound ("MenuMusic");~\\
\cellcolor{green} & 1 & \verb~42~ & \verb~        public static readonly Sound PipeMoveSound = new Sound ("PipeMoveSound~\\
\cellcolor{green} & 1 & \verb~43~ & \verb~        public static readonly Sound PipeInvalidMoveSound = new Sound ("PipeIn~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.Axis}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.Axis\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Axis.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 7\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 7\\
\textbf{Total lines:} & 50\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Axis.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~37~ & \verb~{~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    public class Axis : TypesafeEnum<Axis>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~40~ & \verb~        public static readonly Axis X = new Axis ("X");~\\
\cellcolor{green} & 1 & \verb~41~ & \verb~        public static readonly Axis Y = new Axis ("Y");~\\
\cellcolor{green} & 1 & \verb~42~ & \verb~        public static readonly Axis Z = new Axis ("Z");~\\
\cellcolor{green} & 1 & \verb~43~ & \verb~        public static readonly Axis Zero = new Axis ("Zero");~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{green} & 4 & \verb~45~ & \verb~        private Axis (string name)~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        : base (name)~\\
\cellcolor{green} & 4 & \verb~47~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~48~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~50~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.Challenge}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.Challenge\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Challenge.cs}\end{minipage} \\
\textbf{Coverage:} & 70\%\\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 20\\
\textbf{Total lines:} & 103\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{AddToHighscore(...)} & 1 & 0 & 0\\
\hline
\textbf{Save()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Challenge.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~35~ & \verb~{~\\
\cellcolor{gray} &  & \verb~36~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    /// Ein Objekt dieser Klasse repräsentiert eine Challenge.~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    public sealed class Challenge~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// Der Ausgangsknoten, den der Spieler in den Referenzknoten transfor~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~44~ & \verb~        public Knot Start { get; private set; }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// Der Referenzknoten, in den der Spieler den Ausgangsknoten transfor~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~49~ & \verb~        public Knot Target { get; private set; }~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// Eine sortierte Bestenliste.~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~54~ & \verb~        private SortedList<int, string> highscore { get; set; }~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// Ein öffentlicher Enumerator, der die Bestenliste unabhängig von de~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~59~ & \verb~        public IEnumerable<KeyValuePair<string, int>> Highscore { get { return~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// Die Metadaten der Challenge.~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~64~ & \verb~        public ChallengeMetaData MetaData { get; private set; }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        /// Der Name der Challenge.~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        public string Name~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~71~ & \verb~            get { return MetaData.Name; }~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~            set { MetaData.Name = value; }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// Erstellt ein Challenge-Objekt aus einem gegebenen Challenge-Metada~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// Erstellt ein Challenge-Objekt aus einer gegebenen Challenge-Datei.~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~79~ & \verb~        public Challenge (ChallengeMetaData meta, Knot start, Knot target)~\\
\cellcolor{green} & 3 & \verb~80~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~81~ & \verb~            MetaData = meta;~\\
\cellcolor{green} & 3 & \verb~82~ & \verb~            Start = start;~\\
\cellcolor{green} & 3 & \verb~83~ & \verb~            Target = target;~\\
\cellcolor{green} & 3 & \verb~84~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// Fügt eine neue Bestzeit eines bestimmten Spielers in die Bestenlis~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        public void AddToHighscore (string name, int time)~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~            MetaData.AddToHighscore (name, time);~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~            Save ();~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~96~ & \verb~        /// Speichert die Challenge.~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        public void Save ()~\\
\cellcolor{green} & 1 & \verb~99~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~100~ & \verb~            MetaData.Format.Save (this);~\\
\cellcolor{green} & 1 & \verb~101~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.ChallengeFileIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.ChallengeFileIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash ChallengeFileIO.cs}\end{minipage} \\
\textbf{Coverage:} & 90.5\%\\
\textbf{Covered lines:} & 86\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 95\\
\textbf{Total lines:} & 232\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 1 & 100 & 100\\
\hline
\textbf{Save(...)} & 2 & 100 & 66.67\\
\hline
\textbf{Load(...)} & 9 & 93.33 & 70.59\\
\hline
\textbf{LoadMetaData(...)} & 11 & 100 & 80.95\\
\hline
\textbf{MoveNext()} & 8 & 28.57 & 25\\
\hline
\textbf{MoveNext()} & 5 & 100 & 71.43\\
\hline
\textbf{MoveNext()} & 7 & 100 & 63.64\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash ChallengeFileIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Ionic.Zip;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~42~ & \verb~{~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    /// Implementiert das Speicherformat für Challenges.~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    public sealed class ChallengeFileIO : IChallengeIO~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Die für eine Knoten-Datei gültigen Dateiendungen.~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// </summary>~\\
\cellcolor{green} & 10 & \verb~51~ & \verb~        public IEnumerable<string> FileExtensions~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~53~ & \verb~            get {~\\
\cellcolor{green} & 10 & \verb~54~ & \verb~                yield return ".challenge";~\\
\cellcolor{red} & 0 & \verb~55~ & \verb~                yield return ".chl";~\\
\cellcolor{red} & 0 & \verb~56~ & \verb~                yield return ".chn";~\\
\cellcolor{red} & 0 & \verb~57~ & \verb~                yield return ".chg";~\\
\cellcolor{red} & 0 & \verb~58~ & \verb~                yield return ".chlng";~\\
\cellcolor{red} & 0 & \verb~59~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        /// Erstellt ein ChallengeFileIO-Objekt.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// </summary>~\\
\cellcolor{green} & 7 & \verb~65~ & \verb~        public ChallengeFileIO ()~\\
\cellcolor{green} & 7 & \verb~66~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~67~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// Speichert eine Challenge in dem Dateinamen, der in dem Challenge-O~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        public void Save (Challenge challenge)~\\
\cellcolor{green} & 1 & \verb~73~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~74~ & \verb~            using (ZipFile zip = new ZipFile ()) {~\\
\cellcolor{gray} &  & \verb~75~ & \verb~                // Namen~\\
\cellcolor{green} & 1 & \verb~76~ & \verb~                zip.AddEntry ("name.txt", challenge.Name);~\\
\cellcolor{gray} &  & \verb~77~ & \verb~                // Startknoten~\\
\cellcolor{green} & 1 & \verb~78~ & \verb~                KnotStringIO parser = new KnotStringIO (challenge.Start);~\\
\cellcolor{green} & 1 & \verb~79~ & \verb~                zip.AddEntry ("start.knot", parser.Content);~\\
\cellcolor{gray} &  & \verb~80~ & \verb~                // Zielknoten~\\
\cellcolor{green} & 1 & \verb~81~ & \verb~                parser = new KnotStringIO (challenge.Target);~\\
\cellcolor{green} & 1 & \verb~82~ & \verb~                zip.AddEntry ("target.knot", parser.Content);~\\
\cellcolor{gray} &  & \verb~83~ & \verb~                // Highscore~\\
\cellcolor{green} & 1 & \verb~84~ & \verb~                zip.AddEntry ("highscore.txt", string.Join ("\n", printHighsco~\\
\cellcolor{gray} &  & \verb~85~ & \verb~                // ZIP-Datei speichern~\\
\cellcolor{green} & 1 & \verb~86~ & \verb~                zip.Save (challenge.MetaData.Filename);~\\
\cellcolor{green} & 1 & \verb~87~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~88~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        /// Lädt eine Challenge aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        public Challenge Load (string filename)~\\
\cellcolor{green} & 5 & \verb~94~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~95~ & \verb~            ChallengeMetaData meta = LoadMetaData (filename: filename);~\\
\cellcolor{green} & 3 & \verb~96~ & \verb~            Knot start = null;~\\
\cellcolor{green} & 3 & \verb~97~ & \verb~            Knot target = null;~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{green} & 6 & \verb~99~ & \verb~            using (ZipFile zip = ZipFile.Read (filename)) {~\\
\cellcolor{green} & 45 & \verb~100~ & \verb~                foreach (ZipEntry entry in zip) {~\\
\cellcolor{green} & 12 & \verb~101~ & \verb~                    string content = entry.ReadContent ();~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~                    // für die Datei mit dem Startknoten~\\
\cellcolor{green} & 15 & \verb~104~ & \verb~                    if (entry.FileName.ToLower ().Contains ("start")) {~\\
\cellcolor{green} & 3 & \verb~105~ & \verb~                        KnotStringIO parser = new KnotStringIO (content: conte~\\
\cellcolor{green} & 3 & \verb~106~ & \verb~                        start = new Knot (~\\
\cellcolor{red} & 0 & \verb~107~ & \verb~                            new KnotMetaData (parser.Name, () => parser.CountE~\\
\cellcolor{gray} &  & \verb~108~ & \verb~                            parser.Edges~\\
\cellcolor{gray} &  & \verb~109~ & \verb~                        );~\\
\cellcolor{green} & 3 & \verb~110~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~                    // für die Datei mit dem Zielknoten~\\
\cellcolor{green} & 12 & \verb~113~ & \verb~                    else if (entry.FileName.ToLower ().Contains ("target")) {~\\
\cellcolor{green} & 3 & \verb~114~ & \verb~                        KnotStringIO parser = new KnotStringIO (content: conte~\\
\cellcolor{green} & 3 & \verb~115~ & \verb~                        target = new Knot (~\\
\cellcolor{red} & 0 & \verb~116~ & \verb~                            new KnotMetaData (parser.Name, () => parser.CountE~\\
\cellcolor{gray} &  & \verb~117~ & \verb~                            parser.Edges~\\
\cellcolor{gray} &  & \verb~118~ & \verb~                        );~\\
\cellcolor{green} & 3 & \verb~119~ & \verb~                    }~\\
\cellcolor{green} & 12 & \verb~120~ & \verb~                }~\\
\cellcolor{green} & 3 & \verb~121~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{green} & 6 & \verb~123~ & \verb~            if (meta != null && start != null && target != null) {~\\
\cellcolor{green} & 3 & \verb~124~ & \verb~                return new Challenge (meta, start, target);~\\
\cellcolor{gray} &  & \verb~125~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~                throw new IOException (~\\
\cellcolor{gray} &  & \verb~128~ & \verb~                    "Error! Invalid challenge file: " + filename~\\
\cellcolor{gray} &  & \verb~129~ & \verb~                    + " (meta=" + meta + ",start=" + start + ",target=" + targ~\\
\cellcolor{gray} &  & \verb~130~ & \verb~                );~\\
\cellcolor{gray} &  & \verb~131~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~132~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~133~ & \verb~~\\
\cellcolor{gray} &  & \verb~134~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        /// Lädt die Metadaten einer Challenge aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~137~ & \verb~        public ChallengeMetaData LoadMetaData (string filename)~\\
\cellcolor{green} & 7 & \verb~138~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~139~ & \verb~            string name = null;~\\
\cellcolor{green} & 7 & \verb~140~ & \verb~            KnotMetaData start = null;~\\
\cellcolor{green} & 7 & \verb~141~ & \verb~            KnotMetaData target = null;~\\
\cellcolor{green} & 7 & \verb~142~ & \verb~            IEnumerable<KeyValuePair<string, int>> highscore = null;~\\
\cellcolor{green} & 13 & \verb~143~ & \verb~            using (ZipFile zip = ZipFile.Read (filename)) {~\\
\cellcolor{green} & 87 & \verb~144~ & \verb~                foreach (ZipEntry entry in zip) {~\\
\cellcolor{green} & 23 & \verb~145~ & \verb~                    string content = entry.ReadContent ();~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~                    // für die Datei mit dem Startknoten~\\
\cellcolor{green} & 29 & \verb~148~ & \verb~                    if (entry.FileName.ToLower ().Contains ("start")) {~\\
\cellcolor{green} & 6 & \verb~149~ & \verb~                        KnotStringIO parser = new KnotStringIO (content: conte~\\
\cellcolor{green} & 6 & \verb~150~ & \verb~                        start = new KnotMetaData (parser.Name, () => parser.Co~\\
\cellcolor{green} & 6 & \verb~151~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~152~ & \verb~~\\
\cellcolor{gray} &  & \verb~153~ & \verb~                    // für die Datei mit dem Zielknoten~\\
\cellcolor{green} & 23 & \verb~154~ & \verb~                    else if (entry.FileName.ToLower ().Contains ("target")) {~\\
\cellcolor{green} & 6 & \verb~155~ & \verb~                        KnotStringIO parser = new KnotStringIO (content: conte~\\
\cellcolor{green} & 6 & \verb~156~ & \verb~                        target = new KnotMetaData (parser.Name, () => parser.C~\\
\cellcolor{green} & 6 & \verb~157~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{gray} &  & \verb~159~ & \verb~                    // für die Datei mit dem Namen~\\
\cellcolor{green} & 16 & \verb~160~ & \verb~                    else if (entry.FileName.ToLower ().Contains ("name")) {~\\
\cellcolor{green} & 5 & \verb~161~ & \verb~                        name = content.Trim ();~\\
\cellcolor{green} & 5 & \verb~162~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~163~ & \verb~~\\
\cellcolor{gray} &  & \verb~164~ & \verb~                    // für die Datei mit den Highscores~\\
\cellcolor{green} & 12 & \verb~165~ & \verb~                    else if (entry.FileName.ToLower ().Contains ("highscore"))~\\
\cellcolor{green} & 6 & \verb~166~ & \verb~                        highscore = parseHighscore (content.Split (new char[] ~\\
\cellcolor{green} & 6 & \verb~167~ & \verb~                    }~\\
\cellcolor{green} & 23 & \verb~168~ & \verb~                }~\\
\cellcolor{green} & 6 & \verb~169~ & \verb~            }~\\
\cellcolor{green} & 11 & \verb~170~ & \verb~            if (name != null && start != null && target != null) {~\\
\cellcolor{green} & 5 & \verb~171~ & \verb~                Log.Debug ("Load challenge file: ", filename, " (name=", name,~\\
\cellcolor{green} & 5 & \verb~172~ & \verb~                return new ChallengeMetaData (~\\
\cellcolor{gray} &  & \verb~173~ & \verb~                           name: name,~\\
\cellcolor{gray} &  & \verb~174~ & \verb~                           start: start,~\\
\cellcolor{gray} &  & \verb~175~ & \verb~                           target: target,~\\
\cellcolor{gray} &  & \verb~176~ & \verb~                           filename: filename,~\\
\cellcolor{gray} &  & \verb~177~ & \verb~                           format: this,~\\
\cellcolor{gray} &  & \verb~178~ & \verb~                           highscore: highscore~\\
\cellcolor{gray} &  & \verb~179~ & \verb~                       );~\\
\cellcolor{gray} &  & \verb~180~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~181~ & \verb~            else {~\\
\cellcolor{green} & 1 & \verb~182~ & \verb~                throw new IOException (~\\
\cellcolor{gray} &  & \verb~183~ & \verb~                    "Error! Invalid challenge file: " + filename~\\
\cellcolor{gray} &  & \verb~184~ & \verb~                    + " (name=" + name + ",start=" + start + ",target=" + targ~\\
\cellcolor{gray} &  & \verb~185~ & \verb~                );~\\
\cellcolor{gray} &  & \verb~186~ & \verb~            }~\\
\cellcolor{green} & 5 & \verb~187~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~188~ & \verb~~\\
\cellcolor{gray} &  & \verb~189~ & \verb~        IEnumerable<string> printHighscore (IEnumerable<KeyValuePair<string, i~\\
\cellcolor{green} & 1 & \verb~190~ & \verb~        {~\\
\cellcolor{green} & 12 & \verb~191~ & \verb~            foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{green} & 3 & \verb~192~ & \verb~                Log.Debug (~\\
\cellcolor{gray} &  & \verb~193~ & \verb~                    "Save Highscore: "~\\
\cellcolor{gray} &  & \verb~194~ & \verb~                    + entry.Value.ToString ()~\\
\cellcolor{gray} &  & \verb~195~ & \verb~                    + ":"~\\
\cellcolor{gray} &  & \verb~196~ & \verb~                    + entry.Key.ToString ()~\\
\cellcolor{gray} &  & \verb~197~ & \verb~                );~\\
\cellcolor{gray} &  & \verb~198~ & \verb~~\\
\cellcolor{green} & 3 & \verb~199~ & \verb~                yield return entry.Value + ":" + entry.Key;~\\
\cellcolor{green} & 3 & \verb~200~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~201~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~202~ & \verb~~\\
\cellcolor{gray} &  & \verb~203~ & \verb~        IEnumerable<KeyValuePair<string, int>> parseHighscore (IEnumerable<str~\\
\cellcolor{green} & 5 & \verb~204~ & \verb~        {~\\
\cellcolor{green} & 60 & \verb~205~ & \verb~            foreach (string line in highscore) {~\\
\cellcolor{green} & 15 & \verb~206~ & \verb~                Log.Debug ("Load Highscore: ",line);~\\
\cellcolor{green} & 30 & \verb~207~ & \verb~                if (line.Contains (":")) {~\\
\cellcolor{green} & 15 & \verb~208~ & \verb~                    string[] entry = line.Split (new char[] {':'}, 2, StringSp~\\
\cellcolor{green} & 15 & \verb~209~ & \verb~                    string name = entry [1].Trim ();~\\
\cellcolor{gray} &  & \verb~210~ & \verb~                    int time;~\\
\cellcolor{green} & 30 & \verb~211~ & \verb~                    if (Int32.TryParse (entry [0], out time)) {~\\
\cellcolor{green} & 15 & \verb~212~ & \verb~                        Log.Debug ("=> ", name, ":", time);~\\
\cellcolor{green} & 15 & \verb~213~ & \verb~                        yield return new KeyValuePair<string, int> (name, time~\\
\cellcolor{green} & 15 & \verb~214~ & \verb~                    }~\\
\cellcolor{green} & 15 & \verb~215~ & \verb~                }~\\
\cellcolor{green} & 15 & \verb~216~ & \verb~            }~\\
\cellcolor{green} & 5 & \verb~217~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~218~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~219~ & \verb~~\\
\cellcolor{gray} &  & \verb~220~ & \verb~    [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~221~ & \verb~    static class ZipHelper~\\
\cellcolor{gray} &  & \verb~222~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~223~ & \verb~        public static string ReadContent (this ZipEntry entry)~\\
\cellcolor{gray} &  & \verb~224~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~225~ & \verb~            MemoryStream memory = new MemoryStream ();~\\
\cellcolor{gray} &  & \verb~226~ & \verb~            entry.Extract (memory);~\\
\cellcolor{gray} &  & \verb~227~ & \verb~            memory.Position = 0;~\\
\cellcolor{gray} &  & \verb~228~ & \verb~            var sr = new StreamReader (memory);~\\
\cellcolor{gray} &  & \verb~229~ & \verb~            return sr.ReadToEnd ();~\\
\cellcolor{gray} &  & \verb~230~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~231~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~232~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.ChallengeMetaData}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.ChallengeMetaData\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{s\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash ChallengeMetaData.cs}\end{minipage} \\
\textbf{Coverage:} & 89\%\\
\textbf{Covered lines:} & 73\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 82\\
\textbf{Total lines:} & 211\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 6 & 100 & 63.64\\
\hline
\textbf{AddToHighscore(...)} & 2 & 100 & 66.67\\
\hline
\textbf{formatTime(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{op\_Equality(...)} & 4 & 66.67 & 57.14\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{s\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash ChallengeMetaData.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// Enthält Metadaten zu einer Challenge.~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    public class ChallengeMetaData~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// Der Name der Challenge.~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        public string Name~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~51~ & \verb~            get {~\\
\cellcolor{green} & 1 & \verb~52~ & \verb~                return name;~\\
\cellcolor{green} & 1 & \verb~53~ & \verb~            }~\\
\cellcolor{green} & 5 & \verb~54~ & \verb~            set {~\\
\cellcolor{green} & 5 & \verb~55~ & \verb~                name = value;~\\
\cellcolor{green} & 10 & \verb~56~ & \verb~                if (Format == null) {~\\
\cellcolor{green} & 5 & \verb~57~ & \verb~                    Format = new ChallengeFileIO ();~\\
\cellcolor{green} & 5 & \verb~58~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~59~ & \verb~                string extension;~\\
\cellcolor{green} & 10 & \verb~60~ & \verb~                if (Format.FileExtensions.Any ()) {~\\
\cellcolor{green} & 5 & \verb~61~ & \verb~                    extension = Format.FileExtensions.ElementAt (0);~\\
\cellcolor{green} & 5 & \verb~62~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~                else {~\\
\cellcolor{red} & 0 & \verb~64~ & \verb~                    throw new ArgumentException ("Every implementation of ICha~\\
\cellcolor{gray} &  & \verb~65~ & \verb~                }~\\
\cellcolor{green} & 5 & \verb~66~ & \verb~                Filename = SystemInfo.SavegameDirectory + SystemInfo.PathSepar~\\
\cellcolor{green} & 5 & \verb~67~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        private string name;~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// Der Ausgangsknoten, den der Spieler in den Referenzknoten transfor~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~75~ & \verb~        public KnotMetaData Start { get; private set; }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// Der Referenzknoten, in den der Spieler den Ausgangsknoten transfor~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~80~ & \verb~        public KnotMetaData Target { get; private set; }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// Das Format, aus dem die Metadaten der Challenge gelesen wurden ode~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        /// </summary>~\\
\cellcolor{green} & 26 & \verb~85~ & \verb~        public IChallengeIO Format { get; private set; }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        /// Der Dateiname, aus dem die Metadaten der Challenge gelesen wurden ~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        /// </summary>~\\
\cellcolor{green} & 11 & \verb~90~ & \verb~        public string Filename { get; private set; }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        /// Ein öffentlicher Enumerator, der die Bestenliste unabhängig von de~\\
\cellcolor{gray} &  & \verb~94~ & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~95~ & \verb~        public IEnumerable<KeyValuePair<string, int>> Highscore { get { return~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        private List<KeyValuePair<string, int>> highscore;~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        public float AvgTime~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~101~ & \verb~            get {~\\
\cellcolor{green} & 2 & \verb~102~ & \verb~                if (   highscore != null~\\
\cellcolor{green} & 2 & \verb~103~ & \verb~                        && highscore.Any ()) {~\\
\cellcolor{green} & 2 & \verb~104~ & \verb~                    float amount =0;~\\
\cellcolor{green} & 24 & \verb~105~ & \verb~                    foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{green} & 6 & \verb~106~ & \verb~                        amount += (float)entry.Value;~\\
\cellcolor{green} & 6 & \verb~107~ & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~108~ & \verb~                    return amount/((float)highscore.Count);~\\
\cellcolor{gray} &  & \verb~109~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~                return 0f;~\\
\cellcolor{green} & 2 & \verb~111~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~112~ & \verb~~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~            private set {}~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        public string FormatedAvgTime~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~118~ & \verb~            get {~\\
\cellcolor{green} & 1 & \verb~119~ & \verb~                float time = AvgTime;~\\
\cellcolor{green} & 1 & \verb~120~ & \verb~                Log.Debug (time);~\\
\cellcolor{green} & 2 & \verb~121~ & \verb~                if (time != 0f) {~\\
\cellcolor{green} & 1 & \verb~122~ & \verb~                    return formatTime (time);~\\
\cellcolor{gray} &  & \verb~123~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~                return "Not yet set.";~\\
\cellcolor{green} & 1 & \verb~125~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~            private set {~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~131~ & \verb~        /// Erstellt ein Challenge-Metadaten-Objekt mit einem gegebenen Namen ~\\
\cellcolor{gray} &  & \verb~132~ & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~133~ & \verb~        public ChallengeMetaData (string name, KnotMetaData start, KnotMetaDat~\\
\cellcolor{gray} &  & \verb~134~ & \verb~                                  string filename, IChallengeIO format,~\\
\cellcolor{gray} &  & \verb~135~ & \verb~                                  IEnumerable<KeyValuePair<string, int>> highs~\\
\cellcolor{green} & 5 & \verb~136~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~137~ & \verb~            Name = name;~\\
\cellcolor{green} & 5 & \verb~138~ & \verb~            Start = start;~\\
\cellcolor{green} & 5 & \verb~139~ & \verb~            Target = target;~\\
\cellcolor{green} & 5 & \verb~140~ & \verb~            Format = format ?? Format;~\\
\cellcolor{green} & 5 & \verb~141~ & \verb~            Filename = filename ?? Filename;~\\
\cellcolor{gray} &  & \verb~142~ & \verb~~\\
\cellcolor{green} & 5 & \verb~143~ & \verb~            this.highscore = new List<KeyValuePair<string, int>> ();~\\
\cellcolor{green} & 10 & \verb~144~ & \verb~            if (highscore != null) {~\\
\cellcolor{green} & 60 & \verb~145~ & \verb~                foreach (KeyValuePair<string, int> entry in highscore) {~\\
\cellcolor{green} & 15 & \verb~146~ & \verb~                    this.highscore.Add (entry);~\\
\cellcolor{green} & 15 & \verb~147~ & \verb~                }~\\
\cellcolor{green} & 5 & \verb~148~ & \verb~            }~\\
\cellcolor{green} & 5 & \verb~149~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~152~ & \verb~        /// Fügt eine neue Bestzeit eines bestimmten Spielers in die Bestenlis~\\
\cellcolor{gray} &  & \verb~153~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~154~ & \verb~        public void AddToHighscore (string name, int time)~\\
\cellcolor{green} & 1 & \verb~155~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~156~ & \verb~            KeyValuePair<string, int> entry = new KeyValuePair<string, int> (n~\\
\cellcolor{green} & 2 & \verb~157~ & \verb~            if (!highscore.Contains (entry)) {~\\
\cellcolor{green} & 1 & \verb~158~ & \verb~                highscore.Add (entry);~\\
\cellcolor{green} & 1 & \verb~159~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~160~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~161~ & \verb~~\\
\cellcolor{gray} &  & \verb~162~ & \verb~        public static string formatTime (float secs)~\\
\cellcolor{green} & 2 & \verb~163~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~164~ & \verb~            Log.Debug (secs);~\\
\cellcolor{green} & 2 & \verb~165~ & \verb~            TimeSpan t = TimeSpan.FromSeconds ( secs );~\\
\cellcolor{gray} &  & \verb~166~ & \verb~~\\
\cellcolor{green} & 2 & \verb~167~ & \verb~            string answer = string.Format ("{0:D2}h:{1:D2}m:{2:D2}s",~\\
\cellcolor{gray} &  & \verb~168~ & \verb~                                           t.Hours,~\\
\cellcolor{gray} &  & \verb~169~ & \verb~                                           t.Minutes,~\\
\cellcolor{gray} &  & \verb~170~ & \verb~                                           t.Seconds);~\\
\cellcolor{green} & 2 & \verb~171~ & \verb~            return answer;~\\
\cellcolor{green} & 2 & \verb~172~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~173~ & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & \verb~        public bool Equals (ChallengeMetaData other)~\\
\cellcolor{green} & 1 & \verb~175~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~176~ & \verb~            return other != null && name == other.name;~\\
\cellcolor{green} & 1 & \verb~177~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~178~ & \verb~~\\
\cellcolor{gray} &  & \verb~179~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 1 & \verb~180~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~181~ & \verb~            return other != null && Equals (other as ChallengeMetaData);~\\
\cellcolor{green} & 1 & \verb~182~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~183~ & \verb~~\\
\cellcolor{gray} &  & \verb~184~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~185~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~186~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~187~ & \verb~            return (name ?? String.Empty).GetHashCode ();~\\
\cellcolor{gray} &  & \verb~188~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~189~ & \verb~~\\
\cellcolor{gray} &  & \verb~190~ & \verb~        public static bool operator == (ChallengeMetaData a, ChallengeMetaData~\\
\cellcolor{green} & 4 & \verb~191~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~192~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 4 & \verb~193~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~195~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 8 & \verb~198~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 4 & \verb~199~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~200~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~201~ & \verb~~\\
\cellcolor{gray} &  & \verb~202~ & \verb~            // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~203~ & \verb~            return a.Equals (b);~\\
\cellcolor{green} & 4 & \verb~204~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~        public static bool operator != (ChallengeMetaData a, ChallengeMetaData~\\
\cellcolor{green} & 4 & \verb~207~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~208~ & \verb~            return !(a == b);~\\
\cellcolor{green} & 4 & \verb~209~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~210~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.CircleEntry`1}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.CircleEntry`1\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash CircleEntry.cs}\end{minipage} \\
\textbf{Coverage:} & 92.3\%\\
\textbf{Covered lines:} & 205\\
\textbf{Uncovered lines:} & 17\\
\textbf{Coverable lines:} & 222\\
\textbf{Total lines:} & 384\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor()} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 4 & 100 & 85.71\\
\hline
\textbf{InsertBefore(...)} & 1 & 100 & 100\\
\hline
\textbf{InsertAfter(...)} & 1 & 100 & 100\\
\hline
\textbf{Remove()} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Find(...)} & 1 & 100 & 100\\
\hline
\textbf{IndexOf(...)} & 1 & 100 & 100\\
\hline
\textbf{IndexOf(...)} & 3 & 92.31 & 80\\
\hline
\textbf{System.Collections.I} & 1 & 0 & 0\\
\hline
\textbf{op\_Addition(...)} & 3 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Increment(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Decrement(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Remove(...)} & 2 & 100 & 100\\
\hline
\textbf{RemoveAt(...)} & 1 & 100 & 100\\
\hline
\textbf{Insert(...)} & 1 & 0 & 0\\
\hline
\textbf{Add(...)} & 2 & 100 & 100\\
\hline
\textbf{Clear()} & 1 & 100 & 100\\
\hline
\textbf{CopyTo(...)} & 3 & 100 & 80\\
\hline
\textbf{MoveNext()} & 6 & 100 & 87.5\\
\hline
\textbf{MoveNext()} & 6 & 100 & 87.5\\
\hline
\textbf{MoveNext()} & 6 & 81.82 & 75\\
\hline
\textbf{MoveNext()} & 5 & 0 & 0\\
\hline
\textbf{MoveNext()} & 5 & 100 & 83.33\\
\hline
\textbf{MoveNext()} & 5 & 100 & 83.33\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash CircleEntry.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// Eine doppelt verkettete Liste.~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    public class CircleEntry<T> : IEnumerable<T>, ICollection<T>, IList<T>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        public T Value { get; set; }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public CircleEntry<T> Next { get; set; }~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        public CircleEntry<T> Previous { get; set; }~\\
\cellcolor{gray} &  & \verb~49~ & \verb~~\\
\cellcolor{green} & 1283 & \verb~50~ & \verb~        public CircleEntry (T value)~\\
\cellcolor{green} & 1283 & \verb~51~ & \verb~        {~\\
\cellcolor{green} & 1283 & \verb~52~ & \verb~            Value = value;~\\
\cellcolor{green} & 1283 & \verb~53~ & \verb~            Previous = this;~\\
\cellcolor{green} & 1283 & \verb~54~ & \verb~            Next = this;~\\
\cellcolor{green} & 1283 & \verb~55~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{green} & 7 & \verb~57~ & \verb~        private CircleEntry ()~\\
\cellcolor{green} & 7 & \verb~58~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~59~ & \verb~            Previous = this;~\\
\cellcolor{green} & 7 & \verb~60~ & \verb~            Next = this;~\\
\cellcolor{green} & 7 & \verb~61~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{green} & 61 & \verb~63~ & \verb~        public CircleEntry (IEnumerable<T> list)~\\
\cellcolor{green} & 61 & \verb~64~ & \verb~        {~\\
\cellcolor{green} & 61 & \verb~65~ & \verb~            bool first = true;~\\
\cellcolor{green} & 61 & \verb~66~ & \verb~            CircleEntry<T> inserted = this;~\\
\cellcolor{green} & 4068 & \verb~67~ & \verb~            foreach (T obj in list) {~\\
\cellcolor{green} & 1356 & \verb~68~ & \verb~                if (first) {~\\
\cellcolor{green} & 61 & \verb~69~ & \verb~                    Value = obj;~\\
\cellcolor{green} & 61 & \verb~70~ & \verb~                    Previous = this;~\\
\cellcolor{green} & 61 & \verb~71~ & \verb~                    Next = this;~\\
\cellcolor{green} & 61 & \verb~72~ & \verb~                }~\\
\cellcolor{green} & 1234 & \verb~73~ & \verb~                else {~\\
\cellcolor{green} & 1234 & \verb~74~ & \verb~                    inserted = inserted.InsertAfter (obj);~\\
\cellcolor{green} & 1234 & \verb~75~ & \verb~                }~\\
\cellcolor{green} & 1295 & \verb~76~ & \verb~                first = false;~\\
\cellcolor{green} & 1295 & \verb~77~ & \verb~            }~\\
\cellcolor{green} & 61 & \verb~78~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        public static CircleEntry<T> Empty~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~82~ & \verb~            get {~\\
\cellcolor{green} & 7 & \verb~83~ & \verb~                return new CircleEntry<T> ();~\\
\cellcolor{green} & 7 & \verb~84~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        public CircleEntry<T> InsertBefore (T obj)~\\
\cellcolor{green} & 47 & \verb~88~ & \verb~        {~\\
\cellcolor{green} & 47 & \verb~89~ & \verb~            CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{green} & 47 & \verb~90~ & \verb~            insert.Previous = this.Previous;~\\
\cellcolor{green} & 47 & \verb~91~ & \verb~            insert.Next = this;~\\
\cellcolor{green} & 47 & \verb~92~ & \verb~            this.Previous.Next = insert;~\\
\cellcolor{green} & 47 & \verb~93~ & \verb~            this.Previous = insert;~\\
\cellcolor{green} & 47 & \verb~94~ & \verb~            return insert;~\\
\cellcolor{green} & 47 & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        public CircleEntry<T> InsertAfter (T obj)~\\
\cellcolor{green} & 1236 & \verb~98~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~99~ & \verb~            //Log.Debug (this, ".InsertAfter (", obj, ")");~\\
\cellcolor{green} & 1236 & \verb~100~ & \verb~            CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{green} & 1236 & \verb~101~ & \verb~            insert.Next = this.Next;~\\
\cellcolor{green} & 1236 & \verb~102~ & \verb~            insert.Previous = this;~\\
\cellcolor{green} & 1236 & \verb~103~ & \verb~            this.Next.Previous = insert;~\\
\cellcolor{green} & 1236 & \verb~104~ & \verb~            this.Next = insert;~\\
\cellcolor{green} & 1236 & \verb~105~ & \verb~            return insert;~\\
\cellcolor{green} & 1236 & \verb~106~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        public void Remove ()~\\
\cellcolor{green} & 115 & \verb~109~ & \verb~        {~\\
\cellcolor{green} & 115 & \verb~110~ & \verb~            Previous.Next = Next;~\\
\cellcolor{green} & 115 & \verb~111~ & \verb~            Next.Previous = Previous;~\\
\cellcolor{green} & 115 & \verb~112~ & \verb~            Previous = null;~\\
\cellcolor{green} & 115 & \verb~113~ & \verb~            Next = null;~\\
\cellcolor{green} & 115 & \verb~114~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        private bool IsEmpty~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        {~\\
\cellcolor{green} & 31 & \verb~118~ & \verb~            get {~\\
\cellcolor{green} & 31 & \verb~119~ & \verb~                return (Next == this || Next == null) && (Previous == this || ~\\
\cellcolor{green} & 31 & \verb~120~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        public int Count~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        {~\\
\cellcolor{green} & 29 & \verb~125~ & \verb~            get {~\\
\cellcolor{green} & 29 & \verb~126~ & \verb~                if (IsEmpty) {~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~                    return 0;~\\
\cellcolor{gray} &  & \verb~128~ & \verb~                }~\\
\cellcolor{green} & 29 & \verb~129~ & \verb~                else {~\\
\cellcolor{green} & 29 & \verb~130~ & \verb~                    CircleEntry<T> current = this;~\\
\cellcolor{green} & 29 & \verb~131~ & \verb~                    int count = 0;~\\
\cellcolor{green} & 252 & \verb~132~ & \verb~                    do {~\\
\cellcolor{green} & 252 & \verb~133~ & \verb~                        ++count;~\\
\cellcolor{green} & 252 & \verb~134~ & \verb~                        current = current.Next;~\\
\cellcolor{green} & 252 & \verb~135~ & \verb~                    }~\\
\cellcolor{green} & 252 & \verb~136~ & \verb~                    while (current != this);~\\
\cellcolor{green} & 29 & \verb~137~ & \verb~                    return count;~\\
\cellcolor{gray} &  & \verb~138~ & \verb~                }~\\
\cellcolor{green} & 29 & \verb~139~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~140~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~~\\
\cellcolor{gray} &  & \verb~142~ & \verb~        public bool Contains (T obj, out IEnumerable<CircleEntry<T>> item)~\\
\cellcolor{green} & 199 & \verb~143~ & \verb~        {~\\
\cellcolor{green} & 199 & \verb~144~ & \verb~            item = Find (obj);~\\
\cellcolor{green} & 199 & \verb~145~ & \verb~            return item.Count () > 0;~\\
\cellcolor{green} & 199 & \verb~146~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~147~ & \verb~~\\
\cellcolor{gray} &  & \verb~148~ & \verb~        public bool Contains (Func<T, bool> func, out IEnumerable<CircleEntry<~\\
\cellcolor{green} & 199 & \verb~149~ & \verb~        {~\\
\cellcolor{green} & 199 & \verb~150~ & \verb~            item = Find (func);~\\
\cellcolor{green} & 199 & \verb~151~ & \verb~            return item.Count () > 0;~\\
\cellcolor{green} & 199 & \verb~152~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~        public bool Contains (T obj, out CircleEntry<T> item)~\\
\cellcolor{green} & 301 & \verb~155~ & \verb~        {~\\
\cellcolor{green} & 301 & \verb~156~ & \verb~            item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{green} & 301 & \verb~157~ & \verb~            return item != null;~\\
\cellcolor{green} & 301 & \verb~158~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        public bool Contains (Func<T, bool> func, out CircleEntry<T> item)~\\
\cellcolor{green} & 100 & \verb~161~ & \verb~        {~\\
\cellcolor{green} & 100 & \verb~162~ & \verb~            item = Find (func).ElementAtOrDefault (0);~\\
\cellcolor{green} & 100 & \verb~163~ & \verb~            return item != null;~\\
\cellcolor{green} & 100 & \verb~164~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        public IEnumerable<CircleEntry<T>> Find (T obj)~\\
\cellcolor{green} & 707 & \verb~167~ & \verb~        {~\\
\cellcolor{green} & 27279 & \verb~168~ & \verb~            return Find ((t) => t.Equals (obj));~\\
\cellcolor{green} & 707 & \verb~169~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~        public IEnumerable<CircleEntry<T>> Find (Func<T, bool> func)~\\
\cellcolor{green} & 1909 & \verb~172~ & \verb~        {~\\
\cellcolor{green} & 1909 & \verb~173~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{green} & 52516 & \verb~174~ & \verb~            do {~\\
\cellcolor{green} & 53929 & \verb~175~ & \verb~                if (func (current.Value)) {~\\
\cellcolor{green} & 1413 & \verb~176~ & \verb~                    yield return current;~\\
\cellcolor{green} & 600 & \verb~177~ & \verb~                }~\\
\cellcolor{green} & 51703 & \verb~178~ & \verb~                current = current.Next;~\\
\cellcolor{green} & 51703 & \verb~179~ & \verb~            }~\\
\cellcolor{green} & 51703 & \verb~180~ & \verb~            while (current != this);~\\
\cellcolor{green} & 1096 & \verb~181~ & \verb~            yield break;~\\
\cellcolor{gray} &  & \verb~182~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~183~ & \verb~~\\
\cellcolor{gray} &  & \verb~184~ & \verb~        public int IndexOf (T obj)~\\
\cellcolor{green} & 100 & \verb~185~ & \verb~        {~\\
\cellcolor{green} & 5150 & \verb~186~ & \verb~            return IndexOf ((t) => t.Equals (obj));~\\
\cellcolor{green} & 100 & \verb~187~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~188~ & \verb~~\\
\cellcolor{gray} &  & \verb~189~ & \verb~        public int IndexOf (Func<T, bool> func)~\\
\cellcolor{green} & 200 & \verb~190~ & \verb~        {~\\
\cellcolor{green} & 200 & \verb~191~ & \verb~            int i = 0;~\\
\cellcolor{green} & 200 & \verb~192~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{green} & 10100 & \verb~193~ & \verb~            do {~\\
\cellcolor{green} & 10300 & \verb~194~ & \verb~                if (func (current.Value)) {~\\
\cellcolor{green} & 200 & \verb~195~ & \verb~                    return i;~\\
\cellcolor{gray} &  & \verb~196~ & \verb~                }~\\
\cellcolor{green} & 9900 & \verb~197~ & \verb~                current = current.Next;~\\
\cellcolor{green} & 9900 & \verb~198~ & \verb~                ++ i;~\\
\cellcolor{green} & 9900 & \verb~199~ & \verb~            }~\\
\cellcolor{green} & 9900 & \verb~200~ & \verb~            while (current != this);~\\
\cellcolor{red} & 0 & \verb~201~ & \verb~            return -1;~\\
\cellcolor{green} & 200 & \verb~202~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~203~ & \verb~~\\
\cellcolor{gray} &  & \verb~204~ & \verb~        public IEnumerable<T> RangeTo (CircleEntry<T> other)~\\
\cellcolor{green} & 4 & \verb~205~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~206~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{green} & 16 & \verb~207~ & \verb~            do {~\\
\cellcolor{green} & 16 & \verb~208~ & \verb~                yield return current.Value;~\\
\cellcolor{green} & 16 & \verb~209~ & \verb~                current = current.Next;~\\
\cellcolor{green} & 16 & \verb~210~ & \verb~            }~\\
\cellcolor{green} & 16 & \verb~211~ & \verb~            while (current != other.Next && current != this);~\\
\cellcolor{green} & 4 & \verb~212~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~213~ & \verb~~\\
\cellcolor{gray} &  & \verb~214~ & \verb~        public IEnumerable<T> WayTo (T other)~\\
\cellcolor{green} & 1 & \verb~215~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~216~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{green} & 3 & \verb~217~ & \verb~            while (!current.Value.Equals (other)) {~\\
\cellcolor{green} & 1 & \verb~218~ & \verb~                yield return current.Value;~\\
\cellcolor{green} & 1 & \verb~219~ & \verb~                current = current.Next;~\\
\cellcolor{green} & 1 & \verb~220~ & \verb~                if (current == this) {~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~222~ & \verb~                }~\\
\cellcolor{green} & 1 & \verb~223~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~224~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & \verb~~\\
\cellcolor{gray} &  & \verb~226~ & \verb~        public IEnumerable<Tuple<T,T>> Pairs~\\
\cellcolor{gray} &  & \verb~227~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~228~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~229~ & \verb~                CircleEntry<T> current = this;~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~                do {~\\
\cellcolor{red} & 0 & \verb~231~ & \verb~                    yield return Tuple.Create (current.Value, current.Next.Val~\\
\cellcolor{red} & 0 & \verb~232~ & \verb~                    current = current.Next;~\\
\cellcolor{red} & 0 & \verb~233~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~234~ & \verb~                while (current != this);~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~236~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~237~ & \verb~~\\
\cellcolor{gray} &  & \verb~238~ & \verb~        public IEnumerable<Tuple<T,T,T>> Triples~\\
\cellcolor{gray} &  & \verb~239~ & \verb~        {~\\
\cellcolor{green} & 12 & \verb~240~ & \verb~            get {~\\
\cellcolor{green} & 12 & \verb~241~ & \verb~                CircleEntry<T> current = this;~\\
\cellcolor{green} & 52 & \verb~242~ & \verb~                do {~\\
\cellcolor{green} & 52 & \verb~243~ & \verb~                    yield return Tuple.Create (current.Previous.Value, current~\\
\cellcolor{green} & 50 & \verb~244~ & \verb~                    current = current.Next;~\\
\cellcolor{green} & 50 & \verb~245~ & \verb~                }~\\
\cellcolor{green} & 50 & \verb~246~ & \verb~                while (current != this);~\\
\cellcolor{green} & 10 & \verb~247~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~248~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~249~ & \verb~~\\
\cellcolor{gray} &  & \verb~250~ & \verb~        public IEnumerator<T> GetEnumerator ()~\\
\cellcolor{green} & 109 & \verb~251~ & \verb~        {~\\
\cellcolor{green} & 109 & \verb~252~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{green} & 1064 & \verb~253~ & \verb~            do {~\\
\cellcolor{gray} &  & \verb~254~ & \verb~                //Log.Debug (this, " => ", current.Content);~\\
\cellcolor{green} & 1064 & \verb~255~ & \verb~                yield return current.Value;~\\
\cellcolor{green} & 1056 & \verb~256~ & \verb~                current = current.Next;~\\
\cellcolor{green} & 1056 & \verb~257~ & \verb~            }~\\
\cellcolor{green} & 1056 & \verb~258~ & \verb~            while (current != this);~\\
\cellcolor{green} & 101 & \verb~259~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~260~ & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & \verb~        // explicit interface implementation for nongeneric interface~\\
\cellcolor{gray} &  & \verb~262~ & \verb~        IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{red} & 0 & \verb~263~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~264~ & \verb~            return GetEnumerator (); // just return the generic version~\\
\cellcolor{red} & 0 & \verb~265~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~266~ & \verb~~\\
\cellcolor{gray} &  & \verb~267~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~268~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~269~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~270~ & \verb~            if (IsEmpty) {~\\
\cellcolor{gray} &  & \verb~271~ & \verb~                return "CircleEntry (" + Value.ToString () + ")";~\\
\cellcolor{gray} &  & \verb~272~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~273~ & \verb~            else {~\\
\cellcolor{gray} &  & \verb~274~ & \verb~                return "CircleEntry.Empty";~\\
\cellcolor{gray} &  & \verb~275~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~276~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~277~ & \verb~~\\
\cellcolor{gray} &  & \verb~278~ & \verb~        public static CircleEntry<T> operator + (CircleEntry<T> circle, int i)~\\
\cellcolor{green} & 579 & \verb~279~ & \verb~        {~\\
\cellcolor{green} & 579 & \verb~280~ & \verb~            CircleEntry<T> next = circle;~\\
\cellcolor{green} & 40549 & \verb~281~ & \verb~            while (i > 0) {~\\
\cellcolor{green} & 19985 & \verb~282~ & \verb~                next = next.Next;~\\
\cellcolor{green} & 19985 & \verb~283~ & \verb~                i--;~\\
\cellcolor{green} & 19985 & \verb~284~ & \verb~            }~\\
\cellcolor{green} & 989 & \verb~285~ & \verb~            while (i < 0) {~\\
\cellcolor{green} & 205 & \verb~286~ & \verb~                next = next.Previous;~\\
\cellcolor{green} & 205 & \verb~287~ & \verb~                i++;~\\
\cellcolor{green} & 205 & \verb~288~ & \verb~            }~\\
\cellcolor{green} & 579 & \verb~289~ & \verb~            return next;~\\
\cellcolor{green} & 579 & \verb~290~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~291~ & \verb~~\\
\cellcolor{gray} &  & \verb~292~ & \verb~        public T this [int index]~\\
\cellcolor{gray} &  & \verb~293~ & \verb~        {~\\
\cellcolor{green} & 238 & \verb~294~ & \verb~            get {~\\
\cellcolor{green} & 238 & \verb~295~ & \verb~                return (this + index).Value;~\\
\cellcolor{green} & 238 & \verb~296~ & \verb~            }~\\
\cellcolor{green} & 100 & \verb~297~ & \verb~            set {~\\
\cellcolor{green} & 100 & \verb~298~ & \verb~                (this + index).Value = value;~\\
\cellcolor{green} & 100 & \verb~299~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~300~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~301~ & \verb~~\\
\cellcolor{gray} &  & \verb~302~ & \verb~        public static CircleEntry<T> operator - (CircleEntry<T> circle, int i)~\\
\cellcolor{green} & 30 & \verb~303~ & \verb~        {~\\
\cellcolor{green} & 30 & \verb~304~ & \verb~            return circle + (-i);~\\
\cellcolor{green} & 30 & \verb~305~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~306~ & \verb~~\\
\cellcolor{gray} &  & \verb~307~ & \verb~        public static CircleEntry<T> operator ++ (CircleEntry<T> circle)~\\
\cellcolor{green} & 207 & \verb~308~ & \verb~        {~\\
\cellcolor{green} & 207 & \verb~309~ & \verb~            return circle.Next;~\\
\cellcolor{green} & 207 & \verb~310~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~311~ & \verb~~\\
\cellcolor{gray} &  & \verb~312~ & \verb~        public static CircleEntry<T> operator -- (CircleEntry<T> circle)~\\
\cellcolor{green} & 11 & \verb~313~ & \verb~        {~\\
\cellcolor{green} & 11 & \verb~314~ & \verb~            return circle.Previous;~\\
\cellcolor{green} & 11 & \verb~315~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~316~ & \verb~~\\
\cellcolor{gray} &  & \verb~317~ & \verb~        public static implicit operator T (CircleEntry<T> circle)~\\
\cellcolor{green} & 700 & \verb~318~ & \verb~        {~\\
\cellcolor{green} & 700 & \verb~319~ & \verb~            return circle.Value;~\\
\cellcolor{green} & 700 & \verb~320~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~321~ & \verb~~\\
\cellcolor{green} & 3 & \verb~322~ & \verb~        public bool IsReadOnly { get { return false; } }~\\
\cellcolor{gray} &  & \verb~323~ & \verb~~\\
\cellcolor{gray} &  & \verb~324~ & \verb~        public bool Contains (T obj)~\\
\cellcolor{green} & 102 & \verb~325~ & \verb~        {~\\
\cellcolor{green} & 102 & \verb~326~ & \verb~            CircleEntry<T> item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{green} & 102 & \verb~327~ & \verb~            return item != null;~\\
\cellcolor{green} & 102 & \verb~328~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~329~ & \verb~~\\
\cellcolor{gray} &  & \verb~330~ & \verb~        public bool Remove (T value)~\\
\cellcolor{green} & 198 & \verb~331~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~332~ & \verb~            CircleEntry<T> item;~\\
\cellcolor{green} & 297 & \verb~333~ & \verb~            if (Contains (value, out item)) {~\\
\cellcolor{green} & 99 & \verb~334~ & \verb~                item.Remove ();~\\
\cellcolor{green} & 99 & \verb~335~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~336~ & \verb~            }~\\
\cellcolor{green} & 99 & \verb~337~ & \verb~            else {~\\
\cellcolor{green} & 99 & \verb~338~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~339~ & \verb~            }~\\
\cellcolor{green} & 198 & \verb~340~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~341~ & \verb~~\\
\cellcolor{gray} &  & \verb~342~ & \verb~        public void RemoveAt (int i)~\\
\cellcolor{green} & 1 & \verb~343~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~344~ & \verb~            (this + i).Remove ();~\\
\cellcolor{green} & 1 & \verb~345~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~346~ & \verb~~\\
\cellcolor{gray} &  & \verb~347~ & \verb~        public void Insert (int i, T value)~\\
\cellcolor{red} & 0 & \verb~348~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~349~ & \verb~            (this + i).InsertBefore (value);~\\
\cellcolor{red} & 0 & \verb~350~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~351~ & \verb~~\\
\cellcolor{gray} &  & \verb~352~ & \verb~        public void Add (T value)~\\
\cellcolor{green} & 50 & \verb~353~ & \verb~        {~\\
\cellcolor{green} & 56 & \verb~354~ & \verb~            if (Value == null) {~\\
\cellcolor{green} & 6 & \verb~355~ & \verb~                Value = value;~\\
\cellcolor{green} & 6 & \verb~356~ & \verb~            }~\\
\cellcolor{green} & 44 & \verb~357~ & \verb~            else {~\\
\cellcolor{green} & 44 & \verb~358~ & \verb~                InsertBefore (value);~\\
\cellcolor{green} & 44 & \verb~359~ & \verb~            }~\\
\cellcolor{green} & 50 & \verb~360~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~361~ & \verb~~\\
\cellcolor{gray} &  & \verb~362~ & \verb~        public void Clear ()~\\
\cellcolor{green} & 1 & \verb~363~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~364~ & \verb~            Remove ();~\\
\cellcolor{green} & 1 & \verb~365~ & \verb~            Next = Previous = this;~\\
\cellcolor{green} & 1 & \verb~366~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~367~ & \verb~~\\
\cellcolor{gray} &  & \verb~368~ & \verb~        public void CopyTo (T[] array, int start)~\\
\cellcolor{green} & 1 & \verb~369~ & \verb~        {~\\
\cellcolor{green} & 303 & \verb~370~ & \verb~            foreach (T value in this) {~\\
\cellcolor{green} & 100 & \verb~371~ & \verb~                array.SetValue (value, start);~\\
\cellcolor{green} & 100 & \verb~372~ & \verb~                ++start;~\\
\cellcolor{green} & 100 & \verb~373~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~374~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~375~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~376~ & \verb~~\\
\cellcolor{gray} &  & \verb~377~ & \verb~    public static class CircleExtensions~\\
\cellcolor{gray} &  & \verb~378~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~379~ & \verb~        public static CircleEntry<T> ToCircle<T> (this IEnumerable<T> enumerab~\\
\cellcolor{gray} &  & \verb~380~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~381~ & \verb~            return new CircleEntry<T> (enumerable);~\\
\cellcolor{gray} &  & \verb~382~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~383~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~384~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.CircleExtensions}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.CircleExtensions\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash CircleEntry.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 384\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ToCircle(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash CircleEntry.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// Eine doppelt verkettete Liste.~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    public class CircleEntry<T> : IEnumerable<T>, ICollection<T>, IList<T>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        public T Value { get; set; }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public CircleEntry<T> Next { get; set; }~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        public CircleEntry<T> Previous { get; set; }~\\
\cellcolor{gray} &  & \verb~49~ & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        public CircleEntry (T value)~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~52~ & \verb~            Value = value;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~            Previous = this;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~            Next = this;~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        private CircleEntry ()~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~            Previous = this;~\\
\cellcolor{gray} &  & \verb~60~ & \verb~            Next = this;~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        public CircleEntry (IEnumerable<T> list)~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~65~ & \verb~            bool first = true;~\\
\cellcolor{gray} &  & \verb~66~ & \verb~            CircleEntry<T> inserted = this;~\\
\cellcolor{gray} &  & \verb~67~ & \verb~            foreach (T obj in list) {~\\
\cellcolor{gray} &  & \verb~68~ & \verb~                if (first) {~\\
\cellcolor{gray} &  & \verb~69~ & \verb~                    Value = obj;~\\
\cellcolor{gray} &  & \verb~70~ & \verb~                    Previous = this;~\\
\cellcolor{gray} &  & \verb~71~ & \verb~                    Next = this;~\\
\cellcolor{gray} &  & \verb~72~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~74~ & \verb~                    inserted = inserted.InsertAfter (obj);~\\
\cellcolor{gray} &  & \verb~75~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~                first = false;~\\
\cellcolor{gray} &  & \verb~77~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        public static CircleEntry<T> Empty~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~83~ & \verb~                return new CircleEntry<T> ();~\\
\cellcolor{gray} &  & \verb~84~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        public CircleEntry<T> InsertBefore (T obj)~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~89~ & \verb~            CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{gray} &  & \verb~90~ & \verb~            insert.Previous = this.Previous;~\\
\cellcolor{gray} &  & \verb~91~ & \verb~            insert.Next = this;~\\
\cellcolor{gray} &  & \verb~92~ & \verb~            this.Previous.Next = insert;~\\
\cellcolor{gray} &  & \verb~93~ & \verb~            this.Previous = insert;~\\
\cellcolor{gray} &  & \verb~94~ & \verb~            return insert;~\\
\cellcolor{gray} &  & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        public CircleEntry<T> InsertAfter (T obj)~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~99~ & \verb~            //Log.Debug (this, ".InsertAfter (", obj, ")");~\\
\cellcolor{gray} &  & \verb~100~ & \verb~            CircleEntry<T> insert = new CircleEntry<T> (obj);~\\
\cellcolor{gray} &  & \verb~101~ & \verb~            insert.Next = this.Next;~\\
\cellcolor{gray} &  & \verb~102~ & \verb~            insert.Previous = this;~\\
\cellcolor{gray} &  & \verb~103~ & \verb~            this.Next.Previous = insert;~\\
\cellcolor{gray} &  & \verb~104~ & \verb~            this.Next = insert;~\\
\cellcolor{gray} &  & \verb~105~ & \verb~            return insert;~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        public void Remove ()~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~110~ & \verb~            Previous.Next = Next;~\\
\cellcolor{gray} &  & \verb~111~ & \verb~            Next.Previous = Previous;~\\
\cellcolor{gray} &  & \verb~112~ & \verb~            Previous = null;~\\
\cellcolor{gray} &  & \verb~113~ & \verb~            Next = null;~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        private bool IsEmpty~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~118~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~119~ & \verb~                return (Next == this || Next == null) && (Previous == this || ~\\
\cellcolor{gray} &  & \verb~120~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        public int Count~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~125~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~126~ & \verb~                if (IsEmpty) {~\\
\cellcolor{gray} &  & \verb~127~ & \verb~                    return 0;~\\
\cellcolor{gray} &  & \verb~128~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~130~ & \verb~                    CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~131~ & \verb~                    int count = 0;~\\
\cellcolor{gray} &  & \verb~132~ & \verb~                    do {~\\
\cellcolor{gray} &  & \verb~133~ & \verb~                        ++count;~\\
\cellcolor{gray} &  & \verb~134~ & \verb~                        current = current.Next;~\\
\cellcolor{gray} &  & \verb~135~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~136~ & \verb~                    while (current != this);~\\
\cellcolor{gray} &  & \verb~137~ & \verb~                    return count;~\\
\cellcolor{gray} &  & \verb~138~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~140~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~~\\
\cellcolor{gray} &  & \verb~142~ & \verb~        public bool Contains (T obj, out IEnumerable<CircleEntry<T>> item)~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~144~ & \verb~            item = Find (obj);~\\
\cellcolor{gray} &  & \verb~145~ & \verb~            return item.Count () > 0;~\\
\cellcolor{gray} &  & \verb~146~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~147~ & \verb~~\\
\cellcolor{gray} &  & \verb~148~ & \verb~        public bool Contains (Func<T, bool> func, out IEnumerable<CircleEntry<~\\
\cellcolor{gray} &  & \verb~149~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~150~ & \verb~            item = Find (func);~\\
\cellcolor{gray} &  & \verb~151~ & \verb~            return item.Count () > 0;~\\
\cellcolor{gray} &  & \verb~152~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~        public bool Contains (T obj, out CircleEntry<T> item)~\\
\cellcolor{gray} &  & \verb~155~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~156~ & \verb~            item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{gray} &  & \verb~157~ & \verb~            return item != null;~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        public bool Contains (Func<T, bool> func, out CircleEntry<T> item)~\\
\cellcolor{gray} &  & \verb~161~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~162~ & \verb~            item = Find (func).ElementAtOrDefault (0);~\\
\cellcolor{gray} &  & \verb~163~ & \verb~            return item != null;~\\
\cellcolor{gray} &  & \verb~164~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        public IEnumerable<CircleEntry<T>> Find (T obj)~\\
\cellcolor{gray} &  & \verb~167~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~168~ & \verb~            return Find ((t) => t.Equals (obj));~\\
\cellcolor{gray} &  & \verb~169~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~        public IEnumerable<CircleEntry<T>> Find (Func<T, bool> func)~\\
\cellcolor{gray} &  & \verb~172~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~173~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~174~ & \verb~            do {~\\
\cellcolor{gray} &  & \verb~175~ & \verb~                if (func (current.Value)) {~\\
\cellcolor{gray} &  & \verb~176~ & \verb~                    yield return current;~\\
\cellcolor{gray} &  & \verb~177~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~178~ & \verb~                current = current.Next;~\\
\cellcolor{gray} &  & \verb~179~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~            while (current != this);~\\
\cellcolor{gray} &  & \verb~181~ & \verb~            yield break;~\\
\cellcolor{gray} &  & \verb~182~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~183~ & \verb~~\\
\cellcolor{gray} &  & \verb~184~ & \verb~        public int IndexOf (T obj)~\\
\cellcolor{gray} &  & \verb~185~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~186~ & \verb~            return IndexOf ((t) => t.Equals (obj));~\\
\cellcolor{gray} &  & \verb~187~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~188~ & \verb~~\\
\cellcolor{gray} &  & \verb~189~ & \verb~        public int IndexOf (Func<T, bool> func)~\\
\cellcolor{gray} &  & \verb~190~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~191~ & \verb~            int i = 0;~\\
\cellcolor{gray} &  & \verb~192~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~193~ & \verb~            do {~\\
\cellcolor{gray} &  & \verb~194~ & \verb~                if (func (current.Value)) {~\\
\cellcolor{gray} &  & \verb~195~ & \verb~                    return i;~\\
\cellcolor{gray} &  & \verb~196~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~                current = current.Next;~\\
\cellcolor{gray} &  & \verb~198~ & \verb~                ++ i;~\\
\cellcolor{gray} &  & \verb~199~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~200~ & \verb~            while (current != this);~\\
\cellcolor{gray} &  & \verb~201~ & \verb~            return -1;~\\
\cellcolor{gray} &  & \verb~202~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~203~ & \verb~~\\
\cellcolor{gray} &  & \verb~204~ & \verb~        public IEnumerable<T> RangeTo (CircleEntry<T> other)~\\
\cellcolor{gray} &  & \verb~205~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~206~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~207~ & \verb~            do {~\\
\cellcolor{gray} &  & \verb~208~ & \verb~                yield return current.Value;~\\
\cellcolor{gray} &  & \verb~209~ & \verb~                current = current.Next;~\\
\cellcolor{gray} &  & \verb~210~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~            while (current != other.Next && current != this);~\\
\cellcolor{gray} &  & \verb~212~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~213~ & \verb~~\\
\cellcolor{gray} &  & \verb~214~ & \verb~        public IEnumerable<T> WayTo (T other)~\\
\cellcolor{gray} &  & \verb~215~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~216~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~217~ & \verb~            while (!current.Value.Equals (other)) {~\\
\cellcolor{gray} &  & \verb~218~ & \verb~                yield return current.Value;~\\
\cellcolor{gray} &  & \verb~219~ & \verb~                current = current.Next;~\\
\cellcolor{gray} &  & \verb~220~ & \verb~                if (current == this) {~\\
\cellcolor{gray} &  & \verb~221~ & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~222~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~223~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~224~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & \verb~~\\
\cellcolor{gray} &  & \verb~226~ & \verb~        public IEnumerable<Tuple<T,T>> Pairs~\\
\cellcolor{gray} &  & \verb~227~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~228~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~229~ & \verb~                CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~230~ & \verb~                do {~\\
\cellcolor{gray} &  & \verb~231~ & \verb~                    yield return Tuple.Create (current.Value, current.Next.Val~\\
\cellcolor{gray} &  & \verb~232~ & \verb~                    current = current.Next;~\\
\cellcolor{gray} &  & \verb~233~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~234~ & \verb~                while (current != this);~\\
\cellcolor{gray} &  & \verb~235~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~236~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~237~ & \verb~~\\
\cellcolor{gray} &  & \verb~238~ & \verb~        public IEnumerable<Tuple<T,T,T>> Triples~\\
\cellcolor{gray} &  & \verb~239~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~240~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~241~ & \verb~                CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~242~ & \verb~                do {~\\
\cellcolor{gray} &  & \verb~243~ & \verb~                    yield return Tuple.Create (current.Previous.Value, current~\\
\cellcolor{gray} &  & \verb~244~ & \verb~                    current = current.Next;~\\
\cellcolor{gray} &  & \verb~245~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~246~ & \verb~                while (current != this);~\\
\cellcolor{gray} &  & \verb~247~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~248~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~249~ & \verb~~\\
\cellcolor{gray} &  & \verb~250~ & \verb~        public IEnumerator<T> GetEnumerator ()~\\
\cellcolor{gray} &  & \verb~251~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~252~ & \verb~            CircleEntry<T> current = this;~\\
\cellcolor{gray} &  & \verb~253~ & \verb~            do {~\\
\cellcolor{gray} &  & \verb~254~ & \verb~                //Log.Debug (this, " => ", current.Content);~\\
\cellcolor{gray} &  & \verb~255~ & \verb~                yield return current.Value;~\\
\cellcolor{gray} &  & \verb~256~ & \verb~                current = current.Next;~\\
\cellcolor{gray} &  & \verb~257~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~258~ & \verb~            while (current != this);~\\
\cellcolor{gray} &  & \verb~259~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~260~ & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & \verb~        // explicit interface implementation for nongeneric interface~\\
\cellcolor{gray} &  & \verb~262~ & \verb~        IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{gray} &  & \verb~263~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~264~ & \verb~            return GetEnumerator (); // just return the generic version~\\
\cellcolor{gray} &  & \verb~265~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~266~ & \verb~~\\
\cellcolor{gray} &  & \verb~267~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~268~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~269~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~270~ & \verb~            if (IsEmpty) {~\\
\cellcolor{gray} &  & \verb~271~ & \verb~                return "CircleEntry (" + Value.ToString () + ")";~\\
\cellcolor{gray} &  & \verb~272~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~273~ & \verb~            else {~\\
\cellcolor{gray} &  & \verb~274~ & \verb~                return "CircleEntry.Empty";~\\
\cellcolor{gray} &  & \verb~275~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~276~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~277~ & \verb~~\\
\cellcolor{gray} &  & \verb~278~ & \verb~        public static CircleEntry<T> operator + (CircleEntry<T> circle, int i)~\\
\cellcolor{gray} &  & \verb~279~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~280~ & \verb~            CircleEntry<T> next = circle;~\\
\cellcolor{gray} &  & \verb~281~ & \verb~            while (i > 0) {~\\
\cellcolor{gray} &  & \verb~282~ & \verb~                next = next.Next;~\\
\cellcolor{gray} &  & \verb~283~ & \verb~                i--;~\\
\cellcolor{gray} &  & \verb~284~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~285~ & \verb~            while (i < 0) {~\\
\cellcolor{gray} &  & \verb~286~ & \verb~                next = next.Previous;~\\
\cellcolor{gray} &  & \verb~287~ & \verb~                i++;~\\
\cellcolor{gray} &  & \verb~288~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~289~ & \verb~            return next;~\\
\cellcolor{gray} &  & \verb~290~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~291~ & \verb~~\\
\cellcolor{gray} &  & \verb~292~ & \verb~        public T this [int index]~\\
\cellcolor{gray} &  & \verb~293~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~294~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~295~ & \verb~                return (this + index).Value;~\\
\cellcolor{gray} &  & \verb~296~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~297~ & \verb~            set {~\\
\cellcolor{gray} &  & \verb~298~ & \verb~                (this + index).Value = value;~\\
\cellcolor{gray} &  & \verb~299~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~300~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~301~ & \verb~~\\
\cellcolor{gray} &  & \verb~302~ & \verb~        public static CircleEntry<T> operator - (CircleEntry<T> circle, int i)~\\
\cellcolor{gray} &  & \verb~303~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~304~ & \verb~            return circle + (-i);~\\
\cellcolor{gray} &  & \verb~305~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~306~ & \verb~~\\
\cellcolor{gray} &  & \verb~307~ & \verb~        public static CircleEntry<T> operator ++ (CircleEntry<T> circle)~\\
\cellcolor{gray} &  & \verb~308~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~309~ & \verb~            return circle.Next;~\\
\cellcolor{gray} &  & \verb~310~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~311~ & \verb~~\\
\cellcolor{gray} &  & \verb~312~ & \verb~        public static CircleEntry<T> operator -- (CircleEntry<T> circle)~\\
\cellcolor{gray} &  & \verb~313~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~314~ & \verb~            return circle.Previous;~\\
\cellcolor{gray} &  & \verb~315~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~316~ & \verb~~\\
\cellcolor{gray} &  & \verb~317~ & \verb~        public static implicit operator T (CircleEntry<T> circle)~\\
\cellcolor{gray} &  & \verb~318~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~319~ & \verb~            return circle.Value;~\\
\cellcolor{gray} &  & \verb~320~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~321~ & \verb~~\\
\cellcolor{gray} &  & \verb~322~ & \verb~        public bool IsReadOnly { get { return false; } }~\\
\cellcolor{gray} &  & \verb~323~ & \verb~~\\
\cellcolor{gray} &  & \verb~324~ & \verb~        public bool Contains (T obj)~\\
\cellcolor{gray} &  & \verb~325~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~326~ & \verb~            CircleEntry<T> item = Find (obj).ElementAtOrDefault (0);~\\
\cellcolor{gray} &  & \verb~327~ & \verb~            return item != null;~\\
\cellcolor{gray} &  & \verb~328~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~329~ & \verb~~\\
\cellcolor{gray} &  & \verb~330~ & \verb~        public bool Remove (T value)~\\
\cellcolor{gray} &  & \verb~331~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~332~ & \verb~            CircleEntry<T> item;~\\
\cellcolor{gray} &  & \verb~333~ & \verb~            if (Contains (value, out item)) {~\\
\cellcolor{gray} &  & \verb~334~ & \verb~                item.Remove ();~\\
\cellcolor{gray} &  & \verb~335~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~336~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~337~ & \verb~            else {~\\
\cellcolor{gray} &  & \verb~338~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~339~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~340~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~341~ & \verb~~\\
\cellcolor{gray} &  & \verb~342~ & \verb~        public void RemoveAt (int i)~\\
\cellcolor{gray} &  & \verb~343~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~344~ & \verb~            (this + i).Remove ();~\\
\cellcolor{gray} &  & \verb~345~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~346~ & \verb~~\\
\cellcolor{gray} &  & \verb~347~ & \verb~        public void Insert (int i, T value)~\\
\cellcolor{gray} &  & \verb~348~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~349~ & \verb~            (this + i).InsertBefore (value);~\\
\cellcolor{gray} &  & \verb~350~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~351~ & \verb~~\\
\cellcolor{gray} &  & \verb~352~ & \verb~        public void Add (T value)~\\
\cellcolor{gray} &  & \verb~353~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~354~ & \verb~            if (Value == null) {~\\
\cellcolor{gray} &  & \verb~355~ & \verb~                Value = value;~\\
\cellcolor{gray} &  & \verb~356~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~357~ & \verb~            else {~\\
\cellcolor{gray} &  & \verb~358~ & \verb~                InsertBefore (value);~\\
\cellcolor{gray} &  & \verb~359~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~360~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~361~ & \verb~~\\
\cellcolor{gray} &  & \verb~362~ & \verb~        public void Clear ()~\\
\cellcolor{gray} &  & \verb~363~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~364~ & \verb~            Remove ();~\\
\cellcolor{gray} &  & \verb~365~ & \verb~            Next = Previous = this;~\\
\cellcolor{gray} &  & \verb~366~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~367~ & \verb~~\\
\cellcolor{gray} &  & \verb~368~ & \verb~        public void CopyTo (T[] array, int start)~\\
\cellcolor{gray} &  & \verb~369~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~370~ & \verb~            foreach (T value in this) {~\\
\cellcolor{gray} &  & \verb~371~ & \verb~                array.SetValue (value, start);~\\
\cellcolor{gray} &  & \verb~372~ & \verb~                ++start;~\\
\cellcolor{gray} &  & \verb~373~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~374~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~375~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~376~ & \verb~~\\
\cellcolor{gray} &  & \verb~377~ & \verb~    public static class CircleExtensions~\\
\cellcolor{gray} &  & \verb~378~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~379~ & \verb~        public static CircleEntry<T> ToCircle<T> (this IEnumerable<T> enumerab~\\
\cellcolor{green} & 1 & \verb~380~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~381~ & \verb~            return new CircleEntry<T> (enumerable);~\\
\cellcolor{green} & 1 & \verb~382~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~383~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~384~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.Direction}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.Direction\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Direction.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 58\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 58\\
\textbf{Total lines:} & 186\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{FromAxis(...)} & 5 & 100 & 85.71\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Division(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 100 & 85.71\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 4 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Direction.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// Eine Wertesammlung der möglichen Richtungen in einem dreidimensionalen~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// Wird benutzt, damit keine ungültigen Kantenrichtungen angegeben werden~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    /// Dies ist eine Klasse und kein Enum, kann aber~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// uneingeschränkt wie eines benutzt werden (Typesafe Enum Pattern).~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    public sealed class Direction : TypesafeEnum<Direction>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// Links.~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~52~ & \verb~        public static readonly Direction Left = new Direction (Vector3.Left, "~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// Rechts.~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~56~ & \verb~        public static readonly Direction Right = new Direction (Vector3.Right,~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// Hoch.~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~60~ & \verb~        public static readonly Direction Up = new Direction (Vector3.Up, "Up")~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// Runter.~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~64~ & \verb~        public static readonly Direction Down = new Direction (Vector3.Down, "~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// Vorwärts.~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~68~ & \verb~        public static readonly Direction Forward = new Direction (Vector3.Forw~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// Rückwärts.~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~72~ & \verb~        public static readonly Direction Backward = new Direction (Vector3.Bac~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// Keine Richtung.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~76~ & \verb~        public static readonly Direction Zero = new Direction (Vector3.Zero, "~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        /// Gibt alle Richtungswerte zurück.~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~81~ & \verb~        public new static readonly Direction[] Values = {~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            Left, Right, Up, Down, Forward,  Backward~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        };~\\
\cellcolor{green} & 1 & \verb~84~ & \verb~        private static readonly Dictionary<Direction, Direction> ReverseMap~\\
\cellcolor{gray} &  & \verb~85~ & \verb~            = new Dictionary<Direction, Direction> ()~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~87~ & \verb~            { Left, Right }, { Right, Left },~\\
\cellcolor{gray} &  & \verb~88~ & \verb~            { Up, Down }, { Down, Up },~\\
\cellcolor{gray} &  & \verb~89~ & \verb~            { Forward, Backward }, { Backward, Forward },~\\
\cellcolor{gray} &  & \verb~90~ & \verb~            { Zero, Zero }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        };~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{green} & 1 & \verb~93~ & \verb~        private static readonly Dictionary<Direction, Axis> AxisMap~\\
\cellcolor{gray} &  & \verb~94~ & \verb~            = new Dictionary<Direction, Axis> ()~\\
\cellcolor{gray} &  & \verb~95~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~96~ & \verb~            { Left, Axis.X }, { Right, Axis.X },~\\
\cellcolor{gray} &  & \verb~97~ & \verb~            { Up, Axis.Y }, { Down, Axis.Y },~\\
\cellcolor{gray} &  & \verb~98~ & \verb~            { Forward, Axis.Z }, { Backward, Axis.Z },~\\
\cellcolor{gray} &  & \verb~99~ & \verb~            { Zero, Axis.Zero }~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        };~\\
\cellcolor{gray} &  & \verb~101~ & \verb~~\\
\cellcolor{green} & 1755 & \verb~102~ & \verb~        public Vector3 Vector { get; private set; }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{green} & 183 & \verb~104~ & \verb~        public Direction Reverse { get { return ReverseMap [this]; } }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{green} & 33 & \verb~106~ & \verb~        public Axis Axis { get { return AxisMap [this]; } }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{green} & 7 & \verb~108~ & \verb~        private Direction (Vector3 vector, string description)~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        : base (description)~\\
\cellcolor{green} & 7 & \verb~110~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~111~ & \verb~            Vector = vector;~\\
\cellcolor{green} & 7 & \verb~112~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        public static Direction FromAxis (Axis axis)~\\
\cellcolor{green} & 3 & \verb~115~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~116~ & \verb~            return axis == Axis.X ? Right : axis == Axis.Y ? Up : axis == Axis~\\
\cellcolor{green} & 3 & \verb~117~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~118~ & \verb~~\\
\cellcolor{gray} &  & \verb~119~ & \verb~        public static Vector3 operator + (Vector3 v, Direction d)~\\
\cellcolor{green} & 535 & \verb~120~ & \verb~        {~\\
\cellcolor{green} & 535 & \verb~121~ & \verb~            return v + d.Vector;~\\
\cellcolor{green} & 535 & \verb~122~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        public static Vector3 operator - (Vector3 v, Direction d)~\\
\cellcolor{green} & 1 & \verb~125~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~126~ & \verb~            return v - d.Vector;~\\
\cellcolor{green} & 1 & \verb~127~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~~\\
\cellcolor{gray} &  & \verb~129~ & \verb~        public static Vector3 operator / (Direction d, float i)~\\
\cellcolor{green} & 1034 & \verb~130~ & \verb~        {~\\
\cellcolor{green} & 1034 & \verb~131~ & \verb~            return d.Vector / i;~\\
\cellcolor{green} & 1034 & \verb~132~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~133~ & \verb~~\\
\cellcolor{gray} &  & \verb~134~ & \verb~        public static Vector3 operator * (Direction d, float i)~\\
\cellcolor{green} & 1 & \verb~135~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~136~ & \verb~            return d.Vector * i;~\\
\cellcolor{green} & 1 & \verb~137~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~~\\
\cellcolor{gray} &  & \verb~139~ & \verb~        public static bool operator == (Direction a, Direction b)~\\
\cellcolor{green} & 125 & \verb~140~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~141~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 183 & \verb~142~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 58 & \verb~143~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~144~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 69 & \verb~147~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 2 & \verb~148~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~149~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~            // Return true if the fields match:~\\
\cellcolor{green} & 65 & \verb~152~ & \verb~            return a.Vector == b.Vector;~\\
\cellcolor{green} & 125 & \verb~153~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & \verb~        public static bool operator != (Direction d1, Direction d2)~\\
\cellcolor{green} & 40 & \verb~156~ & \verb~        {~\\
\cellcolor{green} & 40 & \verb~157~ & \verb~            return !(d1 == d2);~\\
\cellcolor{green} & 40 & \verb~158~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        public bool Equals (Direction other)~\\
\cellcolor{green} & 2 & \verb~161~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~162~ & \verb~            return other != null && Vector == other.Vector;~\\
\cellcolor{green} & 2 & \verb~163~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 7 & \verb~166~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~167~ & \verb~            if (other == null) {~\\
\cellcolor{green} & 1 & \verb~168~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~169~ & \verb~            }~\\
\cellcolor{green} & 7 & \verb~170~ & \verb~            else if (other is Direction) {~\\
\cellcolor{green} & 1 & \verb~171~ & \verb~                return Equals (other as Direction);~\\
\cellcolor{gray} &  & \verb~172~ & \verb~            }~\\
\cellcolor{green} & 6 & \verb~173~ & \verb~            else if (other is Vector3) {~\\
\cellcolor{green} & 1 & \verb~174~ & \verb~                return Vector.Equals ((Vector3)other);~\\
\cellcolor{gray} &  & \verb~175~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~176~ & \verb~            else {~\\
\cellcolor{green} & 4 & \verb~177~ & \verb~                return base.Equals (other);~\\
\cellcolor{gray} &  & \verb~178~ & \verb~            }~\\
\cellcolor{green} & 7 & \verb~179~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~        public static implicit operator Vector3 (Direction direction)~\\
\cellcolor{green} & 25 & \verb~182~ & \verb~        {~\\
\cellcolor{green} & 25 & \verb~183~ & \verb~            return direction.Vector;~\\
\cellcolor{green} & 25 & \verb~184~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~185~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.Edge}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.Edge\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Edge.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 80\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 80\\
\textbf{Total lines:} & 208\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 100 & 85.71\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 100\\
\hline
\textbf{Equals(...)} & 6 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{RandomColor()} & 1 & 100 & 100\\
\hline
\textbf{RandomColor(...)} & 1 & 100 & 100\\
\hline
\textbf{RandomEdge()} & 6 & 100 & 45.45\\
\hline
\textbf{Clone()} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Edge.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// Eine Kante eines Knotens, die aus einer Richtung und einer Farbe, sowi~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    public sealed class Edge : IEquatable<Edge>, ICloneable~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// Die Farbe der Kante.~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1348 & \verb~47~ & \verb~        public Color Color { get; set; }~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// Die Richtung der Kante.~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// </summary>~\\
\cellcolor{green} & 2674 & \verb~52~ & \verb~        public Direction Direction { get; private set; }~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// Die Liste der Flächennummern, die an die Kante angrenzen.~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1096 & \verb~57~ & \verb~        public HashSet<int> Rectangles { get; private set; }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        private int id;~\\
\cellcolor{green} & 1 & \verb~60~ & \verb~        private static int previousId = 0;~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        /// Erstellt eine neue Kante mit der angegebenen Richtung.~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// </summary>~\\
\cellcolor{green} & 561 & \verb~65~ & \verb~        public Edge (Direction direction)~\\
\cellcolor{green} & 561 & \verb~66~ & \verb~        {~\\
\cellcolor{green} & 561 & \verb~67~ & \verb~            Direction = direction;~\\
\cellcolor{green} & 561 & \verb~68~ & \verb~            Color = DefaultColor;~\\
\cellcolor{green} & 561 & \verb~69~ & \verb~            id = ++previousId;~\\
\cellcolor{green} & 561 & \verb~70~ & \verb~            Rectangles = new HashSet<int> ();~\\
\cellcolor{green} & 561 & \verb~71~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// Erstellt eine neue Kante mit der angegebenen Richtung und Farbe.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// </summary>~\\
\cellcolor{green} & 19 & \verb~76~ & \verb~        public Edge (Direction direction, Color color)~\\
\cellcolor{green} & 19 & \verb~77~ & \verb~        {~\\
\cellcolor{green} & 19 & \verb~78~ & \verb~            Direction = direction;~\\
\cellcolor{green} & 19 & \verb~79~ & \verb~            Color = color;~\\
\cellcolor{green} & 19 & \verb~80~ & \verb~            id = ++previousId;~\\
\cellcolor{green} & 19 & \verb~81~ & \verb~            Rectangles = new HashSet<int>();~\\
\cellcolor{green} & 19 & \verb~82~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        public static bool operator == (Edge a, Edge b)~\\
\cellcolor{green} & 76 & \verb~85~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~86~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 78 & \verb~87~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 2 & \verb~88~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~89~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 145 & \verb~92~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 71 & \verb~93~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~94~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~            // Return true if the fields match:~\\
\cellcolor{green} & 3 & \verb~97~ & \verb~            return a.id == b.id;~\\
\cellcolor{green} & 76 & \verb~98~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        public static bool operator != (Edge a, Edge b)~\\
\cellcolor{green} & 74 & \verb~101~ & \verb~        {~\\
\cellcolor{green} & 74 & \verb~102~ & \verb~            return !(a == b);~\\
\cellcolor{green} & 74 & \verb~103~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~104~ & \verb~~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        public bool Equals (Edge other)~\\
\cellcolor{green} & 72 & \verb~106~ & \verb~        {~\\
\cellcolor{green} & 72 & \verb~107~ & \verb~            return other != null && this.id == other.id;~\\
\cellcolor{green} & 72 & \verb~108~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 37 & \verb~111~ & \verb~        {~\\
\cellcolor{green} & 38 & \verb~112~ & \verb~            if (other == null) {~\\
\cellcolor{green} & 1 & \verb~113~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~114~ & \verb~            }~\\
\cellcolor{green} & 65 & \verb~115~ & \verb~            else if (other is Edge) {~\\
\cellcolor{green} & 29 & \verb~116~ & \verb~                return Equals (other as Edge);~\\
\cellcolor{gray} &  & \verb~117~ & \verb~            }~\\
\cellcolor{green} & 8 & \verb~118~ & \verb~            else if (other is Direction) {~\\
\cellcolor{green} & 1 & \verb~119~ & \verb~                return Direction.Equals (other as Direction);~\\
\cellcolor{gray} &  & \verb~120~ & \verb~            }~\\
\cellcolor{green} & 7 & \verb~121~ & \verb~            else if (other is Vector3) {~\\
\cellcolor{green} & 1 & \verb~122~ & \verb~                return Direction.Vector.Equals ((Vector3)other);~\\
\cellcolor{gray} &  & \verb~123~ & \verb~            }~\\
\cellcolor{green} & 6 & \verb~124~ & \verb~            else if (other is Color) {~\\
\cellcolor{green} & 1 & \verb~125~ & \verb~                return Color.Equals ((Color)other);~\\
\cellcolor{gray} &  & \verb~126~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~127~ & \verb~            else {~\\
\cellcolor{green} & 4 & \verb~128~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~129~ & \verb~            }~\\
\cellcolor{green} & 37 & \verb~130~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{gray} &  & \verb~132~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~133~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~134~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~135~ & \verb~            return id;~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~139~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~140~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~141~ & \verb~            return Direction + "/" + id.ToString ();~\\
\cellcolor{gray} &  & \verb~142~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & \verb~        public static implicit operator Direction (Edge edge)~\\
\cellcolor{green} & 15 & \verb~145~ & \verb~        {~\\
\cellcolor{green} & 15 & \verb~146~ & \verb~            return edge.Direction;~\\
\cellcolor{green} & 15 & \verb~147~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~~\\
\cellcolor{gray} &  & \verb~149~ & \verb~        public static implicit operator Vector3 (Edge edge)~\\
\cellcolor{green} & 7 & \verb~150~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~151~ & \verb~            return edge.Direction;~\\
\cellcolor{green} & 7 & \verb~152~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~        public static implicit operator Color (Edge edge)~\\
\cellcolor{green} & 18 & \verb~155~ & \verb~        {~\\
\cellcolor{green} & 18 & \verb~156~ & \verb~            return edge.Color;~\\
\cellcolor{green} & 18 & \verb~157~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~158~ & \verb~~\\
\cellcolor{green} & 1 & \verb~159~ & \verb~        private static Random r = new Random ();~\\
\cellcolor{gray} &  & \verb~160~ & \verb~~\\
\cellcolor{gray} &  & \verb~161~ & \verb~        public static Color RandomColor ()~\\
\cellcolor{green} & 1 & \verb~162~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~163~ & \verb~            return Colors [r.Next () % Colors.Count];~\\
\cellcolor{green} & 1 & \verb~164~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        public static Color RandomColor (GameTime time)~\\
\cellcolor{green} & 1 & \verb~167~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~168~ & \verb~            return Colors [(int)time.TotalGameTime.TotalSeconds % Colors.Count~\\
\cellcolor{green} & 1 & \verb~169~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~        public static Edge RandomEdge ()~\\
\cellcolor{green} & 1 & \verb~172~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~173~ & \verb~            int i = r.Next () % 6;~\\
\cellcolor{green} & 1 & \verb~174~ & \verb~            return i == 0 ? Left : i == 1 ? Right : i == 2 ? Up : i == 3 ? Dow~\\
\cellcolor{green} & 1 & \verb~175~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~        public object Clone ()~\\
\cellcolor{green} & 1 & \verb~178~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~179~ & \verb~            return new Edge (Direction, Color);~\\
\cellcolor{green} & 1 & \verb~180~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~181~ & \verb~~\\
\cellcolor{green} & 1 & \verb~182~ & \verb~        public static List<Color> Colors = new List<Color> ()~\\
\cellcolor{gray} &  & \verb~183~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~184~ & \verb~            Color.Red, Color.Green, Color.Blue, Color.Yellow, Color.Orange~\\
\cellcolor{gray} &  & \verb~185~ & \verb~        };~\\
\cellcolor{green} & 1 & \verb~186~ & \verb~        public static Color DefaultColor = RandomColor ();~\\
\cellcolor{gray} &  & \verb~187~ & \verb~~\\
\cellcolor{green} & 42 & \verb~188~ & \verb~        public static Edge Zero { get { return new Edge (Direction.Zero); } }~\\
\cellcolor{gray} &  & \verb~189~ & \verb~~\\
\cellcolor{green} & 3 & \verb~190~ & \verb~        public static Edge UnitX { get { return new Edge (Direction.Right); } ~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{green} & 3 & \verb~192~ & \verb~        public static Edge UnitY { get { return new Edge (Direction.Up); } }~\\
\cellcolor{gray} &  & \verb~193~ & \verb~~\\
\cellcolor{green} & 3 & \verb~194~ & \verb~        public static Edge UnitZ { get { return new Edge (Direction.Backward);~\\
\cellcolor{gray} &  & \verb~195~ & \verb~~\\
\cellcolor{green} & 216 & \verb~196~ & \verb~        public static Edge Up { get { return new Edge (Direction.Up); } }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{green} & 204 & \verb~198~ & \verb~        public static Edge Down { get { return new Edge (Direction.Down); } }~\\
\cellcolor{gray} &  & \verb~199~ & \verb~~\\
\cellcolor{green} & 216 & \verb~200~ & \verb~        public static Edge Right { get { return new Edge (Direction.Right); } ~\\
\cellcolor{gray} &  & \verb~201~ & \verb~~\\
\cellcolor{green} & 216 & \verb~202~ & \verb~        public static Edge Left { get { return new Edge (Direction.Left); } }~\\
\cellcolor{gray} &  & \verb~203~ & \verb~~\\
\cellcolor{green} & 33 & \verb~204~ & \verb~        public static Edge Forward { get { return new Edge (Direction.Forward)~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{green} & 36 & \verb~206~ & \verb~        public static Edge Backward { get { return new Edge (Direction.Backwar~\\
\cellcolor{gray} &  & \verb~207~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~208~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.Knot}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.Knot\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Knot.cs}\end{minipage} \\
\textbf{Coverage:} & 84.8\%\\
\textbf{Covered lines:} & 263\\
\textbf{Uncovered lines:} & 47\\
\textbf{Coverable lines:} & 310\\
\textbf{Total lines:} & 614\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 5 & 100 & 55.56\\
\hline
\textbf{.ctor(...)} & 8 & 100 & 86.67\\
\hline
\textbf{.ctor(...)} & 5 & 100 & 88.89\\
\hline
\textbf{IsValidStructure(...} & 6 & 83.33 & 72.73\\
\hline
\textbf{IsValidStructure(...} & 2 & 100 & 100\\
\hline
\textbf{TryMove(...)} & 21 & 87.30 & 87.80\\
\hline
\textbf{MoveCenterToZero()} & 8 & 100 & 86.67\\
\hline
\textbf{Move(...)} & 2 & 100 & 100\\
\hline
\textbf{IsValidDirection(...} & 16 & 81.25 & 77.42\\
\hline
\textbf{onEdgesChanged()} & 1 & 0 & 0\\
\hline
\textbf{GetEnumerator()} & 1 & 100 & 100\\
\hline
\textbf{Save()} & 3 & 0 & 0\\
\hline
\textbf{Clone()} & 2 & 100 & 100\\
\hline
\textbf{OnSelectionChanged()} & 1 & 100 & 100\\
\hline
\textbf{AddToSelection(...)} & 3 & 100 & 60\\
\hline
\textbf{RemoveFromSelection(} & 2 & 100 & 100\\
\hline
\textbf{ClearSelection()} & 1 & 100 & 100\\
\hline
\textbf{AddRangeToSelection(} & 9 & 100 & 88.24\\
\hline
\textbf{IsSelected(...)} & 1 & 0 & 0\\
\hline
\textbf{System.Collections.I} & 1 & 100 & 100\\
\hline
\textbf{Save(...)} & 1 & 0 & 0\\
\hline
\textbf{Equals(...)} & 8 & 51.43 & 46.67\\
\hline
\textbf{Charakteristic()} & 9 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Knot.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~44~ & \verb~{~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    /// Diese Klasse repräsentiert einen Knoten, bestehend aus einem Knoten-Me~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~    public sealed class Knot : ICloneable, IEnumerable<Edge>, IEquatable<Knot>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// Der Name des Knotens, welcher auch leer sein kann.~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// Beim Speichern muss der Nutzer in diesem Fall zwingend einen nicht~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// Der Wert dieser Eigenschaft wird aus der \glqq Name\grqq -Eigensch~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// und bei Änderungen wieder in diesem gespeichert.~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// Beim Ändern dieser Eigenschaft wird automatisch auch der im Metada~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        public string Name~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        {~\\
\cellcolor{green} & 66 & \verb~59~ & \verb~            get { return MetaData.Name; }~\\
\cellcolor{green} & 3 & \verb~60~ & \verb~            set { MetaData.Name = value; }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// Das Startelement der doppelt-verketteten Liste, in der die Kanten ~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        private CircleEntry<Edge> startElement;~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        /// Die Metadaten des Knotens.~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// </summary>~\\
\cellcolor{green} & 92 & \verb~71~ & \verb~        public KnotMetaData MetaData { get; private set; }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// Ein Ereignis, das in der Move-Methode ausgelöst wird, wenn sich di~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// </summary>~\\
\cellcolor{green} & 49 & \verb~76~ & \verb~        public Action EdgesChanged = () => {};~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        /// Enthält die aktuell vom Spieler selektierten Kanten in der Reihenf~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        /// </summary>~\\
\cellcolor{green} & 24 & \verb~81~ & \verb~        public IEnumerable<Edge> SelectedEdges { get { return selectedEdges; }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        /// Enthält die selektierten Kanten.~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        private HashSet<Edge> selectedEdges;~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        /// WTF?!~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        public int debugId;~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~94~ & \verb~        /// Wird aufgerufen, wenn sich die Selektion geändert hat.~\\
\cellcolor{gray} &  & \verb~95~ & \verb~        /// </summary>~\\
\cellcolor{green} & 60 & \verb~96~ & \verb~        public Action SelectionChanged = () => {};~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        /// Enthält die zuletzt selektierte Kante.~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~101~ & \verb~        private CircleEntry<Edge> lastSelected;~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        /// Wird aufgerufen, wenn sich die Startkante geändert hat.~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        /// </summary>~\\
\cellcolor{green} & 49 & \verb~106~ & \verb~        public Action<Vector3> StartEdgeChanged = (v) => {};~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        /// Der Cache für die Knotencharakteristik.~\\
\cellcolor{gray} &  & \verb~110~ & \verb~        /// </summary>~\\
\cellcolor{green} & 49 & \verb~111~ & \verb~        private KnotCharakteristic? CharakteristicCache = null;~\\
\cellcolor{gray} &  & \verb~112~ & \verb~~\\
\cellcolor{green} & 55 & \verb~113~ & \verb~        public Vector3 OffSet { get; private set;}~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        /// Erstellt einen minimalen Standardknoten. Das Metadaten-Objekt enth~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        /// die das Speicherformat und den Dateinamen beinhalten, den Wert \gl~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~119~ & \verb~        public Knot ()~\\
\cellcolor{green} & 1 & \verb~120~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~121~ & \verb~            debugId++;~\\
\cellcolor{green} & 1 & \verb~122~ & \verb~            MetaData = new KnotMetaData (String.Empty, () => startElement.Coun~\\
\cellcolor{green} & 1 & \verb~123~ & \verb~            startElement = new CircleEntry<Edge> (new Edge[] {~\\
\cellcolor{gray} &  & \verb~124~ & \verb~                // Edge.Up, Edge.Right, Edge.Right, Edge.Down, Edge.Backward,~\\
\cellcolor{gray} &  & \verb~125~ & \verb~                // Edge.Up, Edge.Left, Edge.Left, Edge.Down, Edge.Forward~\\
\cellcolor{gray} &  & \verb~126~ & \verb~                Edge.Up, Edge.Right, Edge.Down, Edge.Left~\\
\cellcolor{gray} &  & \verb~127~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~                                                 );~\\
\cellcolor{green} & 1 & \verb~129~ & \verb~            selectedEdges = new HashSet<Edge> ();~\\
\cellcolor{green} & 1 & \verb~130~ & \verb~            OffSet = Vector3.Zero;~\\
\cellcolor{green} & 1 & \verb~131~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~134~ & \verb~        /// Erstellt einen neuen Knoten mit dem angegebenen Metadaten-Objekt u~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        /// die in der doppelt verketteten Liste gespeichert werden.~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        /// Die Eigenschaft des Metadaten-Objektes, die die Anzahl der Kanten ~\\
\cellcolor{gray} &  & \verb~137~ & \verb~        /// wird auf ein Delegate gesetzt, welches jeweils die aktuelle Anzahl~\\
\cellcolor{gray} &  & \verb~138~ & \verb~        /// </summary>~\\
\cellcolor{green} & 45 & \verb~139~ & \verb~        public Knot (KnotMetaData metaData, IEnumerable<Edge> edges)~\\
\cellcolor{green} & 45 & \verb~140~ & \verb~        {~\\
\cellcolor{green} & 45 & \verb~141~ & \verb~            debugId++;~\\
\cellcolor{green} & 45 & \verb~142~ & \verb~            Stack<Direction> structure = new Stack<Direction> ();~\\
\cellcolor{green} & 1425 & \verb~143~ & \verb~            foreach (Edge edge in edges) {~\\
\cellcolor{green} & 430 & \verb~144~ & \verb~                structure.Push (edge.Direction);~\\
\cellcolor{green} & 430 & \verb~145~ & \verb~            }~\\
\cellcolor{green} & 46 & \verb~146~ & \verb~            if (!IsValidStructure (structure)) {~\\
\cellcolor{green} & 1 & \verb~147~ & \verb~                throw new InvalidDataException ();~\\
\cellcolor{gray} &  & \verb~148~ & \verb~            }~\\
\cellcolor{green} & 44 & \verb~149~ & \verb~            MetaData = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~150~ & \verb~                name: metaData.Name,~\\
\cellcolor{green} & 2 & \verb~151~ & \verb~                countEdges: () => this.startElement.Count,~\\
\cellcolor{gray} &  & \verb~152~ & \verb~                format: metaData.Format,~\\
\cellcolor{gray} &  & \verb~153~ & \verb~                filename: metaData.Filename~\\
\cellcolor{gray} &  & \verb~154~ & \verb~            );~\\
\cellcolor{green} & 43 & \verb~155~ & \verb~            this.startElement = new CircleEntry<Edge> (edges);~\\
\cellcolor{green} & 43 & \verb~156~ & \verb~            selectedEdges = new HashSet<Edge> ();~\\
\cellcolor{green} & 43 & \verb~157~ & \verb~            OffSet = Vector3.Zero;~\\
\cellcolor{green} & 43 & \verb~158~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{green} & 3 & \verb~160~ & \verb~        private Knot (KnotMetaData metaData, CircleEntry<Edge> start, HashSet<~\\
\cellcolor{green} & 3 & \verb~161~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~162~ & \verb~            startElement = start;~\\
\cellcolor{green} & 3 & \verb~163~ & \verb~            MetaData = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~164~ & \verb~                name: metaData.Name,~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~                countEdges: () => this.startElement.Count,~\\
\cellcolor{gray} &  & \verb~166~ & \verb~                format: metaData.Format,~\\
\cellcolor{gray} &  & \verb~167~ & \verb~                filename: metaData.Filename~\\
\cellcolor{gray} &  & \verb~168~ & \verb~            );~\\
\cellcolor{green} & 3 & \verb~169~ & \verb~            selectedEdges = selected;~\\
\cellcolor{green} & 3 & \verb~170~ & \verb~            OffSet = offset;~\\
\cellcolor{green} & 3 & \verb~171~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~172~ & \verb~~\\
\cellcolor{gray} &  & \verb~173~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~174~ & \verb~        /// Prüft ob die gegeben Struktur einen gültigen Knoten darstellt.~\\
\cellcolor{gray} &  & \verb~175~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~176~ & \verb~        public bool IsValidStructure (IEnumerable<Direction> knot)~\\
\cellcolor{green} & 48 & \verb~177~ & \verb~        {~\\
\cellcolor{green} & 48 & \verb~178~ & \verb~            Vector3 position3D = Vector3.Zero;~\\
\cellcolor{green} & 48 & \verb~179~ & \verb~            HashSet<Vector3> occupancy = new HashSet<Vector3> ();~\\
\cellcolor{green} & 48 & \verb~180~ & \verb~            if (knot.Count () < 4) {~\\
\cellcolor{red} & 0 & \verb~181~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~182~ & \verb~            }~\\
\cellcolor{green} & 1494 & \verb~183~ & \verb~            foreach (Direction peek in knot) {~\\
\cellcolor{green} & 450 & \verb~184~ & \verb~                if (occupancy.Contains (position3D + (peek / 2))) {~\\
\cellcolor{red} & 0 & \verb~185~ & \verb~                    return false;~\\
\cellcolor{gray} &  & \verb~186~ & \verb~                }~\\
\cellcolor{green} & 450 & \verb~187~ & \verb~                else {~\\
\cellcolor{green} & 450 & \verb~188~ & \verb~                    occupancy.Add (position3D + (peek / 2));~\\
\cellcolor{green} & 450 & \verb~189~ & \verb~                    position3D += peek;~\\
\cellcolor{green} & 450 & \verb~190~ & \verb~                }~\\
\cellcolor{green} & 450 & \verb~191~ & \verb~            }~\\
\cellcolor{green} & 49 & \verb~192~ & \verb~            if (position3D.DistanceTo (Vector3.Zero) > 0.00001f) {~\\
\cellcolor{green} & 1 & \verb~193~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~194~ & \verb~            }~\\
\cellcolor{green} & 47 & \verb~195~ & \verb~            return true;~\\
\cellcolor{green} & 48 & \verb~196~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & \verb~        private bool IsValidStructure (IEnumerable<Edge> edges)~\\
\cellcolor{green} & 3 & \verb~199~ & \verb~        {~\\
\cellcolor{green} & 43 & \verb~200~ & \verb~            return IsValidStructure (from e in edges select e.Direction);~\\
\cellcolor{green} & 3 & \verb~201~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~202~ & \verb~~\\
\cellcolor{gray} &  & \verb~203~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~204~ & \verb~        /// Verschiebt die aktuelle Kantenauswahl in die angegebene Richtung u~\\
\cellcolor{gray} &  & \verb~205~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~206~ & \verb~        public bool TryMove (Direction direction, int distance, out Knot newkn~\\
\cellcolor{green} & 9 & \verb~207~ & \verb~        {~\\
\cellcolor{green} & 12 & \verb~208~ & \verb~            if (direction == Direction.Zero || distance == 0) {~\\
\cellcolor{green} & 3 & \verb~209~ & \verb~                newknot = this;~\\
\cellcolor{green} & 3 & \verb~210~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~211~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~212~ & \verb~~\\
\cellcolor{green} & 6 & \verb~213~ & \verb~            Log.Debug ("TryMove: direction = ", direction, ", distance = ", di~\\
\cellcolor{green} & 38 & \verb~214~ & \verb~            Log.Debug ("Current Knot #", startElement.Count, " = ", string.Joi~\\
\cellcolor{gray} &  & \verb~215~ & \verb~~\\
\cellcolor{green} & 6 & \verb~216~ & \verb~            HashSet<Edge> selected = new HashSet<Edge> (selectedEdges);~\\
\cellcolor{green} & 6 & \verb~217~ & \verb~            CircleEntry<Edge> newCircle = CircleEntry<Edge>.Empty;~\\
\cellcolor{gray} &  & \verb~218~ & \verb~~\\
\cellcolor{green} & 114 & \verb~219~ & \verb~            foreach (Tuple<Edge, Edge, Edge> triple in startElement.Triples) {~\\
\cellcolor{green} & 32 & \verb~220~ & \verb~                Edge previousEdge = triple.Item1;~\\
\cellcolor{green} & 32 & \verb~221~ & \verb~                Edge currentEdge = triple.Item2;~\\
\cellcolor{green} & 32 & \verb~222~ & \verb~                Edge nextEdge = triple.Item3;~\\
\cellcolor{gray} &  & \verb~223~ & \verb~~\\
\cellcolor{green} & 38 & \verb~224~ & \verb~                if (selectedEdges.Contains (currentEdge) && !selectedEdges.Con~\\
\cellcolor{green} & 15 & \verb~225~ & \verb~                    distance.Repeat (i => newCircle.Add (new Edge (direction: ~\\
\cellcolor{green} & 6 & \verb~226~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~227~ & \verb~~\\
\cellcolor{green} & 32 & \verb~228~ & \verb~                newCircle.Add (currentEdge);~\\
\cellcolor{gray} &  & \verb~229~ & \verb~~\\
\cellcolor{green} & 38 & \verb~230~ & \verb~                if (selectedEdges.Contains (currentEdge) && !selectedEdges.Con~\\
\cellcolor{green} & 15 & \verb~231~ & \verb~                    distance.Repeat (i => newCircle.Add (new Edge (direction: ~\\
\cellcolor{green} & 6 & \verb~232~ & \verb~                }~\\
\cellcolor{green} & 32 & \verb~233~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~234~ & \verb~~\\
\cellcolor{green} & 56 & \verb~235~ & \verb~            Log.Debug ("New Knot #", newCircle.Count, " = ", string.Join (", "~\\
\cellcolor{gray} &  & \verb~236~ & \verb~~\\
\cellcolor{green} & 6 & \verb~237~ & \verb~            Vector3 localOffset = OffSet;~\\
\cellcolor{green} & 6 & \verb~238~ & \verb~            CircleEntry<Edge> current = newCircle;~\\
\cellcolor{green} & 45 & \verb~239~ & \verb~            do {~\\
\cellcolor{green} & 55 & \verb~240~ & \verb~                if (current [- 1].Direction == current [- 2].Direction.Reverse~\\
\cellcolor{gray} &  & \verb~241~ & \verb~                    // Selektierte nicht löschen~\\
\cellcolor{green} & 13 & \verb~242~ & \verb~                    if (selected.Contains (current [- 1]) || selected.Contains~\\
\cellcolor{green} & 3 & \verb~243~ & \verb~                        Log.Debug ("Error: Selektierte nicht löschen");~\\
\cellcolor{green} & 3 & \verb~244~ & \verb~                        newknot = null;~\\
\cellcolor{green} & 3 & \verb~245~ & \verb~                        return false;~\\
\cellcolor{gray} &  & \verb~246~ & \verb~                    }~\\
\cellcolor{green} & 7 & \verb~247~ & \verb~                    if (newCircle == current - 1) {~\\
\cellcolor{red} & 0 & \verb~248~ & \verb~                        localOffset += (current - 1).Value;~\\
\cellcolor{red} & 0 & \verb~249~ & \verb~                        newCircle = current;~\\
\cellcolor{red} & 0 & \verb~250~ & \verb~                    }~\\
\cellcolor{green} & 8 & \verb~251~ & \verb~                    else if (newCircle == current - 2) {~\\
\cellcolor{green} & 1 & \verb~252~ & \verb~                        localOffset += (current - 1).Value.Direction + (curren~\\
\cellcolor{green} & 1 & \verb~253~ & \verb~                        newCircle = current;~\\
\cellcolor{green} & 1 & \verb~254~ & \verb~                    }~\\
\cellcolor{green} & 7 & \verb~255~ & \verb~                    (current - 2).Remove ();~\\
\cellcolor{green} & 7 & \verb~256~ & \verb~                    (current - 1).Remove ();~\\
\cellcolor{green} & 7 & \verb~257~ & \verb~                }~\\
\cellcolor{green} & 42 & \verb~258~ & \verb~                ++ current;~\\
\cellcolor{green} & 42 & \verb~259~ & \verb~            }~\\
\cellcolor{green} & 42 & \verb~260~ & \verb~            while (current != newCircle);~\\
\cellcolor{gray} &  & \verb~261~ & \verb~~\\
\cellcolor{green} & 23 & \verb~262~ & \verb~            Log.Debug ("New Knot after Remove #", newCircle.Count, " = ", stri~\\
\cellcolor{gray} &  & \verb~263~ & \verb~~\\
\cellcolor{green} & 3 & \verb~264~ & \verb~            if (!IsValidStructure (newCircle)) {~\\
\cellcolor{red} & 0 & \verb~265~ & \verb~                Log.Debug ("Error: newCircle ist keine valide Struktur");~\\
\cellcolor{red} & 0 & \verb~266~ & \verb~                newknot = null;~\\
\cellcolor{red} & 0 & \verb~267~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~268~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~269~ & \verb~            newknot = new Knot (MetaData, newCircle, selected, localOffset);~\\
\cellcolor{green} & 3 & \verb~270~ & \verb~            return true;~\\
\cellcolor{green} & 9 & \verb~271~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~272~ & \verb~~\\
\cellcolor{gray} &  & \verb~273~ & \verb~        public Vector3 MoveCenterToZero ()~\\
\cellcolor{green} & 1 & \verb~274~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~275~ & \verb~            Vector3 position3D = Vector3.Zero;~\\
\cellcolor{green} & 1 & \verb~276~ & \verb~            Dictionary<Vector3, Edge> occupancy = new Dictionary<Vector3, Edge~\\
\cellcolor{green} & 21 & \verb~277~ & \verb~            foreach (Edge edge in startElement) {~\\
\cellcolor{green} & 6 & \verb~278~ & \verb~                occupancy.Add (position3D + (edge.Direction / 2), edge);~\\
\cellcolor{green} & 6 & \verb~279~ & \verb~                position3D += edge;~\\
\cellcolor{green} & 6 & \verb~280~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~281~ & \verb~            Vector3 mid = Vector3.Zero;~\\
\cellcolor{green} & 21 & \verb~282~ & \verb~            foreach (KeyValuePair<Vector3,Edge> pos in occupancy) {~\\
\cellcolor{green} & 6 & \verb~283~ & \verb~                mid += pos.Key;~\\
\cellcolor{green} & 6 & \verb~284~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~285~ & \verb~            mid /= startElement.Count;~\\
\cellcolor{green} & 1 & \verb~286~ & \verb~            float minDistance = mid.Length ();~\\
\cellcolor{green} & 1 & \verb~287~ & \verb~            Edge newStart = startElement.Value;~\\
\cellcolor{green} & 21 & \verb~288~ & \verb~            foreach (KeyValuePair<Vector3,Edge> pos in occupancy) {~\\
\cellcolor{green} & 6 & \verb~289~ & \verb~                float testDistance = pos.Key.DistanceTo (mid);~\\
\cellcolor{green} & 8 & \verb~290~ & \verb~                if (testDistance < minDistance) {~\\
\cellcolor{green} & 2 & \verb~291~ & \verb~                    newStart = pos.Value;~\\
\cellcolor{green} & 2 & \verb~292~ & \verb~                    minDistance = testDistance;~\\
\cellcolor{green} & 2 & \verb~293~ & \verb~                }~\\
\cellcolor{green} & 6 & \verb~294~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~295~ & \verb~            Vector3 offset = Vector3.Zero;~\\
\cellcolor{green} & 6 & \verb~296~ & \verb~            foreach (Edge edge in startElement.WayTo (newStart)) {~\\
\cellcolor{green} & 1 & \verb~297~ & \verb~                offset += edge;~\\
\cellcolor{green} & 1 & \verb~298~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~299~ & \verb~            startElement.Contains (newStart, out startElement);~\\
\cellcolor{green} & 1 & \verb~300~ & \verb~            offset += OffSet;~\\
\cellcolor{green} & 1 & \verb~301~ & \verb~            OffSet = Vector3.Zero;~\\
\cellcolor{green} & 1 & \verb~302~ & \verb~            return offset;~\\
\cellcolor{green} & 1 & \verb~303~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~304~ & \verb~~\\
\cellcolor{gray} &  & \verb~305~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~306~ & \verb~        /// Verschiebt die aktuelle Kantenauswahl in die angegebene Richtung u~\\
\cellcolor{gray} &  & \verb~307~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~308~ & \verb~        public bool Move (Direction direction, int distance)~\\
\cellcolor{green} & 9 & \verb~309~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~310~ & \verb~            Knot newKnot;~\\
\cellcolor{green} & 15 & \verb~311~ & \verb~            if (TryMove (direction, distance, out newKnot)) {~\\
\cellcolor{green} & 6 & \verb~312~ & \verb~                startElement = newKnot.startElement;~\\
\cellcolor{green} & 6 & \verb~313~ & \verb~                selectedEdges = newKnot.selectedEdges;~\\
\cellcolor{green} & 6 & \verb~314~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~315~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~316~ & \verb~            else {~\\
\cellcolor{green} & 3 & \verb~317~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~318~ & \verb~            }~\\
\cellcolor{green} & 9 & \verb~319~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~320~ & \verb~~\\
\cellcolor{gray} &  & \verb~321~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~322~ & \verb~        /// Gibt an ob ein Move in diese Richtung überhaupt möglich ist.~\\
\cellcolor{gray} &  & \verb~323~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~324~ & \verb~        public bool IsValidDirection (Direction direction)~\\
\cellcolor{green} & 6 & \verb~325~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~326~ & \verb~            // Nichts selektiert~\\
\cellcolor{green} & 6 & \verb~327~ & \verb~            if (selectedEdges.Count == 0) {~\\
\cellcolor{red} & 0 & \verb~328~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~329~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~330~ & \verb~            // Alles selektiert~\\
\cellcolor{green} & 6 & \verb~331~ & \verb~            if (selectedEdges.Count == startElement.Count) {~\\
\cellcolor{red} & 0 & \verb~332~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~333~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~334~ & \verb~~\\
\cellcolor{green} & 6 & \verb~335~ & \verb~            HashSet<Axis> axes = new HashSet<Axis> ();~\\
\cellcolor{green} & 76 & \verb~336~ & \verb~            foreach (Tuple<Edge, Edge, Edge> triple in startElement.Triples) {~\\
\cellcolor{green} & 20 & \verb~337~ & \verb~                Edge previousEdge = triple.Item1;~\\
\cellcolor{green} & 20 & \verb~338~ & \verb~                Edge currentEdge = triple.Item2;~\\
\cellcolor{green} & 20 & \verb~339~ & \verb~                Edge nextEdge = triple.Item3;~\\
\cellcolor{gray} &  & \verb~340~ & \verb~~\\
\cellcolor{gray} &  & \verb~341~ & \verb~                // Wenn Kante nach der Bewegung gelöscht werden müsste ist ein~\\
\cellcolor{green} & 20 & \verb~342~ & \verb~                if (selectedEdges.Contains (currentEdge) && !selectedEdges.Con~\\
\cellcolor{green} & 1 & \verb~343~ & \verb~                        && currentEdge.Direction == direction.Reverse && previ~\\
\cellcolor{green} & 1 & \verb~344~ & \verb~                    return false;~\\
\cellcolor{gray} &  & \verb~345~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~346~ & \verb~                // Wenn Kante nach der Bewegung gelöscht werden müsste ist ein~\\
\cellcolor{green} & 19 & \verb~347~ & \verb~                if (selectedEdges.Contains (currentEdge) && !selectedEdges.Con~\\
\cellcolor{green} & 1 & \verb~348~ & \verb~                        && currentEdge.Direction == direction && nextEdge.Dire~\\
\cellcolor{green} & 1 & \verb~349~ & \verb~                    return false;~\\
\cellcolor{gray} &  & \verb~350~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~351~ & \verb~~\\
\cellcolor{green} & 22 & \verb~352~ & \verb~                if (selectedEdges.Contains (currentEdge)) {~\\
\cellcolor{green} & 4 & \verb~353~ & \verb~                    axes.Add (currentEdge.Direction.Axis);~\\
\cellcolor{green} & 4 & \verb~354~ & \verb~                }~\\
\cellcolor{green} & 18 & \verb~355~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~356~ & \verb~            // Wenn alle Kanten entlang einer Achse angeordnet sind und die Ve~\\
\cellcolor{green} & 4 & \verb~357~ & \verb~            if (axes.Count == 1 && axes.Contains (direction.Axis)) {~\\
\cellcolor{red} & 0 & \verb~358~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~359~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~360~ & \verb~            return true;~\\
\cellcolor{green} & 6 & \verb~361~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~362~ & \verb~~\\
\cellcolor{gray} &  & \verb~363~ & \verb~        private void onEdgesChanged ()~\\
\cellcolor{red} & 0 & \verb~364~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~365~ & \verb~            CharakteristicCache = null;~\\
\cellcolor{red} & 0 & \verb~366~ & \verb~            EdgesChanged ();~\\
\cellcolor{red} & 0 & \verb~367~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~368~ & \verb~~\\
\cellcolor{gray} &  & \verb~369~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~370~ & \verb~        /// Gibt die doppelt-verkettete Kantenliste als Enumerator zurück.~\\
\cellcolor{gray} &  & \verb~371~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~372~ & \verb~        public IEnumerator<Edge> GetEnumerator ()~\\
\cellcolor{green} & 54 & \verb~373~ & \verb~        {~\\
\cellcolor{green} & 54 & \verb~374~ & \verb~            return startElement.GetEnumerator ();~\\
\cellcolor{green} & 54 & \verb~375~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~376~ & \verb~~\\
\cellcolor{gray} &  & \verb~377~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~378~ & \verb~        /// Speichert den Knoten unter dem Dateinamen in dem Dateiformat, das ~\\
\cellcolor{gray} &  & \verb~379~ & \verb~        /// Enthalten entweder die Dateiname-Eigenschaft, die Dateiformat-Eige~\\
\cellcolor{gray} &  & \verb~380~ & \verb~        /// oder beide den Wert \glqq null\grqq, dann wird eine IOException ge~\\
\cellcolor{gray} &  & \verb~381~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~382~ & \verb~        public void Save ()~\\
\cellcolor{red} & 0 & \verb~383~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~384~ & \verb~            if (MetaData.Format == null) {~\\
\cellcolor{red} & 0 & \verb~385~ & \verb~                throw new IOException ("Error: Knot: MetaData.Format is null!"~\\
\cellcolor{gray} &  & \verb~386~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~387~ & \verb~            else if (MetaData.Filename == null) {~\\
\cellcolor{red} & 0 & \verb~388~ & \verb~                throw new IOException ("Error: Knot: MetaData.Filename is null~\\
\cellcolor{gray} &  & \verb~389~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~390~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~391~ & \verb~                MetaData.Format.Save (this);~\\
\cellcolor{red} & 0 & \verb~392~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~393~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~394~ & \verb~~\\
\cellcolor{gray} &  & \verb~395~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~396~ & \verb~        /// Erstellt eine vollständige Kopie des Knotens, inklusive der Kanten~\\
\cellcolor{gray} &  & \verb~397~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~398~ & \verb~        public object Clone ()~\\
\cellcolor{green} & 2 & \verb~399~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~400~ & \verb~            CircleEntry<Edge> newCircle = new CircleEntry<Edge> (startElement ~\\
\cellcolor{green} & 2 & \verb~401~ & \verb~            KnotMetaData metaData = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~402~ & \verb~                name: MetaData.Name,~\\
\cellcolor{red} & 0 & \verb~403~ & \verb~                countEdges: () => 0,~\\
\cellcolor{gray} &  & \verb~404~ & \verb~                format: MetaData.Format,~\\
\cellcolor{gray} &  & \verb~405~ & \verb~                filename: MetaData.Filename~\\
\cellcolor{gray} &  & \verb~406~ & \verb~            );~\\
\cellcolor{green} & 2 & \verb~407~ & \verb~            return new Knot (metaData: metaData, edges: newCircle) {~\\
\cellcolor{gray} &  & \verb~408~ & \verb~                selectedEdges = new HashSet<Edge> (selectedEdges),~\\
\cellcolor{gray} &  & \verb~409~ & \verb~                EdgesChanged = null,~\\
\cellcolor{gray} &  & \verb~410~ & \verb~                SelectionChanged = null,~\\
\cellcolor{gray} &  & \verb~411~ & \verb~            };~\\
\cellcolor{green} & 2 & \verb~412~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~413~ & \verb~~\\
\cellcolor{gray} &  & \verb~414~ & \verb~        private void OnSelectionChanged ()~\\
\cellcolor{green} & 11 & \verb~415~ & \verb~        {~\\
\cellcolor{green} & 11 & \verb~416~ & \verb~            SelectionChanged ();~\\
\cellcolor{green} & 11 & \verb~417~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~418~ & \verb~~\\
\cellcolor{gray} &  & \verb~419~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~420~ & \verb~        /// Fügt die angegebene Kante zur aktuellen Kantenauswahl hinzu.~\\
\cellcolor{gray} &  & \verb~421~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~422~ & \verb~        public void AddToSelection (Edge edge)~\\
\cellcolor{green} & 5 & \verb~423~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~424~ & \verb~            IEnumerable<CircleEntry<Edge>> found = startElement.Find (edge);~\\
\cellcolor{green} & 10 & \verb~425~ & \verb~            if (found.Any ()) {~\\
\cellcolor{green} & 10 & \verb~426~ & \verb~                if (!selectedEdges.Contains (edge)) {~\\
\cellcolor{green} & 5 & \verb~427~ & \verb~                    selectedEdges.Add (edge);~\\
\cellcolor{green} & 5 & \verb~428~ & \verb~                }~\\
\cellcolor{green} & 5 & \verb~429~ & \verb~                lastSelected = found.ElementAt (0);~\\
\cellcolor{green} & 5 & \verb~430~ & \verb~            }~\\
\cellcolor{green} & 5 & \verb~431~ & \verb~            OnSelectionChanged ();~\\
\cellcolor{green} & 5 & \verb~432~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~433~ & \verb~~\\
\cellcolor{gray} &  & \verb~434~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~435~ & \verb~        /// Entfernt die angegebene Kante von der aktuellen Kantenauswahl.~\\
\cellcolor{gray} &  & \verb~436~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~437~ & \verb~        public void RemoveFromSelection (Edge edge)~\\
\cellcolor{green} & 2 & \verb~438~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~439~ & \verb~            selectedEdges.Remove (edge);~\\
\cellcolor{green} & 3 & \verb~440~ & \verb~            if (lastSelected.Value == edge) {~\\
\cellcolor{green} & 1 & \verb~441~ & \verb~                lastSelected = null;~\\
\cellcolor{green} & 1 & \verb~442~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~443~ & \verb~            OnSelectionChanged ();~\\
\cellcolor{green} & 2 & \verb~444~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~445~ & \verb~~\\
\cellcolor{gray} &  & \verb~446~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~447~ & \verb~        /// Hebt die aktuelle Kantenauswahl auf.~\\
\cellcolor{gray} &  & \verb~448~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~449~ & \verb~        public void ClearSelection ()~\\
\cellcolor{green} & 2 & \verb~450~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~451~ & \verb~            selectedEdges.Clear ();~\\
\cellcolor{green} & 2 & \verb~452~ & \verb~            lastSelected = null;~\\
\cellcolor{green} & 2 & \verb~453~ & \verb~            OnSelectionChanged ();~\\
\cellcolor{green} & 2 & \verb~454~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~455~ & \verb~~\\
\cellcolor{gray} &  & \verb~456~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~457~ & \verb~        /// Fügt alle Kanten auf dem kürzesten Weg zwischen der zuletzt ausgew~\\
\cellcolor{gray} &  & \verb~458~ & \verb~        /// zur aktuellen Kantenauswahl hinzu. Sind beide Wege gleich lang,~\\
\cellcolor{gray} &  & \verb~459~ & \verb~        /// wird der Weg in Richtung der ersten Kante ausgewählt.~\\
\cellcolor{gray} &  & \verb~460~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~461~ & \verb~        public void AddRangeToSelection (Edge selectedEdge)~\\
\cellcolor{green} & 3 & \verb~462~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~463~ & \verb~            if (lastSelected == null) {~\\
\cellcolor{green} & 1 & \verb~464~ & \verb~                AddToSelection (selectedEdge);~\\
\cellcolor{green} & 1 & \verb~465~ & \verb~                return;~\\
\cellcolor{gray} &  & \verb~466~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~467~ & \verb~            CircleEntry<Edge> selectedCircle = null;~\\
\cellcolor{green} & 4 & \verb~468~ & \verb~            if (startElement.Contains (selectedEdge, out selectedCircle) && se~\\
\cellcolor{green} & 2 & \verb~469~ & \verb~                List<Edge> forward = new List<Edge> (lastSelected.RangeTo (sel~\\
\cellcolor{green} & 2 & \verb~470~ & \verb~                List<Edge> backward = new List<Edge> (selectedCircle.RangeTo (~\\
\cellcolor{gray} &  & \verb~471~ & \verb~~\\
\cellcolor{green} & 3 & \verb~472~ & \verb~                if (forward.Count < backward.Count) {~\\
\cellcolor{green} & 12 & \verb~473~ & \verb~                    foreach (Edge e in forward) {~\\
\cellcolor{green} & 5 & \verb~474~ & \verb~                        if (!selectedEdges.Contains (e)) {~\\
\cellcolor{green} & 2 & \verb~475~ & \verb~                            selectedEdges.Add (e);~\\
\cellcolor{green} & 2 & \verb~476~ & \verb~                        }~\\
\cellcolor{green} & 3 & \verb~477~ & \verb~                    }~\\
\cellcolor{green} & 1 & \verb~478~ & \verb~                }~\\
\cellcolor{green} & 1 & \verb~479~ & \verb~                else {~\\
\cellcolor{green} & 9 & \verb~480~ & \verb~                    foreach (Edge e in backward) {~\\
\cellcolor{green} & 3 & \verb~481~ & \verb~                        if (!selectedEdges.Contains (e)) {~\\
\cellcolor{green} & 1 & \verb~482~ & \verb~                            selectedEdges.Add (e);~\\
\cellcolor{green} & 1 & \verb~483~ & \verb~                        }~\\
\cellcolor{green} & 2 & \verb~484~ & \verb~                    }~\\
\cellcolor{green} & 1 & \verb~485~ & \verb~                }~\\
\cellcolor{green} & 2 & \verb~486~ & \verb~                lastSelected = selectedCircle;~\\
\cellcolor{green} & 2 & \verb~487~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~488~ & \verb~            OnSelectionChanged ();~\\
\cellcolor{green} & 3 & \verb~489~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~490~ & \verb~~\\
\cellcolor{gray} &  & \verb~491~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~492~ & \verb~        /// Prüft, ob die angegebene Kante in der aktuellen Kantenauswahl enth~\\
\cellcolor{gray} &  & \verb~493~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~494~ & \verb~        public Boolean IsSelected (Edge edge)~\\
\cellcolor{red} & 0 & \verb~495~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~496~ & \verb~            return selectedEdges.Contains (edge);~\\
\cellcolor{red} & 0 & \verb~497~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~498~ & \verb~~\\
\cellcolor{gray} &  & \verb~499~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~500~ & \verb~        /// Gibt die doppelt-verkettete Kantenliste als Enumerator zurück.~\\
\cellcolor{gray} &  & \verb~501~ & \verb~        /// [name=IEnumerable.GetEnumerator]~\\
\cellcolor{gray} &  & \verb~502~ & \verb~        /// [keywords= ]~\\
\cellcolor{gray} &  & \verb~503~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~504~ & \verb~        IEnumerator IEnumerable.GetEnumerator ()~\\
\cellcolor{green} & 2 & \verb~505~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~506~ & \verb~            return GetEnumerator (); // just return the generic version~\\
\cellcolor{green} & 2 & \verb~507~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~508~ & \verb~~\\
\cellcolor{gray} &  & \verb~509~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~510~ & \verb~        /// Speichert den Knoten unter dem angegebenen Dateinamen in dem angeg~\\
\cellcolor{gray} &  & \verb~511~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~512~ & \verb~        public void Save (IKnotIO format, string filename)~\\
\cellcolor{red} & 0 & \verb~513~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~514~ & \verb~            KnotMetaData metaData = new KnotMetaData (MetaData.Name, () => Met~\\
\cellcolor{red} & 0 & \verb~515~ & \verb~            Knot knotToSave = new Knot (metaData, startElement);~\\
\cellcolor{red} & 0 & \verb~516~ & \verb~            format.Save (knotToSave);~\\
\cellcolor{red} & 0 & \verb~517~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~518~ & \verb~~\\
\cellcolor{gray} &  & \verb~519~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~520~ & \verb~        /// Prüft, ob die räumliche Struktur identisch ist, unabhängig von dem~\\
\cellcolor{gray} &  & \verb~521~ & \verb~        /// [parameters=Knot other]~\\
\cellcolor{gray} &  & \verb~522~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~523~ & \verb~        public bool Equals (Knot other)~\\
\cellcolor{green} & 14 & \verb~524~ & \verb~        {~\\
\cellcolor{green} & 14 & \verb~525~ & \verb~            KnotCharakteristic thisCharakteristik = Charakteristic ();~\\
\cellcolor{green} & 14 & \verb~526~ & \verb~            KnotCharakteristic otherCharakteristik = other.Charakteristic ();~\\
\cellcolor{green} & 20 & \verb~527~ & \verb~            if (thisCharakteristik.CountEdges != otherCharakteristik.CountEdge~\\
\cellcolor{green} & 6 & \verb~528~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~529~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~530~ & \verb~            // Bei Struktur im gleicher Richtung~\\
\cellcolor{green} & 16 & \verb~531~ & \verb~            if (thisCharakteristik.CharacteristicalEdge.Value.Direction == oth~\\
\cellcolor{green} & 8 & \verb~532~ & \verb~                CircleEntry<Edge> currentThisElement = thisCharakteristik.Char~\\
\cellcolor{green} & 8 & \verb~533~ & \verb~                CircleEntry<Edge> currentOtherElement = otherCharakteristik.Ch~\\
\cellcolor{green} & 80 & \verb~534~ & \verb~                while (currentThisElement != thisCharakteristik.Characteristic~\\
\cellcolor{green} & 36 & \verb~535~ & \verb~                    if (currentThisElement.Value.Direction != currentOtherElem~\\
\cellcolor{red} & 0 & \verb~536~ & \verb~                        return false;~\\
\cellcolor{gray} &  & \verb~537~ & \verb~                    }~\\
\cellcolor{green} & 36 & \verb~538~ & \verb~                    currentThisElement++;~\\
\cellcolor{green} & 36 & \verb~539~ & \verb~                    currentOtherElement++;~\\
\cellcolor{green} & 36 & \verb~540~ & \verb~                }~\\
\cellcolor{green} & 8 & \verb~541~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~542~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~543~ & \verb~            // Bei Struktur in entgegengesetzter Richtung~\\
\cellcolor{red} & 0 & \verb~544~ & \verb~            else if (thisCharakteristik.CharacteristicalEdge.Value.Direction =~\\
\cellcolor{red} & 0 & \verb~545~ & \verb~                CircleEntry<Edge> currentThisElement = thisCharakteristik.Char~\\
\cellcolor{red} & 0 & \verb~546~ & \verb~                CircleEntry<Edge> currentOtherElement = otherCharakteristik.Ch~\\
\cellcolor{red} & 0 & \verb~547~ & \verb~                while (currentThisElement != thisCharakteristik.Characteristic~\\
\cellcolor{red} & 0 & \verb~548~ & \verb~                    if (currentThisElement.Value.Direction != currentOtherElem~\\
\cellcolor{red} & 0 & \verb~549~ & \verb~                        return false;~\\
\cellcolor{gray} &  & \verb~550~ & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~551~ & \verb~                    currentThisElement++;~\\
\cellcolor{red} & 0 & \verb~552~ & \verb~                    currentOtherElement++;~\\
\cellcolor{red} & 0 & \verb~553~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~554~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~555~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~556~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~557~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~558~ & \verb~            }~\\
\cellcolor{green} & 14 & \verb~559~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~560~ & \verb~~\\
\cellcolor{gray} &  & \verb~561~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~562~ & \verb~        /// Gibt chrakteristische Werte zurück, die bei gleichen Knoten gleich~\\
\cellcolor{gray} &  & \verb~563~ & \verb~        /// Einmal als Key ein eindeutiges Circle\<Edge\> Element und als Valu~\\
\cellcolor{gray} &  & \verb~564~ & \verb~        /// einen Charakteristischen Integer. Momentan die Anzahl der Kanten.~\\
\cellcolor{gray} &  & \verb~565~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~566~ & \verb~        private KnotCharakteristic Charakteristic ()~\\
\cellcolor{green} & 28 & \verb~567~ & \verb~        {~\\
\cellcolor{green} & 41 & \verb~568~ & \verb~            if (CharakteristicCache.HasValue) {~\\
\cellcolor{green} & 13 & \verb~569~ & \verb~                return CharakteristicCache.Value;~\\
\cellcolor{gray} &  & \verb~570~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~571~ & \verb~~\\
\cellcolor{green} & 15 & \verb~572~ & \verb~            CircleEntry<Edge> charakteristikElement = startElement;~\\
\cellcolor{green} & 15 & \verb~573~ & \verb~            Vector3 position3D = startElement.Value.Direction;~\\
\cellcolor{green} & 15 & \verb~574~ & \verb~            Vector3 bestPosition3D = startElement.Value.Direction / 2;~\\
\cellcolor{green} & 15 & \verb~575~ & \verb~            CircleEntry<Edge> edgePointer = startElement.Next;~\\
\cellcolor{gray} &  & \verb~576~ & \verb~~\\
\cellcolor{green} & 15 & \verb~577~ & \verb~            int edgeCount = 1;~\\
\cellcolor{green} & 279 & \verb~578~ & \verb~            for (edgeCount = 1; edgePointer != startElement; edgePointer++, ed~\\
\cellcolor{green} & 83 & \verb~579~ & \verb~                Vector3 nextPosition3D = position3D + edgePointer.Value.Direct~\\
\cellcolor{green} & 83 & \verb~580~ & \verb~                if ((nextPosition3D.X < bestPosition3D.X)~\\
\cellcolor{gray} &  & \verb~581~ & \verb~                        || (nextPosition3D.X == bestPosition3D.X && nextPositi~\\
\cellcolor{green} & 29 & \verb~582~ & \verb~                        || (nextPosition3D.X == bestPosition3D.X && nextPositi~\\
\cellcolor{green} & 29 & \verb~583~ & \verb~                    bestPosition3D = position3D + edgePointer.Value.Direction ~\\
\cellcolor{green} & 29 & \verb~584~ & \verb~                    charakteristikElement = edgePointer;~\\
\cellcolor{green} & 29 & \verb~585~ & \verb~                }~\\
\cellcolor{green} & 83 & \verb~586~ & \verb~                position3D += edgePointer.Value.Direction;~\\
\cellcolor{green} & 83 & \verb~587~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~588~ & \verb~~\\
\cellcolor{green} & 15 & \verb~589~ & \verb~            CharakteristicCache = new KnotCharakteristic (charakteristikElemen~\\
\cellcolor{green} & 15 & \verb~590~ & \verb~            return CharakteristicCache.Value;~\\
\cellcolor{green} & 28 & \verb~591~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~592~ & \verb~~\\
\cellcolor{gray} &  & \verb~593~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~594~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~595~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~596~ & \verb~            return "Knot (name=" + Name + ",#edgecount=" + startElement.Count.~\\
\cellcolor{gray} &  & \verb~597~ & \verb~                   + ",format=" + (MetaData.Format != null ? MetaData.ToString~\\
\cellcolor{gray} &  & \verb~598~ & \verb~                   + ")";~\\
\cellcolor{gray} &  & \verb~599~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~600~ & \verb~~\\
\cellcolor{gray} &  & \verb~601~ & \verb~        private struct KnotCharakteristic {~\\
\cellcolor{gray} &  & \verb~602~ & \verb~            public CircleEntry<Edge> CharacteristicalEdge { get; private set; ~\\
\cellcolor{gray} &  & \verb~603~ & \verb~~\\
\cellcolor{gray} &  & \verb~604~ & \verb~            public int CountEdges { get; private set; }~\\
\cellcolor{gray} &  & \verb~605~ & \verb~~\\
\cellcolor{gray} &  & \verb~606~ & \verb~            public KnotCharakteristic (CircleEntry<Edge> characteristicalEdge,~\\
\cellcolor{green} & 15 & \verb~607~ & \verb~            : this ()~\\
\cellcolor{green} & 15 & \verb~608~ & \verb~            {~\\
\cellcolor{green} & 15 & \verb~609~ & \verb~                CharacteristicalEdge = characteristicalEdge;~\\
\cellcolor{green} & 15 & \verb~610~ & \verb~                CountEdges = countEdges;~\\
\cellcolor{green} & 15 & \verb~611~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~612~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~613~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~614~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.KnotFileIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.KnotFileIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash KnotFileIO.cs}\end{minipage} \\
\textbf{Coverage:} & 85\%\\
\textbf{Covered lines:} & 34\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 130\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 1 & 100 & 100\\
\hline
\textbf{ResetCache()} & 1 & 0 & 0\\
\hline
\textbf{Save(...)} & 2 & 80 & 66.67\\
\hline
\textbf{Load(...)} & 2 & 100 & 100\\
\hline
\textbf{LoadMetaData(...)} & 2 & 100 & 100\\
\hline
\textbf{MoveNext()} & 5 & 100 & 80\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash KnotFileIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// Implementiert das Speicherformat für Knoten.~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    public sealed class KnotFileIO : IKnotIO~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// Die für eine Knoten-Datei gültigen Dateiendungen.~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// </summary>~\\
\cellcolor{green} & 176 & \verb~48~ & \verb~        public IEnumerable<string> FileExtensions~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        {~\\
\cellcolor{green} & 199 & \verb~50~ & \verb~            get {~\\
\cellcolor{green} & 199 & \verb~51~ & \verb~                yield return ".knot";~\\
\cellcolor{green} & 21 & \verb~52~ & \verb~                yield return ".knt";~\\
\cellcolor{green} & 21 & \verb~53~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{green} & 92 & \verb~56~ & \verb~        private Dictionary<string, Knot> KnotCache = new Dictionary<string, Kn~\\
\cellcolor{green} & 92 & \verb~57~ & \verb~        private Dictionary<string, KnotMetaData> KnotMetaDataCache = new Dicti~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        /// Erstellt ein KnotFileIO-Objekt.~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// </summary>~\\
\cellcolor{green} & 92 & \verb~62~ & \verb~        public KnotFileIO ()~\\
\cellcolor{green} & 92 & \verb~63~ & \verb~        {~\\
\cellcolor{green} & 92 & \verb~64~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        public void ResetCache ()~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~            KnotCache.Clear ();~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~            KnotMetaDataCache.Clear ();~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// Speichert einen Knoten in dem Dateinamen, der in dem Knot-Objekt e~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        public void Save (Knot knot)~\\
\cellcolor{green} & 1 & \verb~76~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~77~ & \verb~            KnotStringIO parser = new KnotStringIO (knot);~\\
\cellcolor{green} & 1 & \verb~78~ & \verb~            Log.Debug ("KnotFileIO.Save (", knot, ") = #", parser.Content.Leng~\\
\cellcolor{green} & 1 & \verb~79~ & \verb~            if (knot.MetaData.Filename == null) {~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~                throw new IOException ("Error! knot has no filename: " + knot)~\\
\cellcolor{gray} &  & \verb~81~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~82~ & \verb~            else {~\\
\cellcolor{green} & 1 & \verb~83~ & \verb~                File.WriteAllText (knot.MetaData.Filename, parser.Content);~\\
\cellcolor{green} & 1 & \verb~84~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~85~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        /// Lädt eines Knotens aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        public Knot Load (string filename)~\\
\cellcolor{green} & 7 & \verb~91~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~92~ & \verb~            if (KnotCache.ContainsKey (filename)) {~\\
\cellcolor{green} & 1 & \verb~93~ & \verb~                return KnotCache [filename];~\\
\cellcolor{gray} &  & \verb~94~ & \verb~            }~\\
\cellcolor{green} & 6 & \verb~95~ & \verb~            else {~\\
\cellcolor{green} & 6 & \verb~96~ & \verb~                Log.Debug ("Load knot from ", filename);~\\
\cellcolor{green} & 6 & \verb~97~ & \verb~                KnotStringIO parser = new KnotStringIO (content: string.Join (~\\
\cellcolor{green} & 5 & \verb~98~ & \verb~                return KnotCache [filename] = new Knot (~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~                    new KnotMetaData (parser.Name, () => parser.CountEdges, th~\\
\cellcolor{gray} &  & \verb~100~ & \verb~                    parser.Edges~\\
\cellcolor{gray} &  & \verb~101~ & \verb~                );~\\
\cellcolor{gray} &  & \verb~102~ & \verb~            }~\\
\cellcolor{green} & 6 & \verb~103~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~104~ & \verb~~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        /// Lädt die Metadaten eines Knotens aus einer angegebenen Datei.~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        public KnotMetaData LoadMetaData (string filename)~\\
\cellcolor{green} & 4 & \verb~109~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~110~ & \verb~            if (KnotMetaDataCache.ContainsKey (filename)) {~\\
\cellcolor{green} & 1 & \verb~111~ & \verb~                return KnotMetaDataCache [filename];~\\
\cellcolor{gray} &  & \verb~112~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~113~ & \verb~            else {~\\
\cellcolor{green} & 3 & \verb~114~ & \verb~                KnotStringIO parser = new KnotStringIO (content: string.Join (~\\
\cellcolor{green} & 3 & \verb~115~ & \verb~                return KnotMetaDataCache [filename] = new KnotMetaData (~\\
\cellcolor{gray} &  & \verb~116~ & \verb~                    name: parser.Name,~\\
\cellcolor{green} & 1 & \verb~117~ & \verb~                    countEdges: () => parser.CountEdges,~\\
\cellcolor{gray} &  & \verb~118~ & \verb~                    format: this,~\\
\cellcolor{gray} &  & \verb~119~ & \verb~                    filename: filename~\\
\cellcolor{gray} &  & \verb~120~ & \verb~                );~\\
\cellcolor{gray} &  & \verb~121~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~122~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~125~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~126~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~127~ & \verb~            return "KnotFileIO";~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~130~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.KnotMetaData}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.KnotMetaData\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash KnotMetaData.cs}\end{minipage} \\
\textbf{Coverage:} & 86\%\\
\textbf{Covered lines:} & 43\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 50\\
\textbf{Total lines:} & 165\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 3 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 100 & 60\\
\hline
\textbf{Equals(...)} & 2 & 0 & 0\\
\hline
\textbf{op\_Equality(...)} & 4 & 66.67 & 57.14\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash KnotMetaData.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// Enthält Metadaten eines Knotens, die aus einer Spielstand-Datei schnel~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// als der vollständige Knoten. Dieses Objekt enthält keine Datenstruktur~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// sondern nur Informationen über den Namen des Knoten und die Anzahl sei~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    /// dazugehöriges Knoten-Objekt existieren, aber jedes Knoten-Objekt enthä~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    public class KnotMetaData : IEquatable<KnotMetaData>~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Der Anzeigename des Knotens, welcher auch leer sein kann.~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// Beim Speichern muss der Spieler in diesem Fall zwingend~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// einen nichtleeren Namen wählen. Wird ein neuer Anzeigename festgel~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// dann wird der Dateiname ebenfalls auf einen neuen Wert gesetzt, un~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// ob er bereits einen Wert enthält oder \glqq null\grqq ist.~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// Diese Eigenschaft kann öffentlich gelesen und gesetzt werden.~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        public string Name~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        {~\\
\cellcolor{green} & 72 & \verb~58~ & \verb~            get {~\\
\cellcolor{green} & 72 & \verb~59~ & \verb~                return name;~\\
\cellcolor{green} & 72 & \verb~60~ & \verb~            }~\\
\cellcolor{green} & 88 & \verb~61~ & \verb~            set {~\\
\cellcolor{green} & 88 & \verb~62~ & \verb~                name = value;~\\
\cellcolor{green} & 175 & \verb~63~ & \verb~                if (Format == null) {~\\
\cellcolor{green} & 87 & \verb~64~ & \verb~                    Format = new KnotFileIO ();~\\
\cellcolor{green} & 87 & \verb~65~ & \verb~                }~\\
\cellcolor{green} & 175 & \verb~66~ & \verb~                if (name != null && name.Length > 0) {~\\
\cellcolor{gray} &  & \verb~67~ & \verb~                    string extension;~\\
\cellcolor{green} & 174 & \verb~68~ & \verb~                    if (Format.FileExtensions.Any ()) {~\\
\cellcolor{green} & 87 & \verb~69~ & \verb~                        extension = Format.FileExtensions.ElementAt (0);~\\
\cellcolor{green} & 87 & \verb~70~ & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~                    else {~\\
\cellcolor{red} & 0 & \verb~72~ & \verb~                        throw new ArgumentException ("Every implementation of ~\\
\cellcolor{gray} &  & \verb~73~ & \verb~                    }~\\
\cellcolor{green} & 87 & \verb~74~ & \verb~                    Filename = SystemInfo.SavegameDirectory + SystemInfo.PathS~\\
\cellcolor{green} & 87 & \verb~75~ & \verb~                }~\\
\cellcolor{green} & 88 & \verb~76~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~78~ & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        private string name;~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        /// Das Format, aus dem die Metadaten geladen wurden.~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// Es ist genau dann \glqq null\grqq, wenn die Metadaten nicht aus ei~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        /// </summary>~\\
\cellcolor{green} & 543 & \verb~85~ & \verb~        public IKnotIO Format { get; private set; }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        /// Ein Delegate, das die Anzahl der Kanten zurückliefert.~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        /// Falls dieses Metadaten-Objekt Teil eines Knotens ist, gibt es dyna~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        /// Kanten des Knoten-Objektes zurück. Anderenfalls gibt es eine stati~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        /// die beim Einlesen der Metadaten vor dem Erstellen dieses Objektes ~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~93~ & \verb~        public int CountEdges { get { return countEdges (); } }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & \verb~        private Func<int> countEdges;~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        /// Falls die Metadaten aus einer Datei eingelesen wurden, enthält die~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        /// sonst \glqq null\grqq.~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        /// </summary>~\\
\cellcolor{green} & 284 & \verb~101~ & \verb~        public string Filename { get; private set; }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        /// Erstellt ein neues Knoten-Metadaten-Objekt mit einem angegebenen K~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        /// und einer angegebenen Funktion, welche eine Kantenanzahl zurück gi~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        /// Zusätzlich wird der Dateiname oder das Speicherformat angegeben, a~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        /// </summary>~\\
\cellcolor{green} & 87 & \verb~108~ & \verb~        public KnotMetaData (string name, Func<int> countEdges, IKnotIO format~\\
\cellcolor{green} & 87 & \verb~109~ & \verb~        {~\\
\cellcolor{green} & 87 & \verb~110~ & \verb~            Name = name;~\\
\cellcolor{green} & 87 & \verb~111~ & \verb~            this.countEdges = countEdges;~\\
\cellcolor{green} & 87 & \verb~112~ & \verb~            Format = format ?? Format;~\\
\cellcolor{green} & 87 & \verb~113~ & \verb~            Filename = filename ?? Filename;~\\
\cellcolor{green} & 87 & \verb~114~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        /// Erstellt ein neues Knoten-Metadaten-Objekt mit einem angegebenen K~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        /// und einer angegebenen Funktion, welche eine Kantenanzahl zurück gi~\\
\cellcolor{gray} &  & \verb~119~ & \verb~        /// </summary>~\\
\cellcolor{green} & 7 & \verb~120~ & \verb~        public KnotMetaData (string name, Func<int> countEdges)~\\
\cellcolor{green} & 7 & \verb~121~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~122~ & \verb~            this.name = name;~\\
\cellcolor{green} & 7 & \verb~123~ & \verb~            this.countEdges = countEdges;~\\
\cellcolor{green} & 7 & \verb~124~ & \verb~            Format = null;~\\
\cellcolor{green} & 7 & \verb~125~ & \verb~            Filename = null;~\\
\cellcolor{green} & 7 & \verb~126~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        public bool Equals (KnotMetaData other)~\\
\cellcolor{green} & 1 & \verb~129~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~130~ & \verb~            return other != null && name == other.name && countEdges () == oth~\\
\cellcolor{green} & 1 & \verb~131~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{red} & 0 & \verb~134~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~            return other != null && Equals (other as KnotMetaData);~\\
\cellcolor{red} & 0 & \verb~136~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~139~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~140~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~141~ & \verb~            return (countEdges ().ToString () + (name ?? String.Empty)).GetHas~\\
\cellcolor{gray} &  & \verb~142~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & \verb~        public static bool operator == (KnotMetaData a, KnotMetaData b)~\\
\cellcolor{green} & 11 & \verb~145~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~146~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 11 & \verb~147~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~149~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 22 & \verb~152~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 11 & \verb~153~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~154~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~            // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~            return a.Equals (b);~\\
\cellcolor{green} & 11 & \verb~158~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        public static bool operator != (KnotMetaData a, KnotMetaData b)~\\
\cellcolor{green} & 11 & \verb~161~ & \verb~        {~\\
\cellcolor{green} & 11 & \verb~162~ & \verb~            return !(a == b);~\\
\cellcolor{green} & 11 & \verb~163~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.KnotStringIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.KnotStringIO\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash KnotStringIO.cs}\end{minipage} \\
\textbf{Coverage:} & 86.2\%\\
\textbf{Covered lines:} & 100\\
\textbf{Uncovered lines:} & 16\\
\textbf{Coverable lines:} & 116\\
\textbf{Total lines:} & 242\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 63.64 & 100\\
\hline
\textbf{DecodeEdge(...)} & 2 & 100 & 100\\
\hline
\textbf{EncodeEdge(...)} & 2 & 75 & 66.67\\
\hline
\textbf{EncodeColor(...)} & 1 & 100 & 100\\
\hline
\textbf{DecodeColor(...)} & 4 & 82.76 & 71.43\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\textbf{MoveNext()} & 10 & 90.91 & 78.95\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash KnotStringIO.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~43~ & \verb~{~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// Diese Klasse repräsentiert einen Parser für das Knoten-Austauschformat~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    /// eingelesenen Informationen wie den Namen des Knotens und die Kantenlis~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~    public sealed class KnotStringIO~\\
\cellcolor{gray} &  & \verb~49~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// Der Name der eingelesenen Knotendatei oder des zugewiesenen Knoten~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// </summary>~\\
\cellcolor{green} & 88 & \verb~53~ & \verb~        public string Name { get; set; }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        private IEnumerable<string> edgeLines;~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{green} & 1 & \verb~57~ & \verb~        public static Dictionary<char, Direction> DirectionCodeMap = new Dicti~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~59~ & \verb~            { 'X', Edge.Right },~\\
\cellcolor{gray} &  & \verb~60~ & \verb~            { 'x', Edge.Left },~\\
\cellcolor{gray} &  & \verb~61~ & \verb~            { 'Y', Edge.Up },~\\
\cellcolor{gray} &  & \verb~62~ & \verb~            { 'y', Edge.Down },~\\
\cellcolor{gray} &  & \verb~63~ & \verb~            { 'Z', Edge.Backward },~\\
\cellcolor{gray} &  & \verb~64~ & \verb~            { 'z', Edge.Forward }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        };~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        /// Die Kanten der eingelesenen Knotendatei oder des zugewiesenen Knot~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        /// </summary>~\\
\cellcolor{green} & 24 & \verb~70~ & \verb~        public IEnumerable<Edge> Edges~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        {~\\
\cellcolor{green} & 36 & \verb~72~ & \verb~            get {~\\
\cellcolor{green} & 36 & \verb~73~ & \verb~                Log.Debug ("KnotStringIO.Edges [get] = ", edgeLines.Count ());~\\
\cellcolor{green} & 820 & \verb~74~ & \verb~                foreach (string _line in edgeLines) {~\\
\cellcolor{green} & 238 & \verb~75~ & \verb~                    string line = _line;~\\
\cellcolor{green} & 238 & \verb~76~ & \verb~                    Edge edge = DecodeEdge (line [0]);~\\
\cellcolor{green} & 237 & \verb~77~ & \verb~                    line = line.Substring (1);~\\
\cellcolor{green} & 474 & \verb~78~ & \verb~                    if (line.StartsWith ("#")) {~\\
\cellcolor{green} & 237 & \verb~79~ & \verb~                        line = line.Substring (1);~\\
\cellcolor{green} & 237 & \verb~80~ & \verb~                    }~\\
\cellcolor{green} & 474 & \verb~81~ & \verb~                    if (line.IndexOf ("#") > -1) {~\\
\cellcolor{green} & 237 & \verb~82~ & \verb~                        edge.Color = DecodeColor (line.Substring (0, line.Inde~\\
\cellcolor{green} & 236 & \verb~83~ & \verb~                        line = line.Substring (line.IndexOf ("#"));~\\
\cellcolor{green} & 236 & \verb~84~ & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~                    else {~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~                        edge.Color = DecodeColor (line);~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~                        line = "";~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{green} & 472 & \verb~90~ & \verb~                    if (line.StartsWith ("#")) {~\\
\cellcolor{green} & 236 & \verb~91~ & \verb~                        line = line.Substring (1);~\\
\cellcolor{green} & 236 & \verb~92~ & \verb~                    }~\\
\cellcolor{green} & 237 & \verb~93~ & \verb~                    if (line.IndexOf ("#") > -1) {~\\
\cellcolor{green} & 1 & \verb~94~ & \verb~                        line = line.Substring (0, line.IndexOf ("#"));~\\
\cellcolor{green} & 1 & \verb~95~ & \verb~                    }~\\
\cellcolor{green} & 240 & \verb~96~ & \verb~                    if (line.Length > 0) {~\\
\cellcolor{green} & 24 & \verb~97~ & \verb~                        foreach (int rect in line.Split (',').Select (int.Pars~\\
\cellcolor{green} & 4 & \verb~98~ & \verb~                            edge.Rectangles.Add (rect);~\\
\cellcolor{green} & 4 & \verb~99~ & \verb~                        }~\\
\cellcolor{green} & 4 & \verb~100~ & \verb~                    }~\\
\cellcolor{green} & 236 & \verb~101~ & \verb~                    yield return edge;~\\
\cellcolor{green} & 236 & \verb~102~ & \verb~                }~\\
\cellcolor{green} & 34 & \verb~103~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~104~ & \verb~            set {~\\
\cellcolor{green} & 1 & \verb~105~ & \verb~                Log.Debug ("KnotStringIO.Edges [set] = #", value.Count ());~\\
\cellcolor{green} & 1 & \verb~106~ & \verb~                try {~\\
\cellcolor{green} & 1 & \verb~107~ & \verb~                    edgeLines = ToLines (value);~\\
\cellcolor{green} & 1 & \verb~108~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~                catch (Exception ex) {~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~                    Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~                }~\\
\cellcolor{green} & 1 & \verb~112~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        /// Die Anzahl der Kanten der eingelesenen Knotendatei oder des zugewi~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        public int CountEdges~\\
\cellcolor{gray} &  & \verb~119~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~120~ & \verb~            get {~\\
\cellcolor{green} & 94 & \verb~121~ & \verb~                return edgeLines.Where ((l) => l.Trim ().Length > 0).Count ();~\\
\cellcolor{green} & 4 & \verb~122~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~126~ & \verb~        /// Erstellt aus den \glqq Name\grqq - und \glqq Edges\grqq -Eigenscha~\\
\cellcolor{gray} &  & \verb~127~ & \verb~        /// die als Dateiinhalt in einer Datei eines Spielstandes einen gültig~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~129~ & \verb~        public string Content~\\
\cellcolor{gray} &  & \verb~130~ & \verb~        {~\\
\cellcolor{green} & 11 & \verb~131~ & \verb~            get {~\\
\cellcolor{green} & 11 & \verb~132~ & \verb~                return Name + "\n" + string.Join ("\n", edgeLines);~\\
\cellcolor{green} & 11 & \verb~133~ & \verb~            }~\\
\cellcolor{green} & 37 & \verb~134~ & \verb~            set {~\\
\cellcolor{green} & 73 & \verb~135~ & \verb~                if (value.Trim ().Contains ("\n")) {~\\
\cellcolor{green} & 36 & \verb~136~ & \verb~                    string[] parts = value.Split (new char[] {'\r','\n'}, Stri~\\
\cellcolor{green} & 36 & \verb~137~ & \verb~                    Name = parts [0];~\\
\cellcolor{green} & 36 & \verb~138~ & \verb~                    edgeLines = parts.Skip (1);~\\
\cellcolor{green} & 36 & \verb~139~ & \verb~                }~\\
\cellcolor{green} & 1 & \verb~140~ & \verb~                else {~\\
\cellcolor{green} & 1 & \verb~141~ & \verb~                    Name = value;~\\
\cellcolor{green} & 1 & \verb~142~ & \verb~                    edgeLines = new string[] {};~\\
\cellcolor{green} & 1 & \verb~143~ & \verb~                }~\\
\cellcolor{green} & 37 & \verb~144~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~146~ & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~148~ & \verb~        /// Liest das in der angegebenen Zeichenkette enthaltene Dateiformat e~\\
\cellcolor{gray} &  & \verb~149~ & \verb~        /// so werden die \glqq Name\grqq - und \glqq Edges\grqq -Eigenschafte~\\
\cellcolor{gray} &  & \verb~150~ & \verb~        /// Enthält es einen ungültigen Knoten, so wird eine IOException gewor~\\
\cellcolor{gray} &  & \verb~151~ & \verb~        /// </summary>~\\
\cellcolor{green} & 37 & \verb~152~ & \verb~        public KnotStringIO (string content)~\\
\cellcolor{green} & 37 & \verb~153~ & \verb~        {~\\
\cellcolor{green} & 37 & \verb~154~ & \verb~            Content = content;~\\
\cellcolor{green} & 37 & \verb~155~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~156~ & \verb~~\\
\cellcolor{gray} &  & \verb~157~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        /// Erstellt ein neues Objekt und setzt die \glqq Name\grqq - und \glq~\\
\cellcolor{gray} &  & \verb~159~ & \verb~        /// im angegebenen Knoten enthaltenen Werte.~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        /// </summary>~\\
\cellcolor{green} & 13 & \verb~161~ & \verb~        public KnotStringIO (Knot knot)~\\
\cellcolor{green} & 13 & \verb~162~ & \verb~        {~\\
\cellcolor{green} & 13 & \verb~163~ & \verb~            Name = knot.Name;~\\
\cellcolor{green} & 13 & \verb~164~ & \verb~            try {~\\
\cellcolor{green} & 13 & \verb~165~ & \verb~                edgeLines = ToLines (knot);~\\
\cellcolor{green} & 13 & \verb~166~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~            catch (Exception ex) {~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~                Log.Debug (ex);~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~            }~\\
\cellcolor{green} & 13 & \verb~170~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~171~ & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & \verb~        [ExcludeFromCodeCoverage]~\\
\cellcolor{gray} &  & \verb~173~ & \verb~        private static IEnumerable<string> ToLines (IEnumerable<Edge> edges)~\\
\cellcolor{gray} &  & \verb~174~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~175~ & \verb~            foreach (Edge edge in edges) {~\\
\cellcolor{gray} &  & \verb~176~ & \verb~                yield return EncodeEdge (edge) + "#" + EncodeColor (edge.Color~\\
\cellcolor{gray} &  & \verb~177~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~178~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~179~ & \verb~~\\
\cellcolor{gray} &  & \verb~180~ & \verb~        private static Edge DecodeEdge (char c)~\\
\cellcolor{green} & 238 & \verb~181~ & \verb~        {~\\
\cellcolor{green} & 475 & \verb~182~ & \verb~            if (DirectionCodeMap.ContainsKey (c)) {~\\
\cellcolor{green} & 237 & \verb~183~ & \verb~                return new Edge (DirectionCodeMap [c]);~\\
\cellcolor{gray} &  & \verb~184~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~185~ & \verb~            else {~\\
\cellcolor{green} & 1 & \verb~186~ & \verb~                throw new IOException ("Failed to decode Edge: '" + c + "'!");~\\
\cellcolor{gray} &  & \verb~187~ & \verb~            }~\\
\cellcolor{green} & 237 & \verb~188~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~189~ & \verb~~\\
\cellcolor{gray} &  & \verb~190~ & \verb~        private static char EncodeEdge (Edge edge)~\\
\cellcolor{green} & 512 & \verb~191~ & \verb~        {~\\
\cellcolor{green} & 512 & \verb~192~ & \verb~            Dictionary<Direction, char> reversed = DirectionCodeMap.ReverseDic~\\
\cellcolor{green} & 1024 & \verb~193~ & \verb~            if (reversed.ContainsKey (edge.Direction)) {~\\
\cellcolor{green} & 512 & \verb~194~ & \verb~                return reversed [edge.Direction];~\\
\cellcolor{gray} &  & \verb~195~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~196~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~197~ & \verb~                throw new IOException ("Failed to encode Edge: '" + edge + "'!~\\
\cellcolor{gray} &  & \verb~198~ & \verb~            }~\\
\cellcolor{green} & 512 & \verb~199~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~200~ & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & \verb~        private static String EncodeColor (Color c)~\\
\cellcolor{green} & 512 & \verb~202~ & \verb~        {~\\
\cellcolor{green} & 512 & \verb~203~ & \verb~            return c.R.ToString ("X2") + c.G.ToString ("X2") + c.B.ToString ("~\\
\cellcolor{green} & 512 & \verb~204~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~205~ & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & \verb~        private static Color DecodeColor (string hexString)~\\
\cellcolor{green} & 237 & \verb~207~ & \verb~        {~\\
\cellcolor{green} & 237 & \verb~208~ & \verb~            if (hexString.StartsWith ("#")) {~\\
\cellcolor{red} & 0 & \verb~209~ & \verb~                hexString = hexString.Substring (1);~\\
\cellcolor{red} & 0 & \verb~210~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~~\\
\cellcolor{green} & 237 & \verb~212~ & \verb~            Log.Debug (hexString);~\\
\cellcolor{green} & 237 & \verb~213~ & \verb~            uint hex = unchecked ( uint.Parse (hexString, System.Globalization~\\
\cellcolor{green} & 236 & \verb~214~ & \verb~            Color color = Color.White;~\\
\cellcolor{green} & 464 & \verb~215~ & \verb~            if (hexString.Length == 8) {~\\
\cellcolor{green} & 228 & \verb~216~ & \verb~                unchecked {~\\
\cellcolor{green} & 228 & \verb~217~ & \verb~                    color.R = (byte)(hex >> 24);~\\
\cellcolor{green} & 228 & \verb~218~ & \verb~                    color.G = (byte)(hex >> 16);~\\
\cellcolor{green} & 228 & \verb~219~ & \verb~                    color.B = (byte)(hex >> 8);~\\
\cellcolor{green} & 228 & \verb~220~ & \verb~                    color.A = (byte)(hex);~\\
\cellcolor{green} & 228 & \verb~221~ & \verb~                }~\\
\cellcolor{green} & 228 & \verb~222~ & \verb~            }~\\
\cellcolor{green} & 16 & \verb~223~ & \verb~            else if (hexString.Length == 6) {~\\
\cellcolor{green} & 8 & \verb~224~ & \verb~                unchecked {~\\
\cellcolor{green} & 8 & \verb~225~ & \verb~                    color.R = (byte)(hex >> 16);~\\
\cellcolor{green} & 8 & \verb~226~ & \verb~                    color.G = (byte)(hex >> 8);~\\
\cellcolor{green} & 8 & \verb~227~ & \verb~                    color.B = (byte)(hex);~\\
\cellcolor{green} & 8 & \verb~228~ & \verb~                }~\\
\cellcolor{green} & 8 & \verb~229~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~231~ & \verb~                throw new IOException ("Invalid hex representation of an ARGB ~\\
\cellcolor{gray} &  & \verb~232~ & \verb~            }~\\
\cellcolor{green} & 236 & \verb~233~ & \verb~            return color;~\\
\cellcolor{green} & 236 & \verb~234~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~235~ & \verb~~\\
\cellcolor{gray} &  & \verb~236~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~237~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~238~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~239~ & \verb~            return "KnotStringIO (length=" + Content.Length + ")";~\\
\cellcolor{gray} &  & \verb~240~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~241~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~242~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.Node}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.Node\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Node.cs}\end{minipage} \\
\textbf{Coverage:} & 73.7\%\\
\textbf{Covered lines:} & 45\\
\textbf{Uncovered lines:} & 16\\
\textbf{Coverable lines:} & 61\\
\textbf{Total lines:} & 180\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{CenterBetween(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Addition(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 0 & 0\\
\hline
\textbf{Clone()} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 6 & 55.56 & 54.55\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 100 & 60\\
\hline
\textbf{Equals(...)} & 2 & 71.43 & 66.67\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash Node.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~37~ & \verb~{~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// Eine Position im 3D-Raster. Die Werte für alle drei Koordinaten sind I~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// Eine Skalierung auf Koordinaten im 3D-Raum und damit einhergehend eine~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    public sealed class Node : IEquatable<Node>, ICloneable~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// X steht für eine x-Koordinate im dreidimensionalen Raster.~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// </summary>~\\
\cellcolor{green} & 116 & \verb~47~ & \verb~        public int X { get; private set; }~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// Y steht für eine y-Koordinate im dreidimensionalen Raster.~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// </summary>~\\
\cellcolor{green} & 116 & \verb~52~ & \verb~        public int Y { get; private set; }~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// Z steht für eine z-Koordinate im dreidimensionalen Raster.~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// </summary>~\\
\cellcolor{green} & 116 & \verb~57~ & \verb~        public int Z { get; private set; }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        /// Ein Skalierungswert.~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~62~ & \verb~        public static readonly int Scale = 100;~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        /// Erzeugt eine neue Instanz eines Node-Objekts und initialisiert die~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// für die x-, y- und z-Koordinate.~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        /// </summary>~\\
\cellcolor{green} & 22 & \verb~68~ & \verb~        public Node (int x, int y, int z)~\\
\cellcolor{green} & 22 & \verb~69~ & \verb~        {~\\
\cellcolor{green} & 22 & \verb~70~ & \verb~            X = x;~\\
\cellcolor{green} & 22 & \verb~71~ & \verb~            Y = y;~\\
\cellcolor{green} & 22 & \verb~72~ & \verb~            Z = z;~\\
\cellcolor{green} & 22 & \verb~73~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// Liefert die x-, y- und z-Koordinaten im 3D-Raum als ein Vektor3 de~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        public Vector3 Vector~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        {~\\
\cellcolor{green} & 22 & \verb~80~ & \verb~            get {~\\
\cellcolor{green} & 22 & \verb~81~ & \verb~                return new Vector3 (X * Scale, Y * Scale, Z * Scale);~\\
\cellcolor{green} & 22 & \verb~82~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        public static implicit operator Vector3 (Node node)~\\
\cellcolor{green} & 14 & \verb~86~ & \verb~        {~\\
\cellcolor{green} & 14 & \verb~87~ & \verb~            return node.Vector;~\\
\cellcolor{green} & 14 & \verb~88~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        public Vector3 CenterBetween (Node other)~\\
\cellcolor{green} & 4 & \verb~91~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~92~ & \verb~            Vector3 positionFrom = this.Vector;~\\
\cellcolor{green} & 4 & \verb~93~ & \verb~            Vector3 positionTo = other.Vector;~\\
\cellcolor{green} & 4 & \verb~94~ & \verb~            return positionFrom + (positionTo - positionFrom) / 2;~\\
\cellcolor{green} & 4 & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        public static Node operator + (Node a, Vector3 b)~\\
\cellcolor{green} & 1 & \verb~98~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~99~ & \verb~            return new Node (a.X + (int)b.X, a.Y + (int)b.Y, a.Z + (int)b.Z);~\\
\cellcolor{green} & 1 & \verb~100~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~101~ & \verb~~\\
\cellcolor{gray} &  & \verb~102~ & \verb~        public static Vector3 operator - (Node a, Node b)~\\
\cellcolor{green} & 1 & \verb~103~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~104~ & \verb~            return new Vector3 (a.X - b.X, a.Y - b.Y, a.Z - b.Z);~\\
\cellcolor{green} & 1 & \verb~105~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        public static Node operator + (Node a, Direction b)~\\
\cellcolor{red} & 0 & \verb~108~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~109~ & \verb~            return new Node (a.X + (int)b.Vector.X, a.Y + (int)b.Vector.Y, a.Z~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~        public static Node operator - (Node a, Direction b)~\\
\cellcolor{red} & 0 & \verb~113~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~            return new Node (a.X - (int)b.Vector.X, a.Y - (int)b.Vector.Y, a.Z~\\
\cellcolor{red} & 0 & \verb~115~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        public static Node operator + (Direction a, Node b)~\\
\cellcolor{red} & 0 & \verb~118~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~            return b+a;~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~        public static Node operator - (Direction a, Node b)~\\
\cellcolor{red} & 0 & \verb~123~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~            return b-a;~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~129~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~130~ & \verb~            return X * 10000 + Y * 100 + Z;~\\
\cellcolor{gray} &  & \verb~131~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~134~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~136~ & \verb~            return "(" + X.ToString () + "," + Y.ToString () + "," + Z.ToStrin~\\
\cellcolor{gray} &  & \verb~137~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~138~ & \verb~~\\
\cellcolor{gray} &  & \verb~139~ & \verb~        public object Clone ()~\\
\cellcolor{green} & 1 & \verb~140~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~141~ & \verb~            return new Node (X, Y, Z);~\\
\cellcolor{green} & 1 & \verb~142~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & \verb~        public static bool operator == (Node a, Node b)~\\
\cellcolor{green} & 2 & \verb~145~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~146~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 2 & \verb~147~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~148~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~149~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 2 & \verb~152~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{red} & 0 & \verb~153~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~154~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~            // Return true if the fields match:~\\
\cellcolor{green} & 2 & \verb~157~ & \verb~            return a.X == b.X && a.Y == b.Y && a.Z == b.Z;~\\
\cellcolor{green} & 2 & \verb~158~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~159~ & \verb~~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        public static bool operator != (Node a, Node b)~\\
\cellcolor{green} & 1 & \verb~161~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~162~ & \verb~            return !(a == b);~\\
\cellcolor{green} & 1 & \verb~163~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~164~ & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & \verb~        public bool Equals (Node other)~\\
\cellcolor{green} & 20 & \verb~166~ & \verb~        {~\\
\cellcolor{green} & 20 & \verb~167~ & \verb~            return this.X == other.X && this.Y == other.Y && this.Z == other.Z~\\
\cellcolor{green} & 20 & \verb~168~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~169~ & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & \verb~        public override bool Equals (object obj)~\\
\cellcolor{green} & 2 & \verb~171~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~172~ & \verb~            if (obj is Node) {~\\
\cellcolor{green} & 2 & \verb~173~ & \verb~                return Equals ((Node)obj);~\\
\cellcolor{gray} &  & \verb~174~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~175~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~176~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~177~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~178~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~179~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Data.NodeMap}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Data.NodeMap\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash NodeMap.cs}\end{minipage} \\
\textbf{Coverage:} & 88.5\%\\
\textbf{Covered lines:} & 54\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 61\\
\textbf{Total lines:} & 151\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor()} & 2 & 100 & 66.67\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{NodeBeforeEdge(...)} & 1 & 100 & 100\\
\hline
\textbf{NodeAfterEdge(...)} & 1 & 100 & 100\\
\hline
\textbf{JunctionsAtNode(...)} & 1 & 100 & 100\\
\hline
\textbf{JunctionsBeforeEdge(} & 1 & 100 & 100\\
\hline
\textbf{JunctionsAfterEdge(.} & 1 & 100 & 100\\
\hline
\textbf{OnEdgesChanged()} & 1 & 0 & 0\\
\hline
\textbf{BuildIndex()} & 5 & 100 & 77.78\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{c:\textbackslash Users\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Data\textbackslash NodeMap.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Knot3.Game.Models;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & \verb~namespace Knot3.Game.Data~\\
\cellcolor{gray} &  & \verb~44~ & \verb~{~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    /// Eine Zuordnung zwischen Kanten und den dreidimensionalen Rasterpunkten~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~    public sealed class NodeMap : INodeMap~\\
\cellcolor{gray} &  & \verb~49~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~50~ & \verb~        private Hashtable fromMap = new Hashtable ();~\\
\cellcolor{green} & 1 & \verb~51~ & \verb~        private Hashtable toMap = new Hashtable ();~\\
\cellcolor{green} & 1 & \verb~52~ & \verb~        private Dictionary<Node, List<IJunction>> junctionMap = new Dictionary~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// Die Skalierung, die bei einer Konvertierung in einen Vector3 des X~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~57~ & \verb~        public int Scale { get; set; }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{green} & 11 & \verb~59~ & \verb~        public IEnumerable<Edge> Edges { get; set; }~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{green} & 3 & \verb~61~ & \verb~        public Vector3 Offset { get; set; }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{green} & 11 & \verb~63~ & \verb~        public Action IndexRebuilt { get; set; }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~        public NodeMap ()~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~67~ & \verb~            IndexRebuilt = () => {};~\\
\cellcolor{green} & 1 & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{green} & 1 & \verb~70~ & \verb~        public NodeMap (IEnumerable<Edge> edges)~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        : this ()~\\
\cellcolor{green} & 1 & \verb~72~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~73~ & \verb~            Edges = edges;~\\
\cellcolor{green} & 1 & \verb~74~ & \verb~            BuildIndex ();~\\
\cellcolor{green} & 1 & \verb~75~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// Gibt die Rasterposition des Übergangs am Anfang der Kante zurück.~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        public Node NodeBeforeEdge (Edge edge)~\\
\cellcolor{green} & 8 & \verb~81~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~82~ & \verb~            return (Node)fromMap [edge];~\\
\cellcolor{green} & 8 & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        /// Gibt die Rasterposition des Übergangs am Ende der Kante zurück.~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        public Node NodeAfterEdge (Edge edge)~\\
\cellcolor{green} & 20 & \verb~89~ & \verb~        {~\\
\cellcolor{green} & 20 & \verb~90~ & \verb~            return (Node)toMap [edge];~\\
\cellcolor{green} & 20 & \verb~91~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~92~ & \verb~~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        public List<IJunction> JunctionsAtNode (Node node)~\\
\cellcolor{green} & 4 & \verb~94~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~95~ & \verb~            return junctionMap [node];~\\
\cellcolor{green} & 4 & \verb~96~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        public List<IJunction> JunctionsBeforeEdge (Edge edge)~\\
\cellcolor{green} & 4 & \verb~99~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~100~ & \verb~            return junctionMap [NodeBeforeEdge (edge)];~\\
\cellcolor{green} & 4 & \verb~101~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        public List<IJunction> JunctionsAfterEdge (Edge edge)~\\
\cellcolor{green} & 4 & \verb~104~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~105~ & \verb~            return junctionMap [NodeAfterEdge (edge)];~\\
\cellcolor{green} & 4 & \verb~106~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        public IEnumerable<Node> Nodes~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~110~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~111~ & \verb~                return junctionMap.Keys;~\\
\cellcolor{red} & 0 & \verb~112~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        /// Aktualisiert die Zuordnung, wenn sich die Kanten geändert haben.~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        public void OnEdgesChanged ()~\\
\cellcolor{red} & 0 & \verb~119~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~120~ & \verb~            BuildIndex ();~\\
\cellcolor{red} & 0 & \verb~121~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        private void BuildIndex ()~\\
\cellcolor{green} & 1 & \verb~124~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~125~ & \verb~            fromMap.Clear ();~\\
\cellcolor{green} & 1 & \verb~126~ & \verb~            toMap.Clear ();~\\
\cellcolor{green} & 3 & \verb~127~ & \verb~            float x = Offset.X, y = Offset.Y, z = Offset.Z;~\\
\cellcolor{green} & 15 & \verb~128~ & \verb~            foreach (Edge edge in Edges) {~\\
\cellcolor{green} & 4 & \verb~129~ & \verb~                fromMap [edge] = new Node ((int)x, (int)y, (int)z);~\\
\cellcolor{green} & 4 & \verb~130~ & \verb~                Vector3 v = edge.Direction.Vector;~\\
\cellcolor{green} & 4 & \verb~131~ & \verb~                x += v.X;~\\
\cellcolor{green} & 4 & \verb~132~ & \verb~                y += v.Y;~\\
\cellcolor{green} & 4 & \verb~133~ & \verb~                z += v.Z;~\\
\cellcolor{green} & 4 & \verb~134~ & \verb~                toMap [edge] = new Node ((int)x, (int)y, (int)z);~\\
\cellcolor{green} & 4 & \verb~135~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~136~ & \verb~~\\
\cellcolor{green} & 2 & \verb~137~ & \verb~            IndexRebuilt = () => {};~\\
\cellcolor{green} & 1 & \verb~138~ & \verb~            junctionMap.Clear ();~\\
\cellcolor{green} & 1 & \verb~139~ & \verb~            List<Edge> EdgeList = Edges.ToList ();~\\
\cellcolor{green} & 14 & \verb~140~ & \verb~            for (int n = 0; n < EdgeList.Count; n++) {~\\
\cellcolor{green} & 4 & \verb~141~ & \verb~                Edge edgeA = Edges.At (n);~\\
\cellcolor{green} & 4 & \verb~142~ & \verb~                Edge edgeB = Edges.At (n + 1);~\\
\cellcolor{green} & 4 & \verb~143~ & \verb~                Node node = NodeAfterEdge (edgeA);~\\
\cellcolor{green} & 4 & \verb~144~ & \verb~                IJunction junction = new Junction (nodeMap: this, from: edgeA,~\\
\cellcolor{green} & 4 & \verb~145~ & \verb~                junctionMap.Add (node, junction);~\\
\cellcolor{green} & 4 & \verb~146~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~147~ & \verb~~\\
\cellcolor{green} & 1 & \verb~148~ & \verb~            IndexRebuilt ();~\\
\cellcolor{green} & 1 & \verb~149~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~151~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Utilities.FileIndex}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Utilities.FileIndex\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{sers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Utilities\textbackslash FileIndex.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 27\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 27\\
\textbf{Total lines:} & 80\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{Add(...)} & 1 & 100 & 100\\
\hline
\textbf{Remove(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Save()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{sers\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Utilities\textbackslash FileIndex.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Game.Utilities~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    public class FileIndex~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        private HashSet<string> hashes;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        private string filename;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~~\\
\cellcolor{green} & 4 & \verb~44~ & \verb~        public FileIndex (string filename)~\\
\cellcolor{green} & 4 & \verb~45~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~46~ & \verb~            this.filename = filename;~\\
\cellcolor{green} & 4 & \verb~47~ & \verb~            try {~\\
\cellcolor{green} & 4 & \verb~48~ & \verb~                hashes = new HashSet<string> (FileUtility.ReadFrom (filename))~\\
\cellcolor{green} & 2 & \verb~49~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~50~ & \verb~            catch (System.ArgumentException) {~\\
\cellcolor{green} & 1 & \verb~51~ & \verb~                hashes = new HashSet<string> ();~\\
\cellcolor{green} & 1 & \verb~52~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~53~ & \verb~            catch (IOException) {~\\
\cellcolor{green} & 1 & \verb~54~ & \verb~                hashes = new HashSet<string> ();~\\
\cellcolor{green} & 1 & \verb~55~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~56~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~57~ & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        public void Add (string hash)~\\
\cellcolor{green} & 4 & \verb~59~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~60~ & \verb~            hashes.Add (hash);~\\
\cellcolor{green} & 4 & \verb~61~ & \verb~            Save ();~\\
\cellcolor{green} & 3 & \verb~62~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        public void Remove (string hash)~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~            hashes.Remove (hash);~\\
\cellcolor{green} & 1 & \verb~67~ & \verb~            Save ();~\\
\cellcolor{green} & 1 & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        public bool Contains (string hash)~\\
\cellcolor{green} & 9 & \verb~71~ & \verb~        {~\\
\cellcolor{green} & 9 & \verb~72~ & \verb~            return hashes.Contains (hash);~\\
\cellcolor{green} & 9 & \verb~73~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        private void Save ()~\\
\cellcolor{green} & 5 & \verb~76~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~77~ & \verb~            File.WriteAllText (filename, string.Join ("\n", hashes));~\\
\cellcolor{green} & 4 & \verb~78~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Game.Utilities.SavegameLoader`2}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Game.Utilities.SavegameLoader`2\\
\textbf{Assembly:} & Knot3\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Utilities\textbackslash SavegameLoader.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 31\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 31\\
\textbf{Total lines:} & 111\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{FindSavegames(...)} & 1 & 100 & 100\\
\hline
\textbf{AddFileToList(...)} & 3 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash Game\textbackslash Knot3.Game\textbackslash Utilities\textbackslash SavegameLoader.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Knot3.Game.Data;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Game.Utilities~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    public class SavegameLoader<Savegame, SavegameMetaData>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        public ISavegameIO<Savegame, SavegameMetaData> FileFormat { get; set; ~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        public FileIndex fileIndex { get; private set; }~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        public string IndexName;~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        private Action<string, SavegameMetaData> OnSavegameFound;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~~\\
\cellcolor{green} & 2 & \verb~50~ & \verb~        public SavegameLoader (ISavegameIO<Savegame, SavegameMetaData> fileFor~\\
\cellcolor{green} & 2 & \verb~51~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~52~ & \verb~            FileFormat = fileFormat;~\\
\cellcolor{green} & 2 & \verb~53~ & \verb~            IndexName = indexName;~\\
\cellcolor{green} & 2 & \verb~54~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        public void FindSavegames (Action<string, SavegameMetaData> onSavegame~\\
\cellcolor{green} & 2 & \verb~57~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~58~ & \verb~            // Erstelle einen neuen Index, der eine Datei mit dem angegeben In~\\
\cellcolor{green} & 2 & \verb~59~ & \verb~            fileIndex = new FileIndex (SystemInfo.SavegameDirectory + SystemIn~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & \verb~            // Diese Verzeichnisse werden nach Spielständen durchsucht~\\
\cellcolor{green} & 2 & \verb~62~ & \verb~            string[] searchDirectories = new string[] {~\\
\cellcolor{gray} &  & \verb~63~ & \verb~                SystemInfo.BaseDirectory,~\\
\cellcolor{gray} &  & \verb~64~ & \verb~                SystemInfo.SavegameDirectory~\\
\cellcolor{gray} &  & \verb~65~ & \verb~            };~\\
\cellcolor{green} & 2 & \verb~66~ & \verb~            Log.Debug ("Search for Savegames: ", string.Join (", ", searchDire~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~            // Suche nach Spielstanddateien und fülle das Menü auf~\\
\cellcolor{green} & 2 & \verb~69~ & \verb~            OnSavegameFound = onSavegameFound;~\\
\cellcolor{green} & 2 & \verb~70~ & \verb~            FileUtility.SearchFiles (searchDirectories, FileFormat.FileExtensi~\\
\cellcolor{green} & 2 & \verb~71~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// Diese Methode wird für jede gefundene Spielstanddatei aufgerufen~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        private void AddFileToList (string filename)~\\
\cellcolor{green} & 4 & \verb~77~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~78~ & \verb~            // Lese die Datei ein und erstelle einen Hashcode~\\
\cellcolor{green} & 4 & \verb~79~ & \verb~            string hashcode = FileUtility.GetHash (filename);~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~            // Ist dieser Hashcode im Index enthalten?~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            // Dann wäre der Spielstand gültig, sonst ungültig oder unbekannt.~\\
\cellcolor{green} & 4 & \verb~83~ & \verb~            bool isValid = fileIndex.Contains (hashcode);~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~            // Wenn der Spielstand ungültig oder unbekannt ist...~\\
\cellcolor{green} & 6 & \verb~86~ & \verb~            if (!isValid) {~\\
\cellcolor{green} & 2 & \verb~87~ & \verb~                try {~\\
\cellcolor{gray} &  & \verb~88~ & \verb~                    // Lade den Knoten und prüfe, ob Exceptions auftreten~\\
\cellcolor{green} & 2 & \verb~89~ & \verb~                    FileFormat.Load (filename);~\\
\cellcolor{gray} &  & \verb~90~ & \verb~                    // Keine Exceptions? Dann ist enthält die Datei einen gült~\\
\cellcolor{green} & 2 & \verb~91~ & \verb~                    isValid = true;~\\
\cellcolor{green} & 2 & \verb~92~ & \verb~                    fileIndex.Add (hashcode);~\\
\cellcolor{green} & 1 & \verb~93~ & \verb~                }~\\
\cellcolor{green} & 2 & \verb~94~ & \verb~                catch (Exception ex) {~\\
\cellcolor{gray} &  & \verb~95~ & \verb~                    // Es ist eine Exception aufgetreten, der Knoten ist offen~\\
\cellcolor{green} & 1 & \verb~96~ & \verb~                    Log.Debug (ex);~\\
\cellcolor{green} & 1 & \verb~97~ & \verb~                    isValid = false;~\\
\cellcolor{green} & 1 & \verb~98~ & \verb~                }~\\
\cellcolor{green} & 2 & \verb~99~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~            // Falls der Knoten gültig ist, entweder laut Index oder nach Über~\\
\cellcolor{green} & 7 & \verb~102~ & \verb~            if (isValid) {~\\
\cellcolor{gray} &  & \verb~103~ & \verb~                // Lade die Metadaten~\\
\cellcolor{green} & 3 & \verb~104~ & \verb~                SavegameMetaData meta = FileFormat.LoadMetaData (filename);~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & \verb~                // Rufe die Callback-Funktion auf~\\
\cellcolor{green} & 3 & \verb~107~ & \verb~                OnSavegameFound (filename, meta);~\\
\cellcolor{green} & 3 & \verb~108~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~109~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Audio.AudioManager}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Audio.AudioManager\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash AudioManager.cs}\end{minipage} \\
\textbf{Coverage:} & 86.9\%\\
\textbf{Covered lines:} & 80\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 92\\
\textbf{Total lines:} & 204\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{Initialize()} & 1 & 0 & 0\\
\hline
\textbf{Initialize(...)} & 4 & 100 & 71.43\\
\hline
\textbf{Reset()} & 1 & 100 & 100\\
\hline
\textbf{AddOggAudioFile(...)} & 3 & 100 & 80\\
\hline
\textbf{LoadOggAudioFile(...} & 1 & 90 & 100\\
\hline
\textbf{StartBackgroundMusic} & 3 & 81.25 & 80\\
\hline
\textbf{PlaySound(...)} & 2 & 70 & 66.67\\
\hline
\textbf{Volume(...)} & 1 & 0 & 0\\
\hline
\textbf{SetVolume(...)} & 1 & 100 & 100\\
\hline
\textbf{ValidVolume(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash AudioManager.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~~\\
\cellcolor{gray} &  & \verb~44~ & \verb~namespace Knot3.Framework.Audio~\\
\cellcolor{gray} &  & \verb~45~ & \verb~{~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    public abstract class AudioManager : DrawableGameComponent~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Eine Zuordnung zwischen dem Typ der Audiodateien und den Ordnern u~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// in denen sich die Audiodateien befinden.~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// </summary>~\\
\cellcolor{green} & 39 & \verb~52~ & \verb~        public Dictionary<Sound, string> AudioDirectories { get; private set; ~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        // Enthält alle gefunden Audiodateien, sortiert nach ihrem Zweck~\\
\cellcolor{green} & 4 & \verb~55~ & \verb~        private Dictionary<Sound, HashSet<IAudioFile>> AudioFiles = new Dictio~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// Die aktuell verwendete Hintergrundmusik.~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        public Sound BackgroundMusic~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        {~\\
\cellcolor{green} & 9 & \verb~62~ & \verb~            get {~\\
\cellcolor{green} & 9 & \verb~63~ & \verb~                return _backgroundMusic;~\\
\cellcolor{green} & 9 & \verb~64~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~65~ & \verb~            set {~\\
\cellcolor{green} & 6 & \verb~66~ & \verb~                if (value != Sound.None && value != _backgroundMusic) {~\\
\cellcolor{green} & 3 & \verb~67~ & \verb~                    _backgroundMusic = value;~\\
\cellcolor{green} & 3 & \verb~68~ & \verb~                    StartBackgroundMusic ();~\\
\cellcolor{green} & 3 & \verb~69~ & \verb~                }~\\
\cellcolor{green} & 3 & \verb~70~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{green} & 4 & \verb~73~ & \verb~        private Sound _backgroundMusic = Sound.None;~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// Enthält die Playlist, die aktuell abgespielt wird,~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// oder null, falls keine Playlist abgespielt wird.~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// </summary>~\\
\cellcolor{green} & 29 & \verb~79~ & \verb~        public IPlaylist Playlist { get; set; }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{green} & 1 & \verb~81~ & \verb~        private static Dictionary<Sound, float> VolumeMap = new Dictionary<Sou~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        /// Erstellt einen neuen AudioManager für den angegebenen Spielzustand~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~86~ & \verb~        public AudioManager (Game game)~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        : base (game)~\\
\cellcolor{green} & 4 & \verb~88~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~89~ & \verb~            AudioDirectories = new Dictionary<Sound, string> ();~\\
\cellcolor{green} & 4 & \verb~90~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        public override void Initialize ()~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~            Initialize (SystemInfo.RelativeContentDirectory);~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        public virtual void Initialize (string directory)~\\
\cellcolor{green} & 5 & \verb~98~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~99~ & \verb~            if (SystemInfo.IsRunningOnMonogame ()) {~\\
\cellcolor{green} & 5 & \verb~100~ & \verb~                base.Initialize ();~\\
\cellcolor{green} & 5 & \verb~101~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{green} & 10 & \verb~103~ & \verb~            if (AudioFiles.Count == 0) {~\\
\cellcolor{gray} &  & \verb~104~ & \verb~                // Erstelle für alle Enum-Werte von Sound ein HashSet~\\
\cellcolor{green} & 105 & \verb~105~ & \verb~                foreach (Sound soundType in Sound.Values) {~\\
\cellcolor{green} & 30 & \verb~106~ & \verb~                    AudioFiles [soundType] = new HashSet<IAudioFile> ();~\\
\cellcolor{green} & 30 & \verb~107~ & \verb~                    VolumeMap [soundType] = ValidVolume (Config.Default ["volu~\\
\cellcolor{green} & 30 & \verb~108~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & \verb~                // Suche nach OGG-Dateien~\\
\cellcolor{green} & 5 & \verb~111~ & \verb~                FileUtility.SearchFiles (directory, new string[] {".ogg"}, Add~\\
\cellcolor{green} & 5 & \verb~112~ & \verb~            }~\\
\cellcolor{green} & 5 & \verb~113~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & \verb~        public void Reset ()~\\
\cellcolor{green} & 5 & \verb~116~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~117~ & \verb~            AudioFiles.Clear ();~\\
\cellcolor{green} & 5 & \verb~118~ & \verb~            VolumeMap.Clear ();~\\
\cellcolor{green} & 5 & \verb~119~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~120~ & \verb~~\\
\cellcolor{gray} &  & \verb~121~ & \verb~        private void AddOggAudioFile (string filepath)~\\
\cellcolor{green} & 10 & \verb~122~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~123~ & \verb~            filepath = filepath.Replace (@"\", "/");~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{green} & 95 & \verb~125~ & \verb~            foreach (KeyValuePair<Sound,string> pair in AudioDirectories) {~\\
\cellcolor{green} & 25 & \verb~126~ & \verb~                Sound soundType = pair.Key;~\\
\cellcolor{green} & 25 & \verb~127~ & \verb~                string directory = pair.Value;~\\
\cellcolor{green} & 35 & \verb~128~ & \verb~                if (filepath.ToLower ().Contains (directory.ToLower ())) {~\\
\cellcolor{green} & 10 & \verb~129~ & \verb~                    string name = Path.GetFileName (filepath);~\\
\cellcolor{green} & 10 & \verb~130~ & \verb~                    LoadOggAudioFile (filepath, name, soundType);~\\
\cellcolor{green} & 10 & \verb~131~ & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~132~ & \verb~                }~\\
\cellcolor{green} & 15 & \verb~133~ & \verb~            }~\\
\cellcolor{green} & 10 & \verb~134~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        private void LoadOggAudioFile (string filepath, string name, Sound sou~\\
\cellcolor{green} & 10 & \verb~137~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~138~ & \verb~            try {~\\
\cellcolor{gray} &  & \verb~139~ & \verb~                // erstelle ein OggVorbisFile-Objekt~\\
\cellcolor{green} & 10 & \verb~140~ & \verb~                AudioFiles [soundType].Add (new OggVorbisFile (name, filepath,~\\
\cellcolor{red} & 0 & \verb~141~ & \verb~            }~\\
\cellcolor{green} & 20 & \verb~142~ & \verb~            catch (Exception ex) {~\\
\cellcolor{gray} &  & \verb~143~ & \verb~                // egal, warum das laden nicht klappt; mehr als die Fehlermeld~\\
\cellcolor{gray} &  & \verb~144~ & \verb~                // macht wegen einer fehlenden Musikdatei keinen Sinn~\\
\cellcolor{green} & 10 & \verb~145~ & \verb~                Log.Debug ("Failed to load ogg audio file (", soundType, "): "~\\
\cellcolor{green} & 10 & \verb~146~ & \verb~                Log.Debug (ex);~\\
\cellcolor{green} & 10 & \verb~147~ & \verb~            }~\\
\cellcolor{green} & 10 & \verb~148~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~149~ & \verb~~\\
\cellcolor{gray} &  & \verb~150~ & \verb~        private void StartBackgroundMusic ()~\\
\cellcolor{green} & 3 & \verb~151~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~152~ & \verb~            if (Playlist != null) {~\\
\cellcolor{green} & 2 & \verb~153~ & \verb~                Playlist.Stop ();~\\
\cellcolor{green} & 2 & \verb~154~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~155~ & \verb~            Log.Debug ("Background Music: ", BackgroundMusic);~\\
\cellcolor{green} & 6 & \verb~156~ & \verb~            if (AudioFiles.ContainsKey (BackgroundMusic)) {~\\
\cellcolor{green} & 3 & \verb~157~ & \verb~                Playlist = new LoopPlaylist (AudioFiles [BackgroundMusic]);~\\
\cellcolor{green} & 3 & \verb~158~ & \verb~                Playlist.Shuffle ();~\\
\cellcolor{green} & 3 & \verb~159~ & \verb~                Playlist.Start ();~\\
\cellcolor{green} & 3 & \verb~160~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~161~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~                Log.Message ("Warning: ", BackgroundMusic, ": no sound files a~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~164~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        public void PlaySound (Sound sound)~\\
\cellcolor{green} & 2 & \verb~167~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~168~ & \verb~            Log.Debug ("Sound: ", sound);~\\
\cellcolor{green} & 2 & \verb~169~ & \verb~            if (AudioFiles [sound].Count > 0) {~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~                AudioFiles [sound].RandomElement ().Play ();~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~172~ & \verb~            else {~\\
\cellcolor{green} & 2 & \verb~173~ & \verb~                Log.Debug ("There are no audio files for: ", sound);~\\
\cellcolor{green} & 2 & \verb~174~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~175~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~178~ & \verb~        public override void Update (GameTime time)~\\
\cellcolor{gray} &  & \verb~179~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~180~ & \verb~            if (Playlist != null) {~\\
\cellcolor{gray} &  & \verb~181~ & \verb~                Playlist.Update (time);~\\
\cellcolor{gray} &  & \verb~182~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~183~ & \verb~            base.Update (time);~\\
\cellcolor{gray} &  & \verb~184~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~185~ & \verb~~\\
\cellcolor{gray} &  & \verb~186~ & \verb~        public static float Volume (Sound soundType)~\\
\cellcolor{red} & 0 & \verb~187~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~188~ & \verb~            return VolumeMap [soundType];~\\
\cellcolor{red} & 0 & \verb~189~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~190~ & \verb~~\\
\cellcolor{gray} &  & \verb~191~ & \verb~        public static void SetVolume (Sound soundType, float volume)~\\
\cellcolor{green} & 1 & \verb~192~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~193~ & \verb~            volume = ValidVolume (volume);~\\
\cellcolor{green} & 1 & \verb~194~ & \verb~            VolumeMap [soundType] = volume;~\\
\cellcolor{green} & 1 & \verb~195~ & \verb~            Config.Default ["volume", soundType.ToString (), 1] = volume;~\\
\cellcolor{green} & 1 & \verb~196~ & \verb~            Log.Debug ("Set Volume (", soundType, "): ", volume);~\\
\cellcolor{green} & 1 & \verb~197~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~198~ & \verb~~\\
\cellcolor{gray} &  & \verb~199~ & \verb~        public static float ValidVolume (float volume)~\\
\cellcolor{green} & 31 & \verb~200~ & \verb~        {~\\
\cellcolor{green} & 31 & \verb~201~ & \verb~            return MathHelper.Clamp (volume, 0.0f, 2.0f);~\\
\cellcolor{green} & 31 & \verb~202~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~203~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~204~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Audio.LoopPlaylist}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Audio.LoopPlaylist\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash LoopPlaylist.cs}\end{minipage} \\
\textbf{Coverage:} & 69.2\%\\
\textbf{Covered lines:} & 18\\
\textbf{Uncovered lines:} & 8\\
\textbf{Coverable lines:} & 26\\
\textbf{Total lines:} & 116\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 71.43 & 66.67\\
\hline
\textbf{Shuffle()} & 1 & 100 & 100\\
\hline
\textbf{Start()} & 2 & 42.86 & 66.67\\
\hline
\textbf{Stop()} & 2 & 42.86 & 66.67\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash LoopPlaylist.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & \verb~namespace Knot3.Framework.Audio~\\
\cellcolor{gray} &  & \verb~42~ & \verb~{~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    /// Diese Klasse repräsentiert eine Playlist, deren Audiodateien der reihe~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// Endlosschleife abgespielt werden.~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    public class LoopPlaylist : IPlaylist~\\
\cellcolor{gray} &  & \verb~48~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        private List<IAudioFile> Sounds;~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        private int index;~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{green} & 3 & \verb~52~ & \verb~        public SoundState State { get; private set; }~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// Erstellt eine neue Playlist.~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// <param name='sounds'>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// Die abzuspielenden Audiodateien.~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// </param>~\\
\cellcolor{green} & 3 & \verb~60~ & \verb~        public LoopPlaylist (IEnumerable<IAudioFile> sounds)~\\
\cellcolor{green} & 3 & \verb~61~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~62~ & \verb~            Sounds = sounds.ToList ();~\\
\cellcolor{green} & 3 & \verb~63~ & \verb~            index = 0;~\\
\cellcolor{green} & 3 & \verb~64~ & \verb~            State = SoundState.Stopped;~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{green} & 3 & \verb~66~ & \verb~            Log.Debug ("Created new playlist (", Sounds.Count, " songs)");~\\
\cellcolor{green} & 9 & \verb~67~ & \verb~            foreach (IAudioFile sound in Sounds) {~\\
\cellcolor{red} & 0 & \verb~68~ & \verb~                Log.Debug ("  - ", sound.Name);~\\
\cellcolor{red} & 0 & \verb~69~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~70~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        public void Shuffle ()~\\
\cellcolor{green} & 3 & \verb~73~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~74~ & \verb~            Sounds = Sounds.Shuffle ().ToList ();~\\
\cellcolor{green} & 3 & \verb~75~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// Starte die Wiedergabe.~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        public void Start ()~\\
\cellcolor{green} & 3 & \verb~81~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~82~ & \verb~            if (Sounds.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~83~ & \verb~                State = SoundState.Playing;~\\
\cellcolor{red} & 0 & \verb~84~ & \verb~                Sounds .At (index).Play ();~\\
\cellcolor{red} & 0 & \verb~85~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~86~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        /// Stoppe die Wiedergabe.~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        public void Stop ()~\\
\cellcolor{green} & 2 & \verb~92~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~93~ & \verb~            if (Sounds.Count > 0) {~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~                State = SoundState.Stopped;~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~                Sounds.At (index).Stop ();~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~97~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        /// Wird für jeden Frame aufgerufen.~\\
\cellcolor{gray} &  & \verb~101~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~102~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        public void Update (GameTime time)~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~105~ & \verb~            if (Sounds.Count > 0) {~\\
\cellcolor{gray} &  & \verb~106~ & \verb~                if (State == SoundState.Playing && Sounds.At (index).State != ~\\
\cellcolor{gray} &  & \verb~107~ & \verb~                    ++index;~\\
\cellcolor{gray} &  & \verb~108~ & \verb~                    Sounds.At (index).Play ();~\\
\cellcolor{gray} &  & \verb~109~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~            if (index >= 0 && index < Sounds.Count) {~\\
\cellcolor{gray} &  & \verb~112~ & \verb~                Sounds.At (index).Update (time);~\\
\cellcolor{gray} &  & \verb~113~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Audio.OggVorbisFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Audio.OggVorbisFile\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash OggVorbisFile.cs}\end{minipage} \\
\textbf{Coverage:} & 86\%\\
\textbf{Covered lines:} & 43\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 50\\
\textbf{Total lines:} & 129\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 7 & 90.62 & 63.64\\
\hline
\textbf{Stop()} & 1 & 0 & 0\\
\hline
\textbf{WriteWave(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash OggVorbisFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using OggSharp;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & \verb~namespace Knot3.Framework.Audio~\\
\cellcolor{gray} &  & \verb~44~ & \verb~{~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    public class OggVorbisFile : IAudioFile~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    {~\\
\cellcolor{green} & 10 & \verb~47~ & \verb~        public string Name { get; private set; }~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{red} & 0 & \verb~49~ & \verb~        public SoundState State { get { return internalFile.State; } }~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        private SoundEffectFile internalFile;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{green} & 10 & \verb~53~ & \verb~        public OggVorbisFile (string name, string filepath, Sound soundType)~\\
\cellcolor{green} & 10 & \verb~54~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~55~ & \verb~            Name = name;~\\
\cellcolor{green} & 10 & \verb~56~ & \verb~            string cachefile = SystemInfo.DecodedMusicCache~\\
\cellcolor{gray} &  & \verb~57~ & \verb~                               + SystemInfo.PathSeparator.ToString ()~\\
\cellcolor{gray} &  & \verb~58~ & \verb~                               + soundType.ToString ()~\\
\cellcolor{gray} &  & \verb~59~ & \verb~                               + "_"~\\
\cellcolor{gray} &  & \verb~60~ & \verb~                               + name.GetHashCode ().ToString ()~\\
\cellcolor{gray} &  & \verb~61~ & \verb~                               + ".wav";~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{green} & 10 & \verb~63~ & \verb~            Log.BlockList (id: 33, before: "  - ", after: "", begin: "Load ogg~\\
\cellcolor{green} & 10 & \verb~64~ & \verb~            Log.BlockList (id: 34, before: "  - ", after: "", begin: "Decode o~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~            byte[] data;~\\
\cellcolor{green} & 10 & \verb~67~ & \verb~            try {~\\
\cellcolor{green} & 10 & \verb~68~ & \verb~                Log.ListElement (33, "[", soundType, "] ", name);~\\
\cellcolor{green} & 10 & \verb~69~ & \verb~                data = File.ReadAllBytes (cachefile);~\\
\cellcolor{green} & 8 & \verb~70~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~71~ & \verb~            catch (Exception) {~\\
\cellcolor{green} & 2 & \verb~72~ & \verb~                Log.ListElement (34, "[", soundType, "] ", name);~\\
\cellcolor{green} & 2 & \verb~73~ & \verb~                OggDecoder decoder = new OggDecoder ();~\\
\cellcolor{green} & 2 & \verb~74~ & \verb~                decoder.Initialize (TitleContainer.OpenStream (filepath));~\\
\cellcolor{green} & 16 & \verb~75~ & \verb~                data = decoder.SelectMany (chunk => chunk.Bytes.Take (chunk.Le~\\
\cellcolor{green} & 2 & \verb~76~ & \verb~                using (MemoryStream stream = new MemoryStream ())~\\
\cellcolor{green} & 4 & \verb~77~ & \verb~                using (BinaryWriter writer = new BinaryWriter (stream)) {~\\
\cellcolor{green} & 2 & \verb~78~ & \verb~                    WriteWave (writer, decoder.Stereo ? 2 : 1, decoder.SampleR~\\
\cellcolor{green} & 2 & \verb~79~ & \verb~                    stream.Position = 0;~\\
\cellcolor{green} & 2 & \verb~80~ & \verb~                    data = stream.ToArray ();~\\
\cellcolor{green} & 2 & \verb~81~ & \verb~                }~\\
\cellcolor{green} & 2 & \verb~82~ & \verb~                File.WriteAllBytes (cachefile, data);~\\
\cellcolor{green} & 2 & \verb~83~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{green} & 20 & \verb~85~ & \verb~            using (MemoryStream stream = new MemoryStream (data)) {~\\
\cellcolor{green} & 10 & \verb~86~ & \verb~                stream.Position = 0;~\\
\cellcolor{green} & 10 & \verb~87~ & \verb~                SoundEffect soundEffect = SoundEffect.FromStream (stream);~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~                internalFile = new SoundEffectFile (name, soundEffect, soundTy~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        public void Play ()~\\
\cellcolor{gray} &  & \verb~94~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~95~ & \verb~            internalFile.Play ();~\\
\cellcolor{gray} &  & \verb~96~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        public void Stop ()~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~            internalFile.Stop ();~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        public void Update (GameTime time)~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~106~ & \verb~            internalFile.Update (time);~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~108~ & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        private static void WriteWave (BinaryWriter writer, int channels, int ~\\
\cellcolor{green} & 2 & \verb~110~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~111~ & \verb~            writer.Write (new char [4] { 'R', 'I', 'F', 'F' });~\\
\cellcolor{green} & 2 & \verb~112~ & \verb~            writer.Write ((int)(36 + data.Length));~\\
\cellcolor{green} & 2 & \verb~113~ & \verb~            writer.Write (new char [4] { 'W', 'A', 'V', 'E' });~\\
\cellcolor{gray} &  & \verb~114~ & \verb~~\\
\cellcolor{green} & 2 & \verb~115~ & \verb~            writer.Write (new char [4] { 'f', 'm', 't', ' ' });~\\
\cellcolor{green} & 2 & \verb~116~ & \verb~            writer.Write ((int)16);~\\
\cellcolor{green} & 2 & \verb~117~ & \verb~            writer.Write ((short)1);~\\
\cellcolor{green} & 2 & \verb~118~ & \verb~            writer.Write ((short)channels);~\\
\cellcolor{green} & 2 & \verb~119~ & \verb~            writer.Write ((int)rate);~\\
\cellcolor{green} & 2 & \verb~120~ & \verb~            writer.Write ((int)(rate * ((16 * channels) / 8)));~\\
\cellcolor{green} & 2 & \verb~121~ & \verb~            writer.Write ((short)((16 * channels) / 8));~\\
\cellcolor{green} & 2 & \verb~122~ & \verb~            writer.Write ((short)16);~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{green} & 2 & \verb~124~ & \verb~            writer.Write (new char [4] { 'd', 'a', 't', 'a' });~\\
\cellcolor{green} & 2 & \verb~125~ & \verb~            writer.Write ((int)data.Length);~\\
\cellcolor{green} & 2 & \verb~126~ & \verb~            writer.Write (data);~\\
\cellcolor{green} & 2 & \verb~127~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Audio.SilentAudioManager}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Audio.SilentAudioManager\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{uments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash SilentAudioManager.cs}\end{minipage} \\
\textbf{Coverage:} & 0\%\\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 6\\
\textbf{Total lines:} & 53\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{Initialize(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{uments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash SilentAudioManager.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Knot3.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Framework.Audio~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    public class SilentAudioManager : AudioManager~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    {~\\
\cellcolor{red} & 0 & \verb~41~ & \verb~        public SilentAudioManager (GameCore game)~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        : base (game)~\\
\cellcolor{red} & 0 & \verb~43~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~44~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public override void Initialize (string directory)~\\
\cellcolor{red} & 0 & \verb~47~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~48~ & \verb~            // no directories are initialized -> no audio files will be detect~\\
\cellcolor{gray} &  & \verb~49~ & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & \verb~            base.Initialize (directory);~\\
\cellcolor{red} & 0 & \verb~51~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~52~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~53~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Audio.Sound}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Audio.Sound\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{rs\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash Sound.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 4\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 4\\
\textbf{Total lines:} & 52\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{rs\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Audio\textbackslash Sound.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Framework.Audio~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public class Sound : TypesafeEnum<Sound>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// Kein Sound.~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~45~ & \verb~        public static readonly Sound None = new Sound ("None");~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{green} & 6 & \verb~47~ & \verb~        public Sound (string name)~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        : base (name)~\\
\cellcolor{green} & 6 & \verb~49~ & \verb~        {~\\
\cellcolor{green} & 6 & \verb~50~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~51~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~52~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Core.Camera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Core.Camera\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{rs\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Core\textbackslash Camera.cs}\end{minipage} \\
\textbf{Coverage:} & 65.3\%\\
\textbf{Covered lines:} & 83\\
\textbf{Uncovered lines:} & 44\\
\textbf{Coverable lines:} & 127\\
\textbf{Total lines:} & 352\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 100\\
\hline
\textbf{UpdateMatrices(...)} & 1 & 100 & 100\\
\hline
\textbf{GetMouseRay(...)} & 1 & 0 & 0\\
\hline
\textbf{ResetCamera()} & 1 & 100 & 100\\
\hline
\textbf{StartSmoothMove(...)} & 2 & 0 & 0\\
\hline
\textbf{UpdateSmoothMove(...} & 2 & 0 & 0\\
\hline
\textbf{To3D(...)} & 2 & 100 & 100\\
\hline
\textbf{To2D(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{rs\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Core\textbackslash Camera.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Knot3.Framework.Math;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Knot3.Framework.Storage;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & \verb~namespace Knot3.Framework.Core~\\
\cellcolor{gray} &  & \verb~42~ & \verb~{~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    /// Jede Instanz der World-Klasse hält eine für diese Spielwelt verwendete~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    /// Die Hauptfunktion der Kamera-Klasse ist das Berechnen der drei Matrize~\\
\cellcolor{gray} &  & \verb~46~ & \verb~    /// und Skalierung von 3D-Objekten in einer bestimmten Spielwelt benötigt ~\\
\cellcolor{gray} &  & \verb~47~ & \verb~    /// Um diese Matrizen zu berechnen, benötigt die Kamera unter Anderem Info~\\
\cellcolor{gray} &  & \verb~48~ & \verb~    /// das aktuelle Kamera-Ziel und das Field of View.~\\
\cellcolor{gray} &  & \verb~49~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~50~ & \verb~    public sealed class Camera : ScreenComponent~\\
\cellcolor{gray} &  & \verb~51~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        private Vector3 _position;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// Die Position der Kamera.~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        public Vector3 Position~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        {~\\
\cellcolor{green} & 75 & \verb~59~ & \verb~            get { return _position; }~\\
\cellcolor{green} & 16 & \verb~60~ & \verb~            set {~\\
\cellcolor{green} & 16 & \verb~61~ & \verb~                OnViewChanged ();~\\
\cellcolor{green} & 16 & \verb~62~ & \verb~                if ((value.X.Abs () <= MaxPositionDistance && value.Y.Abs () <~\\
\cellcolor{green} & 16 & \verb~63~ & \verb~                        && value.Z.Abs () <= MaxPositionDistance) || MaxPositi~\\
\cellcolor{green} & 16 & \verb~64~ & \verb~                    _position = value;~\\
\cellcolor{green} & 16 & \verb~65~ & \verb~                }~\\
\cellcolor{green} & 16 & \verb~66~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        private Vector3 _target;~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        /// Das Ziel der Kamera.~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        public Vector3 Target~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        {~\\
\cellcolor{green} & 81 & \verb~76~ & \verb~            get { return _target; }~\\
\cellcolor{green} & 12 & \verb~77~ & \verb~            set {~\\
\cellcolor{green} & 12 & \verb~78~ & \verb~                OnViewChanged ();~\\
\cellcolor{green} & 12 & \verb~79~ & \verb~                _target = value;~\\
\cellcolor{green} & 12 & \verb~80~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        private float _foV;~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        /// Das Sichtfeld.~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        public float FoV~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        {~\\
\cellcolor{green} & 36 & \verb~90~ & \verb~            get { return _foV; }~\\
\cellcolor{green} & 11 & \verb~91~ & \verb~            set {~\\
\cellcolor{green} & 11 & \verb~92~ & \verb~                _foV = MathHelper.Clamp (value, 10, 70);~\\
\cellcolor{green} & 11 & \verb~93~ & \verb~                OnViewChanged ();~\\
\cellcolor{green} & 11 & \verb~94~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        /// Die View-Matrix wird über die statische Methode CreateLookAt der K~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        /// mit Matrix.CreateLookAt (Position, Target, Vector3.Up) berechnet.~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        /// </summary>~\\
\cellcolor{green} & 23 & \verb~101~ & \verb~        public Matrix ViewMatrix { get; private set; }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        /// Die World-Matrix wird mit Matrix.CreateFromYawPitchRoll und den dr~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        /// </summary>~\\
\cellcolor{green} & 12 & \verb~106~ & \verb~        public Matrix WorldMatrix { get; private set; }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        /// Die Projektionsmatrix wird über die statische XNA-Methode Matrix.C~\\
\cellcolor{gray} &  & \verb~110~ & \verb~        /// </summary>~\\
\cellcolor{green} & 23 & \verb~111~ & \verb~        public Matrix ProjectionMatrix { get; private set; }~\\
\cellcolor{gray} &  & \verb~112~ & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~114~ & \verb~        /// Berechnet ein Bounding-Frustum, das benötigt wird, um festzustelle~\\
\cellcolor{gray} &  & \verb~115~ & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~116~ & \verb~        public BoundingFrustum ViewFrustum { get; private set; }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~119~ & \verb~        /// Eine Referenz auf die Spielwelt, für welche die Kamera zuständig i~\\
\cellcolor{gray} &  & \verb~120~ & \verb~        /// </summary>~\\
\cellcolor{green} & 29 & \verb~121~ & \verb~        private World World { get; set; }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~124~ & \verb~        /// Die Rotationswinkel.~\\
\cellcolor{gray} &  & \verb~125~ & \verb~        /// </summary>~\\
\cellcolor{green} & 34 & \verb~126~ & \verb~        public Angles3 Rotation { get; set; }~\\
\cellcolor{gray} &  & \verb~127~ & \verb~~\\
\cellcolor{green} & 16 & \verb~128~ & \verb~        public Vector3 UpVector { get; private set; }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{green} & 56 & \verb~130~ & \verb~        public float MaxPositionDistance { get; set; }~\\
\cellcolor{gray} &  & \verb~131~ & \verb~~\\
\cellcolor{green} & 47 & \verb~132~ & \verb~        public Action OnViewChanged = () => {};~\\
\cellcolor{gray} &  & \verb~133~ & \verb~        private float aspectRatio;~\\
\cellcolor{gray} &  & \verb~134~ & \verb~        private float nearPlane;~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        private float farPlane;~\\
\cellcolor{green} & 8 & \verb~136~ & \verb~        private Vector3 defaultPosition = new Vector3 (400, 400, 700);~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~139~ & \verb~        /// Erstellt eine neue Kamera in einem bestimmten IGameScreen für eine~\\
\cellcolor{gray} &  & \verb~140~ & \verb~        /// </summary>~\\
\cellcolor{green} & 8 & \verb~141~ & \verb~        public Camera (IScreen screen, World world)~\\
\cellcolor{gray} &  & \verb~142~ & \verb~        : base (screen, DisplayLayer.None)~\\
\cellcolor{green} & 8 & \verb~143~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~144~ & \verb~            World = world;~\\
\cellcolor{green} & 8 & \verb~145~ & \verb~            Position = defaultPosition;~\\
\cellcolor{green} & 8 & \verb~146~ & \verb~            Target = Vector3.Zero;~\\
\cellcolor{green} & 8 & \verb~147~ & \verb~            UpVector = Vector3.Up;~\\
\cellcolor{green} & 8 & \verb~148~ & \verb~            Rotation = Angles3.Zero;~\\
\cellcolor{green} & 8 & \verb~149~ & \verb~            MaxPositionDistance = 5000;~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{green} & 8 & \verb~151~ & \verb~            FoV = 60;~\\
\cellcolor{green} & 8 & \verb~152~ & \verb~            nearPlane = 0.5f;~\\
\cellcolor{green} & 8 & \verb~153~ & \verb~            farPlane = 15000.0f;~\\
\cellcolor{gray} &  & \verb~154~ & \verb~~\\
\cellcolor{green} & 8 & \verb~155~ & \verb~            UpdateMatrices (null);~\\
\cellcolor{green} & 8 & \verb~156~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~157~ & \verb~~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~159~ & \verb~        /// Die Blickrichtung.~\\
\cellcolor{gray} &  & \verb~160~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~161~ & \verb~        public Vector3 PositionToTargetDirection~\\
\cellcolor{gray} &  & \verb~162~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~                return Vector3.Normalize (Target - Position);~\\
\cellcolor{red} & 0 & \verb~165~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~167~ & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & \verb~        public Vector3 PositionToArcballTargetDirection~\\
\cellcolor{gray} &  & \verb~169~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~170~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~171~ & \verb~                return Vector3.Normalize (ArcballTarget - Position);~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~173~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~174~ & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~176~ & \verb~        /// Der Abstand zwischen der Kamera und dem Kamera-Ziel.~\\
\cellcolor{gray} &  & \verb~177~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~178~ & \verb~        public float PositionToTargetDistance~\\
\cellcolor{gray} &  & \verb~179~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~180~ & \verb~            get {~\\
\cellcolor{green} & 4 & \verb~181~ & \verb~                return Position.DistanceTo (Target);~\\
\cellcolor{green} & 4 & \verb~182~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~183~ & \verb~            set {~\\
\cellcolor{green} & 4 & \verb~184~ & \verb~                Position = Position.SetDistanceTo (Target, value);~\\
\cellcolor{green} & 4 & \verb~185~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~187~ & \verb~~\\
\cellcolor{gray} &  & \verb~188~ & \verb~        public float PositionToArcballTargetDistance~\\
\cellcolor{gray} &  & \verb~189~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~190~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~191~ & \verb~                return Position.DistanceTo (ArcballTarget);~\\
\cellcolor{red} & 0 & \verb~192~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~193~ & \verb~            set {~\\
\cellcolor{red} & 0 & \verb~194~ & \verb~                Position = Position.SetDistanceTo (ArcballTarget, value);~\\
\cellcolor{red} & 0 & \verb~195~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~197~ & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~199~ & \verb~        /// Wird für jeden Frame aufgerufen.~\\
\cellcolor{gray} &  & \verb~200~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~201~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~202~ & \verb~        public override void Update (GameTime time)~\\
\cellcolor{gray} &  & \verb~203~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~204~ & \verb~            // Setze den Viewport auf den der aktuellen Spielwelt~\\
\cellcolor{gray} &  & \verb~205~ & \verb~            Viewport original = Screen.Viewport;~\\
\cellcolor{gray} &  & \verb~206~ & \verb~            Screen.Viewport = World.Viewport;~\\
\cellcolor{gray} &  & \verb~207~ & \verb~~\\
\cellcolor{gray} &  & \verb~208~ & \verb~            UpdateMatrices (time);~\\
\cellcolor{gray} &  & \verb~209~ & \verb~            UpdateSmoothMove (time);~\\
\cellcolor{gray} &  & \verb~210~ & \verb~~\\
\cellcolor{gray} &  & \verb~211~ & \verb~            // Setze den Viewport wieder auf den ganzen Screen~\\
\cellcolor{gray} &  & \verb~212~ & \verb~            Screen.Viewport = original;~\\
\cellcolor{gray} &  & \verb~213~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~214~ & \verb~~\\
\cellcolor{gray} &  & \verb~215~ & \verb~        private void UpdateMatrices (GameTime time)~\\
\cellcolor{green} & 8 & \verb~216~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~217~ & \verb~            aspectRatio = Screen.Viewport.AspectRatio;~\\
\cellcolor{green} & 8 & \verb~218~ & \verb~            farPlane = MaxPositionDistance * 4;~\\
\cellcolor{green} & 8 & \verb~219~ & \verb~            ViewMatrix = Matrix.CreateLookAt (Position, Target, UpVector);~\\
\cellcolor{green} & 8 & \verb~220~ & \verb~            WorldMatrix = Matrix.CreateFromYawPitchRoll (Rotation.Y, Rotation.~\\
\cellcolor{green} & 8 & \verb~221~ & \verb~            ProjectionMatrix = Matrix.CreatePerspectiveFieldOfView (MathHelper~\\
\cellcolor{green} & 8 & \verb~222~ & \verb~            ViewFrustum = new BoundingFrustum (ViewMatrix * ProjectionMatrix);~\\
\cellcolor{green} & 8 & \verb~223~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~224~ & \verb~~\\
\cellcolor{gray} &  & \verb~225~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~226~ & \verb~        /// Berechnet einen Strahl für die angegebenene 2D-Mausposition.~\\
\cellcolor{gray} &  & \verb~227~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~228~ & \verb~        public Ray GetMouseRay (ScreenPoint mousePosition)~\\
\cellcolor{red} & 0 & \verb~229~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~            Viewport viewport = World.Viewport;~\\
\cellcolor{gray} &  & \verb~231~ & \verb~~\\
\cellcolor{red} & 0 & \verb~232~ & \verb~            Vector3 nearPoint = new Vector3 (mousePosition.AbsoluteVector, 0);~\\
\cellcolor{red} & 0 & \verb~233~ & \verb~            Vector3 farPoint = new Vector3 (mousePosition.AbsoluteVector, 1);~\\
\cellcolor{gray} &  & \verb~234~ & \verb~~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~            nearPoint = viewport.Unproject (nearPoint, ProjectionMatrix, ViewM~\\
\cellcolor{red} & 0 & \verb~236~ & \verb~            farPoint = viewport.Unproject (farPoint, ProjectionMatrix, ViewMat~\\
\cellcolor{gray} &  & \verb~237~ & \verb~~\\
\cellcolor{red} & 0 & \verb~238~ & \verb~            Vector3 direction = farPoint - nearPoint;~\\
\cellcolor{red} & 0 & \verb~239~ & \verb~            direction.Normalize ();~\\
\cellcolor{gray} &  & \verb~240~ & \verb~~\\
\cellcolor{red} & 0 & \verb~241~ & \verb~            return new Ray (nearPoint, direction);~\\
\cellcolor{red} & 0 & \verb~242~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~243~ & \verb~~\\
\cellcolor{gray} &  & \verb~244~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~245~ & \verb~        /// Eine Position, um die rotiert werden soll, wenn der User die recht~\\
\cellcolor{gray} &  & \verb~246~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~247~ & \verb~        public Vector3 ArcballTarget~\\
\cellcolor{gray} &  & \verb~248~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~249~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~250~ & \verb~                if (World.SelectedObject != null) {~\\
\cellcolor{red} & 0 & \verb~251~ & \verb~                    return World.SelectedObject.Center ();~\\
\cellcolor{gray} &  & \verb~252~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~253~ & \verb~                else {~\\
\cellcolor{red} & 0 & \verb~254~ & \verb~                    return Vector3.Zero;~\\
\cellcolor{gray} &  & \verb~255~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~256~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~257~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~258~ & \verb~~\\
\cellcolor{gray} &  & \verb~259~ & \verb~        public void ResetCamera ()~\\
\cellcolor{green} & 2 & \verb~260~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~261~ & \verb~            Position = defaultPosition;~\\
\cellcolor{green} & 2 & \verb~262~ & \verb~            Target = new Vector3 (0, 0, 0);~\\
\cellcolor{green} & 2 & \verb~263~ & \verb~            Rotation = Angles3.Zero;~\\
\cellcolor{green} & 2 & \verb~264~ & \verb~            FoV = 45;~\\
\cellcolor{green} & 2 & \verb~265~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~266~ & \verb~~\\
\cellcolor{green} & 8 & \verb~267~ & \verb~        private Vector3? smoothTarget = null;~\\
\cellcolor{green} & 8 & \verb~268~ & \verb~        private float smoothDistance = 0f;~\\
\cellcolor{green} & 8 & \verb~269~ & \verb~        private float smoothProgress = 0f;~\\
\cellcolor{gray} &  & \verb~270~ & \verb~~\\
\cellcolor{gray} &  & \verb~271~ & \verb~        public void StartSmoothMove (Vector3 target, GameTime time)~\\
\cellcolor{red} & 0 & \verb~272~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~273~ & \verb~            if (!InSmoothMove) {~\\
\cellcolor{red} & 0 & \verb~274~ & \verb~                smoothTarget = target;~\\
\cellcolor{red} & 0 & \verb~275~ & \verb~                smoothDistance = System.Math.Abs (Target.DistanceTo (target));~\\
\cellcolor{red} & 0 & \verb~276~ & \verb~                smoothProgress = 0f;~\\
\cellcolor{red} & 0 & \verb~277~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~278~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~279~ & \verb~~\\
\cellcolor{red} & 0 & \verb~280~ & \verb~        public bool InSmoothMove { get { return smoothTarget.HasValue && smoot~\\
\cellcolor{gray} &  & \verb~281~ & \verb~~\\
\cellcolor{gray} &  & \verb~282~ & \verb~        private void UpdateSmoothMove (GameTime time)~\\
\cellcolor{red} & 0 & \verb~283~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~284~ & \verb~            if (InSmoothMove) {~\\
\cellcolor{red} & 0 & \verb~285~ & \verb~                float distance = MathHelper.SmoothStep (0, smoothDistance, smo~\\
\cellcolor{gray} &  & \verb~286~ & \verb~~\\
\cellcolor{red} & 0 & \verb~287~ & \verb~                smoothProgress += 0.05f;~\\
\cellcolor{gray} &  & \verb~288~ & \verb~~\\
\cellcolor{gray} &  & \verb~289~ & \verb~                //Log.Debug ("distance = ", distance);~\\
\cellcolor{red} & 0 & \verb~290~ & \verb~                Target = Target.SetDistanceTo (target: smoothTarget.Value, dis~\\
\cellcolor{red} & 0 & \verb~291~ & \verb~                World.Redraw = true;~\\
\cellcolor{red} & 0 & \verb~292~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~293~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~294~ & \verb~~\\
\cellcolor{gray} &  & \verb~295~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~296~ & \verb~        /// Berechne aus einer 2D-Positon (z.b. Mausposition) die entsprechend~\\
\cellcolor{gray} &  & \verb~297~ & \verb~        /// Für die fehlende dritte Koordinate wird eine Angabe einer weiteren~\\
\cellcolor{gray} &  & \verb~298~ & \verb~        /// mit der die 3D-(Maus-)Position auf der selben Ebene liegen soll.~\\
\cellcolor{gray} &  & \verb~299~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~300~ & \verb~        public Vector3 To3D (ScreenPoint position, Vector3 nearTo)~\\
\cellcolor{green} & 2 & \verb~301~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~302~ & \verb~            if (Config.Default ["debug", "unproject", "SelectedObject"] == "Ne~\\
\cellcolor{green} & 1 & \verb~303~ & \verb~                Vector3 nearScreenPoint = new Vector3 (position.AbsoluteVector~\\
\cellcolor{green} & 1 & \verb~304~ & \verb~                Vector3 farScreenPoint = new Vector3 (position.AbsoluteVector,~\\
\cellcolor{green} & 1 & \verb~305~ & \verb~                Vector3 nearWorldPoint = World.Viewport.Unproject (~\\
\cellcolor{gray} &  & \verb~306~ & \verb~                                             source: nearScreenPoint,~\\
\cellcolor{gray} &  & \verb~307~ & \verb~                                             projection: World.Camera.Projecti~\\
\cellcolor{gray} &  & \verb~308~ & \verb~                                             view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~309~ & \verb~                                             world: Matrix.Identity~\\
\cellcolor{gray} &  & \verb~310~ & \verb~                                         );~\\
\cellcolor{green} & 1 & \verb~311~ & \verb~                Vector3 farWorldPoint = World.Viewport.Unproject (~\\
\cellcolor{gray} &  & \verb~312~ & \verb~                                            source: farScreenPoint,~\\
\cellcolor{gray} &  & \verb~313~ & \verb~                                            projection: World.Camera.Projectio~\\
\cellcolor{gray} &  & \verb~314~ & \verb~                                            view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~315~ & \verb~                                            world: Matrix.Identity~\\
\cellcolor{gray} &  & \verb~316~ & \verb~                                        );~\\
\cellcolor{gray} &  & \verb~317~ & \verb~~\\
\cellcolor{green} & 1 & \verb~318~ & \verb~                Vector3 direction = farWorldPoint - nearWorldPoint;~\\
\cellcolor{gray} &  & \verb~319~ & \verb~~\\
\cellcolor{green} & 1 & \verb~320~ & \verb~                float zFactor = -nearWorldPoint.Y / direction.Y;~\\
\cellcolor{green} & 1 & \verb~321~ & \verb~                Vector3 zeroWorldPoint = nearWorldPoint + direction * zFactor;~\\
\cellcolor{green} & 1 & \verb~322~ & \verb~                return zeroWorldPoint;~\\
\cellcolor{gray} &  & \verb~323~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~324~ & \verb~            else {~\\
\cellcolor{green} & 1 & \verb~325~ & \verb~                Vector3 screenLocation = World.Viewport.Project (~\\
\cellcolor{gray} &  & \verb~326~ & \verb~                                             source: nearTo,~\\
\cellcolor{gray} &  & \verb~327~ & \verb~                                             projection: World.Camera.Projecti~\\
\cellcolor{gray} &  & \verb~328~ & \verb~                                             view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~329~ & \verb~                                             world: World.Camera.WorldMatrix~\\
\cellcolor{gray} &  & \verb~330~ & \verb~                                         );~\\
\cellcolor{green} & 1 & \verb~331~ & \verb~                Vector3 currentMousePosition = World.Viewport.Unproject (~\\
\cellcolor{gray} &  & \verb~332~ & \verb~                                                   source: new Vector3 (positi~\\
\cellcolor{gray} &  & \verb~333~ & \verb~                                                   projection: World.Camera.Pr~\\
\cellcolor{gray} &  & \verb~334~ & \verb~                                                   view: World.Camera.ViewMatr~\\
\cellcolor{gray} &  & \verb~335~ & \verb~                                                   world: Matrix.Identity~\\
\cellcolor{gray} &  & \verb~336~ & \verb~                                               );~\\
\cellcolor{green} & 1 & \verb~337~ & \verb~                return currentMousePosition;~\\
\cellcolor{gray} &  & \verb~338~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~339~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~340~ & \verb~~\\
\cellcolor{gray} &  & \verb~341~ & \verb~        public Vector2 To2D (Vector3 position)~\\
\cellcolor{green} & 2 & \verb~342~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~343~ & \verb~            Vector3 screenLocation = World.Viewport.Project (~\\
\cellcolor{gray} &  & \verb~344~ & \verb~                                         source: position,~\\
\cellcolor{gray} &  & \verb~345~ & \verb~                                         projection: World.Camera.ProjectionMa~\\
\cellcolor{gray} &  & \verb~346~ & \verb~                                         view: World.Camera.ViewMatrix,~\\
\cellcolor{gray} &  & \verb~347~ & \verb~                                         world: World.Camera.WorldMatrix~\\
\cellcolor{gray} &  & \verb~348~ & \verb~                                     );~\\
\cellcolor{green} & 2 & \verb~349~ & \verb~            return new Vector2 (screenLocation.X, screenLocation.Y);~\\
\cellcolor{green} & 2 & \verb~350~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~351~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~352~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Core.DisplayLayer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Core.DisplayLayer\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Core\textbackslash DisplayLayer.cs}\end{minipage} \\
\textbf{Coverage:} & 98.1\%\\
\textbf{Covered lines:} & 52\\
\textbf{Uncovered lines:} & 1\\
\textbf{Coverable lines:} & 53\\
\textbf{Total lines:} & 169\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 88.89 & 71.43\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Core\textbackslash DisplayLayer.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Knot3.Framework.Widgets;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~namespace Knot3.Framework.Core~\\
\cellcolor{gray} &  & \verb~37~ & \verb~{~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// Die Zeichenreihenfolge der Elemente der grafischen Benutzeroberfläche.~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    public class DisplayLayer : IEquatable<DisplayLayer>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// Steht für die hinterste Ebene bei der Zeichenreihenfolge.~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~46~ & \verb~        public static readonly DisplayLayer None = new DisplayLayer (0, "None"~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// Steht für eine Ebene hinter der Spielwelt, z.B. um~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Hintergrundbilder darzustellen.~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~51~ & \verb~        public static readonly DisplayLayer Background = new DisplayLayer (10,~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// Steht für die Ebene in der die Spielwelt dargestellt wird.~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~55~ & \verb~        public static readonly DisplayLayer GameWorld = new DisplayLayer (20, ~\\
\cellcolor{green} & 1 & \verb~56~ & \verb~        public static readonly DisplayLayer ScreenUI = new DisplayLayer (30, "~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// Steht für die Ebene in der die Dialoge dargestellt werden.~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// Dialoge werden vor der Spielwelt gezeichnet, damit der Spieler dam~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~61~ & \verb~        public static readonly DisplayLayer Dialog = new DisplayLayer (50, "Di~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        /// Steht für die Ebene in der Menüs gezeichnet werden. Menüs werden i~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~        public static readonly DisplayLayer Menu = new DisplayLayer (10, "Menu~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        /// Steht für die Ebene in der Menüeinträge gezeichnet werden. Menüein~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~69~ & \verb~        public static readonly DisplayLayer MenuItem = new DisplayLayer (20, "~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        /// Zum Anzeigen zusätzlicher Informationen bei der (Weiter-)Entwicklu~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~73~ & \verb~        public static readonly DisplayLayer Overlay = new DisplayLayer (300, "~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// Die Maus ist das Hauptinteraktionswerkzeug, welches der Spieler~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// ständig verwendet. Daher muss die Maus bei der Interaktion immer~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// im Vordergrund sein. Cursor steht für die vorderste Ebene.~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~79~ & \verb~        public static readonly DisplayLayer Cursor = new DisplayLayer (500, "C~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{green} & 1 & \verb~81~ & \verb~        public static readonly DisplayLayer[] Values = {~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            None, Background, GameWorld, ScreenUI, Dialog, Menu, MenuItem, Ove~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        };~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{green} & 1822 & \verb~85~ & \verb~        public int Index { get; private set; }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{green} & 1001 & \verb~87~ & \verb~        public string Description { get; private set; }~\\
\cellcolor{gray} &  & \verb~88~ & \verb~~\\
\cellcolor{green} & 18 & \verb~89~ & \verb~        private DisplayLayer (int index, string desciption)~\\
\cellcolor{green} & 18 & \verb~90~ & \verb~        {~\\
\cellcolor{green} & 18 & \verb~91~ & \verb~            Index = index;~\\
\cellcolor{green} & 18 & \verb~92~ & \verb~            Description = desciption;~\\
\cellcolor{green} & 18 & \verb~93~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~~\\
\cellcolor{green} & 324 & \verb~95~ & \verb~        private DisplayLayer (DisplayLayer layer1, DisplayLayer layer2)~\\
\cellcolor{green} & 324 & \verb~96~ & \verb~        {~\\
\cellcolor{green} & 324 & \verb~97~ & \verb~            Index = layer1.Index + layer2.Index;~\\
\cellcolor{green} & 324 & \verb~98~ & \verb~            Description = layer1.Description + "+" + layer2.Description;~\\
\cellcolor{green} & 324 & \verb~99~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~102~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~104~ & \verb~            return Description;~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        public static DisplayLayer operator + (DisplayLayer layer1, DisplayLay~\\
\cellcolor{green} & 243 & \verb~108~ & \verb~        {~\\
\cellcolor{green} & 243 & \verb~109~ & \verb~            return new DisplayLayer (layer1, layer2);~\\
\cellcolor{green} & 243 & \verb~110~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~        public static DisplayLayer operator + (DisplayLayer layer, Widget widg~\\
\cellcolor{green} & 81 & \verb~113~ & \verb~        {~\\
\cellcolor{green} & 81 & \verb~114~ & \verb~            return new DisplayLayer (widget.Index, layer);~\\
\cellcolor{green} & 81 & \verb~115~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        public static DisplayLayer operator * (DisplayLayer layer, int i)~\\
\cellcolor{green} & 9 & \verb~118~ & \verb~        {~\\
\cellcolor{green} & 9 & \verb~119~ & \verb~            return new DisplayLayer (layer.Index * i, "(" + layer + "*" + i + ~\\
\cellcolor{green} & 9 & \verb~120~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~        public static bool operator == (DisplayLayer a, DisplayLayer b)~\\
\cellcolor{green} & 27 & \verb~123~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~124~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 36 & \verb~125~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 9 & \verb~126~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~127~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~~\\
\cellcolor{gray} &  & \verb~129~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 36 & \verb~130~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 18 & \verb~131~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~132~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~133~ & \verb~~\\
\cellcolor{gray} &  & \verb~134~ & \verb~            // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~135~ & \verb~            return a.Index == b.Index;~\\
\cellcolor{green} & 27 & \verb~136~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & \verb~        public static bool operator != (DisplayLayer d1, DisplayLayer d2)~\\
\cellcolor{green} & 27 & \verb~139~ & \verb~        {~\\
\cellcolor{green} & 27 & \verb~140~ & \verb~            return !(d1 == d2);~\\
\cellcolor{green} & 27 & \verb~141~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        public bool Equals (DisplayLayer other)~\\
\cellcolor{green} & 27 & \verb~144~ & \verb~        {~\\
\cellcolor{green} & 27 & \verb~145~ & \verb~            return other != null && Index == other.Index;~\\
\cellcolor{green} & 27 & \verb~146~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~147~ & \verb~~\\
\cellcolor{gray} &  & \verb~148~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 9 & \verb~149~ & \verb~        {~\\
\cellcolor{green} & 9 & \verb~150~ & \verb~            return other != null && Equals (other as DisplayLayer);~\\
\cellcolor{green} & 9 & \verb~151~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~152~ & \verb~~\\
\cellcolor{gray} &  & \verb~153~ & \verb~        public static implicit operator string (DisplayLayer layer)~\\
\cellcolor{green} & 9 & \verb~154~ & \verb~        {~\\
\cellcolor{green} & 9 & \verb~155~ & \verb~            return layer.Description;~\\
\cellcolor{green} & 9 & \verb~156~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~157~ & \verb~~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        public static implicit operator int (DisplayLayer layer)~\\
\cellcolor{green} & 598 & \verb~159~ & \verb~        {~\\
\cellcolor{green} & 598 & \verb~160~ & \verb~            return layer.Index;~\\
\cellcolor{green} & 598 & \verb~161~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~162~ & \verb~~\\
\cellcolor{gray} &  & \verb~163~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~164~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~165~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~166~ & \verb~            return Description.GetHashCode ();~\\
\cellcolor{gray} &  & \verb~167~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~168~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~169~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Core.TypesafeEnum`1}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Core.TypesafeEnum`1\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Core\textbackslash TypesafeEnum.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 39\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 39\\
\textbf{Total lines:} & 122\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 5 & 100 & 77.78\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 100 & 85.71\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 100\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{FromString(...)} & 3 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Core\textbackslash TypesafeEnum.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Framework.Core~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public abstract class TypesafeEnum<T> : IEquatable<T>, IEquatable<Typesafe~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        where T : TypesafeEnum<T>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    {~\\
\cellcolor{green} & 3 & \verb~43~ & \verb~        private static Dictionary<string, ISet<TypesafeEnum<T>>> _values = new~\\
\cellcolor{gray} &  & \verb~44~ & \verb~~\\
\cellcolor{green} & 108 & \verb~45~ & \verb~        public static T[] Values { get { return _values [Typename].Select (val~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{green} & 81 & \verb~47~ & \verb~        private static string Typename { get { return typeof (T).ToString (); ~\\
\cellcolor{gray} &  & \verb~48~ & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        public string Name { get; private set; }~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{green} & 17 & \verb~51~ & \verb~        public TypesafeEnum (string name)~\\
\cellcolor{green} & 17 & \verb~52~ & \verb~        {~\\
\cellcolor{green} & 17 & \verb~53~ & \verb~            Name = name;~\\
\cellcolor{green} & 32 & \verb~54~ & \verb~            if (!string.IsNullOrWhiteSpace (name) && name != "Zero" && name !=~\\
\cellcolor{green} & 15 & \verb~55~ & \verb~                _values.Add (Typename, this);~\\
\cellcolor{green} & 15 & \verb~56~ & \verb~            }~\\
\cellcolor{green} & 17 & \verb~57~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~62~ & \verb~            return Name;~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        public static implicit operator string (TypesafeEnum<T> instance)~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~67~ & \verb~            return instance.Name;~\\
\cellcolor{green} & 1 & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        public static bool operator == (TypesafeEnum<T> a, TypesafeEnum<T> b)~\\
\cellcolor{green} & 2264 & \verb~71~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~72~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 2271 & \verb~73~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 7 & \verb~74~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~75~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 4505 & \verb~78~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 2248 & \verb~79~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~80~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            // Return true if the fields match:~\\
\cellcolor{green} & 9 & \verb~83~ & \verb~            return a.Name == b.Name;~\\
\cellcolor{green} & 2264 & \verb~84~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        public static bool operator != (TypesafeEnum<T> d1, TypesafeEnum<T> d2~\\
\cellcolor{green} & 2258 & \verb~87~ & \verb~        {~\\
\cellcolor{green} & 2258 & \verb~88~ & \verb~            return !(d1 == d2);~\\
\cellcolor{green} & 2258 & \verb~89~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        public bool Equals (TypesafeEnum<T> other)~\\
\cellcolor{green} & 1128 & \verb~92~ & \verb~        {~\\
\cellcolor{green} & 1128 & \verb~93~ & \verb~            return other != null && Name == other.Name;~\\
\cellcolor{green} & 1128 & \verb~94~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 4 & \verb~97~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~98~ & \verb~            return other != null && Equals (other as TypesafeEnum<T>);~\\
\cellcolor{green} & 4 & \verb~99~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~100~ & \verb~~\\
\cellcolor{gray} &  & \verb~101~ & \verb~        public bool Equals (T other)~\\
\cellcolor{green} & 1124 & \verb~102~ & \verb~        {~\\
\cellcolor{green} & 1124 & \verb~103~ & \verb~            return other != null && Equals (other as TypesafeEnum<T>);~\\
\cellcolor{green} & 1124 & \verb~104~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        public static T FromString (string str)~\\
\cellcolor{green} & 7 & \verb~107~ & \verb~        {~\\
\cellcolor{green} & 96 & \verb~108~ & \verb~            foreach (T value in Values) {~\\
\cellcolor{green} & 33 & \verb~109~ & \verb~                if (str.ToLower () == value.Name.ToLower ()) {~\\
\cellcolor{green} & 6 & \verb~110~ & \verb~                    return value;~\\
\cellcolor{gray} &  & \verb~111~ & \verb~                }~\\
\cellcolor{green} & 21 & \verb~112~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~113~ & \verb~            return null;~\\
\cellcolor{green} & 7 & \verb~114~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~115~ & \verb~~\\
\cellcolor{gray} &  & \verb~116~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~119~ & \verb~            return Name.GetHashCode ();~\\
\cellcolor{gray} &  & \verb~120~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Math.Angles3}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Math.Angles3\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{s\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash Angles3.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 62\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 62\\
\textbf{Total lines:} & 192\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{FromDegrees(...)} & 1 & 100 & 100\\
\hline
\textbf{ToDegrees(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 3 & 100 & 80\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_UnaryNegation(...} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Division(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Division(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{s\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash Angles3.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~namespace Knot3.Framework.Math~\\
\cellcolor{gray} &  & \verb~37~ & \verb~{~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// Diese Klasse repräsentiert die Rollwinkel der drei Achsen X, Y und Z.~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// Sie bietet Möglichkeit vordefinierte Winkelwerte zu verwenden, z.B. st~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// Die Umwandlung zwischen verschiedenen Winkelmaßen wie Grad- und Bogenm~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    public sealed class Angles3 : IEquatable<Angles3>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// Der Winkel im Bogenmaß für das Rollen um die X-Achse. Siehe statis~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// </summary>~\\
\cellcolor{green} & 158 & \verb~48~ & \verb~        public float X { get; set; }~\\
\cellcolor{gray} &  & \verb~49~ & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        /// Der Winkel im Bogenmaß für das Rollen um die Y-Achse. Siehe statis~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// </summary>~\\
\cellcolor{green} & 154 & \verb~53~ & \verb~        public float Y { get; set; }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        /// Der Winkel im Bogenmaß für das Rollen um die Z-Achse. Siehe statis~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// </summary>~\\
\cellcolor{green} & 154 & \verb~58~ & \verb~        public float Z { get; set; }~\\
\cellcolor{gray} &  & \verb~59~ & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// Eine statische Eigenschaft mit dem Wert X = 0, Y = 0, Z = 0.~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        public static Angles3 Zero~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        {~\\
\cellcolor{green} & 54 & \verb~65~ & \verb~            get { return new Angles3 (0f, 0f, 0f); }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        /// Konstruiert ein neues Angles3-Objekt mit drei gegebenen Winkeln im~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// </summary>~\\
\cellcolor{green} & 91 & \verb~71~ & \verb~        public Angles3 (float x, float y, float z)~\\
\cellcolor{green} & 91 & \verb~72~ & \verb~        {~\\
\cellcolor{green} & 91 & \verb~73~ & \verb~            X = x;~\\
\cellcolor{green} & 91 & \verb~74~ & \verb~            Y = y;~\\
\cellcolor{green} & 91 & \verb~75~ & \verb~            Z = z;~\\
\cellcolor{green} & 91 & \verb~76~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{green} & 5 & \verb~78~ & \verb~        public Angles3 (Vector3 v)~\\
\cellcolor{green} & 5 & \verb~79~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~80~ & \verb~            X = v.X;~\\
\cellcolor{green} & 5 & \verb~81~ & \verb~            Y = v.Y;~\\
\cellcolor{green} & 5 & \verb~82~ & \verb~            Z = v.Z;~\\
\cellcolor{green} & 5 & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        /// Eine statische Methode, die Grad in Bogenmaß konvertiert.~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        public static Angles3 FromDegrees (float x, float y, float z)~\\
\cellcolor{green} & 46 & \verb~89~ & \verb~        {~\\
\cellcolor{green} & 46 & \verb~90~ & \verb~            return new Angles3 (~\\
\cellcolor{gray} &  & \verb~91~ & \verb~                       MathHelper.ToRadians (x),~\\
\cellcolor{gray} &  & \verb~92~ & \verb~                       MathHelper.ToRadians (y),~\\
\cellcolor{gray} &  & \verb~93~ & \verb~                       MathHelper.ToRadians (z)~\\
\cellcolor{gray} &  & \verb~94~ & \verb~                   );~\\
\cellcolor{green} & 46 & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        /// Konvertiert Bogenmaß in Grad.~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        public void ToDegrees (out float x, out float y, out float z)~\\
\cellcolor{green} & 2 & \verb~101~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~102~ & \verb~            x = (int)MathHelper.ToDegrees (X) % 360;~\\
\cellcolor{green} & 2 & \verb~103~ & \verb~            y = (int)MathHelper.ToDegrees (Y) % 360;~\\
\cellcolor{green} & 2 & \verb~104~ & \verb~            z = (int)MathHelper.ToDegrees (Z) % 360;~\\
\cellcolor{green} & 2 & \verb~105~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        public override bool Equals (object obj)~\\
\cellcolor{green} & 1 & \verb~108~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~109~ & \verb~            return (obj is Angles3) ? this == (Angles3)obj : false;~\\
\cellcolor{green} & 1 & \verb~110~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & \verb~        public bool Equals (Angles3 other)~\\
\cellcolor{green} & 12 & \verb~113~ & \verb~        {~\\
\cellcolor{green} & 12 & \verb~114~ & \verb~            return this == other;~\\
\cellcolor{green} & 12 & \verb~115~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~118~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~119~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~120~ & \verb~            return (int)(this.X + this.Y + this.Z);~\\
\cellcolor{gray} &  & \verb~121~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~122~ & \verb~~\\
\cellcolor{gray} &  & \verb~123~ & \verb~        public static bool operator == (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 14 & \verb~124~ & \verb~        {~\\
\cellcolor{green} & 14 & \verb~125~ & \verb~            return value1.X == value2.X~\\
\cellcolor{gray} &  & \verb~126~ & \verb~                   && value1.Y == value2.Y~\\
\cellcolor{gray} &  & \verb~127~ & \verb~                   && value1.Z == value2.Z;~\\
\cellcolor{green} & 14 & \verb~128~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & \verb~        public static bool operator != (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~131~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~132~ & \verb~            return !(value1 == value2);~\\
\cellcolor{green} & 1 & \verb~133~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~134~ & \verb~~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        public static Angles3 operator + (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 6 & \verb~136~ & \verb~        {~\\
\cellcolor{green} & 6 & \verb~137~ & \verb~            return new Angles3 (value1.X + value2.X, value1.Y + value2.Y, valu~\\
\cellcolor{green} & 6 & \verb~138~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~~\\
\cellcolor{gray} &  & \verb~140~ & \verb~        public static Angles3 operator - (Angles3 value)~\\
\cellcolor{green} & 1 & \verb~141~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~142~ & \verb~            value = new Angles3 (-value.X, -value.Y, -value.Z);~\\
\cellcolor{green} & 1 & \verb~143~ & \verb~            return value;~\\
\cellcolor{green} & 1 & \verb~144~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & \verb~        public static Angles3 operator - (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~147~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~148~ & \verb~            return new Angles3 (value1.X - value2.X, value1.Y - value2.Y, valu~\\
\cellcolor{green} & 1 & \verb~149~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~        public static Angles3 operator * (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~152~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~153~ & \verb~            return new Angles3 (value1.X * value2.X, value1.Y * value2.Y, valu~\\
\cellcolor{green} & 1 & \verb~154~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~        public static Angles3 operator * (Angles3 value, float scaleFactor)~\\
\cellcolor{green} & 1 & \verb~157~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~158~ & \verb~            return new Angles3 (value.X * scaleFactor, value.Y * scaleFactor, ~\\
\cellcolor{green} & 1 & \verb~159~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~160~ & \verb~~\\
\cellcolor{gray} &  & \verb~161~ & \verb~        public static Angles3 operator * (float scaleFactor, Angles3 value)~\\
\cellcolor{green} & 1 & \verb~162~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~163~ & \verb~            return new Angles3 (value.X * scaleFactor, value.Y * scaleFactor, ~\\
\cellcolor{green} & 1 & \verb~164~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        public static Angles3 operator / (Angles3 value1, Angles3 value2)~\\
\cellcolor{green} & 1 & \verb~167~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~168~ & \verb~            return new Angles3 (value1.X / value2.X, value1.Y / value2.Y, valu~\\
\cellcolor{green} & 1 & \verb~169~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~        public static Angles3 operator / (Angles3 value, float divider)~\\
\cellcolor{green} & 1 & \verb~172~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~173~ & \verb~            float scaleFactor = 1 / divider;~\\
\cellcolor{green} & 1 & \verb~174~ & \verb~            return new Angles3 (value.X * scaleFactor, value.Y * scaleFactor, ~\\
\cellcolor{green} & 1 & \verb~175~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~178~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~179~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~180~ & \verb~            float x, y, z;~\\
\cellcolor{gray} &  & \verb~181~ & \verb~            ToDegrees (out x, out y, out z);~\\
\cellcolor{gray} &  & \verb~182~ & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & \verb~            return   "Angles3 ("~\\
\cellcolor{gray} &  & \verb~184~ & \verb~                     + x.ToString ()~\\
\cellcolor{gray} &  & \verb~185~ & \verb~                     + ","~\\
\cellcolor{gray} &  & \verb~186~ & \verb~                     + y.ToString ()~\\
\cellcolor{gray} &  & \verb~187~ & \verb~                     + ","~\\
\cellcolor{gray} &  & \verb~188~ & \verb~                     + z.ToString ()~\\
\cellcolor{gray} &  & \verb~189~ & \verb~                     + ")";~\\
\cellcolor{gray} &  & \verb~190~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~192~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Math.BoundingCylinder}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Math.BoundingCylinder\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash BoundingCylinder.cs}\end{minipage} \\
\textbf{Coverage:} & 90.4\%\\
\textbf{Covered lines:} & 19\\
\textbf{Uncovered lines:} & 2\\
\textbf{Coverable lines:} & 21\\
\textbf{Total lines:} & 85\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 55.56 & 57.14\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 5 & 100 & 77.78\\
\hline
\textbf{Equals(...)} & 2 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash BoundingCylinder.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~namespace Knot3.Framework.Math~\\
\cellcolor{gray} &  & \verb~37~ & \verb~{~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    public struct BoundingCylinder : IEquatable<BoundingCylinder> {~\\
\cellcolor{gray} &  & \verb~39~ & \verb~        public Vector3 SideA;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~        public Vector3 SideB;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        public float Radius;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        public BoundingCylinder (Vector3 sideA, Vector3 sideB, float radius)~\\
\cellcolor{green} & 5 & \verb~44~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~45~ & \verb~            SideA = sideA;~\\
\cellcolor{green} & 5 & \verb~46~ & \verb~            SideB = sideB;~\\
\cellcolor{green} & 5 & \verb~47~ & \verb~            Radius = radius;~\\
\cellcolor{green} & 5 & \verb~48~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        public static bool operator == (BoundingCylinder a, BoundingCylinder b~\\
\cellcolor{green} & 11 & \verb~51~ & \verb~        {~\\
\cellcolor{green} & 11 & \verb~52~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~53~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~            }~\\
\cellcolor{green} & 11 & \verb~55~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{red} & 0 & \verb~56~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~57~ & \verb~            }~\\
\cellcolor{green} & 11 & \verb~58~ & \verb~            return a.Equals (b);~\\
\cellcolor{green} & 11 & \verb~59~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        public static bool operator != (BoundingCylinder a, BoundingCylinder b~\\
\cellcolor{green} & 8 & \verb~62~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~63~ & \verb~            return !(a == b);~\\
\cellcolor{green} & 8 & \verb~64~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        public bool Equals (BoundingCylinder other)~\\
\cellcolor{green} & 24 & \verb~67~ & \verb~        {~\\
\cellcolor{green} & 24 & \verb~68~ & \verb~            return ((SideA == other.SideA && SideB == other.SideB)~\\
\cellcolor{gray} &  & \verb~69~ & \verb~                    || (SideA == other.SideB && SideB == other.SideA))~\\
\cellcolor{gray} &  & \verb~70~ & \verb~                   && Radius == other.Radius;~\\
\cellcolor{green} & 24 & \verb~71~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 3 & \verb~74~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~75~ & \verb~            return other != null && Equals ((BoundingCylinder)other);~\\
\cellcolor{green} & 3 & \verb~76~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~81~ & \verb~            // irgendwas möglichst eindeutiges~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            return (Radius * (SideA + SideB)).GetHashCode ();~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Math.Bounds}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Math.Bounds\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{rs\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash Bounds.cs}\end{minipage} \\
\textbf{Coverage:} & 94.5\%\\
\textbf{Covered lines:} & 87\\
\textbf{Uncovered lines:} & 5\\
\textbf{Coverable lines:} & 92\\
\textbf{Total lines:} & 229\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Contains(...)} & 1 & 100 & 100\\
\hline
\textbf{Zero(...)} & 1 & 100 & 100\\
\hline
\textbf{FromLeft(...)} & 1 & 100 & 100\\
\hline
\textbf{FromRight(...)} & 2 & 100 & 66.67\\
\hline
\textbf{FromTop(...)} & 1 & 100 & 100\\
\hline
\textbf{FromBottom(...)} & 2 & 100 & 66.67\\
\hline
\textbf{FromLeft(...)} & 1 & 100 & 100\\
\hline
\textbf{FromRight(...)} & 1 & 100 & 100\\
\hline
\textbf{FromTop(...)} & 1 & 100 & 100\\
\hline
\textbf{FromBottom(...)} & 1 & 100 & 100\\
\hline
\textbf{In(...)} & 1 & 100 & 100\\
\hline
\textbf{Grow(...)} & 1 & 100 & 100\\
\hline
\textbf{Shrink(...)} & 1 & 100 & 100\\
\hline
\textbf{Grow(...)} & 1 & 100 & 100\\
\hline
\textbf{Shrink(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{rs\textbackslash Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash Bounds.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Framework.Math~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public class Bounds~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// Die von der Auflösung unabhängige Position in Prozent.~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        public ScreenPoint Position~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        {~\\
\cellcolor{green} & 132 & \verb~47~ & \verb~            get { return _position; }~\\
\cellcolor{red} & 0 & \verb~48~ & \verb~            set { _position.Assign (value); }~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        private ScreenPoint _position;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// Die von der Auflösung unabhängige Größe in Prozent.~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        public ScreenPoint Size~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        {~\\
\cellcolor{green} & 174 & \verb~58~ & \verb~            get { return _size; }~\\
\cellcolor{green} & 3 & \verb~59~ & \verb~            set { _size.Assign (value); }~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        private ScreenPoint _size;~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        /// Der von der Auflösung unabhängige Abstand in Prozent.~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        public ScreenPoint Padding~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        {~\\
\cellcolor{green} & 30 & \verb~69~ & \verb~            get { return _padding; }~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~            set { _padding.Assign (value); }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        private ScreenPoint _padding;~\\
\cellcolor{gray} &  & \verb~74~ & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// Gibt ein auf die Auflösujng skaliertes Rechteck zurück, das in den~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        public Rectangle Rectangle~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~80~ & \verb~            get {~\\
\cellcolor{green} & 2 & \verb~81~ & \verb~                Point pos = Position.Absolute;~\\
\cellcolor{green} & 2 & \verb~82~ & \verb~                Point size = Size.Absolute;~\\
\cellcolor{green} & 2 & \verb~83~ & \verb~                return new Rectangle (pos.X, pos.Y, size.X, size.Y);~\\
\cellcolor{green} & 2 & \verb~84~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & \verb~        public Vector4 Vector4~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~89~ & \verb~            get {~\\
\cellcolor{green} & 1 & \verb~90~ & \verb~                Point pos = Position.Absolute;~\\
\cellcolor{green} & 1 & \verb~91~ & \verb~                Point size = Size.Absolute;~\\
\cellcolor{green} & 1 & \verb~92~ & \verb~                return new Vector4 (pos.X, pos.Y, size.X, size.Y);~\\
\cellcolor{green} & 1 & \verb~93~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~~\\
\cellcolor{green} & 90 & \verb~96~ & \verb~        public Bounds (ScreenPoint position, ScreenPoint size, ScreenPoint pad~\\
\cellcolor{green} & 90 & \verb~97~ & \verb~        {~\\
\cellcolor{green} & 90 & \verb~98~ & \verb~            _position = position;~\\
\cellcolor{green} & 90 & \verb~99~ & \verb~            _size = size;~\\
\cellcolor{green} & 90 & \verb~100~ & \verb~            _padding = padding;~\\
\cellcolor{green} & 90 & \verb~101~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{green} & 16 & \verb~103~ & \verb~        public Bounds (ScreenPoint position, ScreenPoint size)~\\
\cellcolor{green} & 16 & \verb~104~ & \verb~        {~\\
\cellcolor{green} & 16 & \verb~105~ & \verb~            _position = position;~\\
\cellcolor{green} & 16 & \verb~106~ & \verb~            _size = size;~\\
\cellcolor{green} & 16 & \verb~107~ & \verb~            _padding = new ScreenPoint (position.Screen, Vector2.Zero);~\\
\cellcolor{green} & 16 & \verb~108~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~~\\
\cellcolor{green} & 11 & \verb~110~ & \verb~        public Bounds (IScreen screen, float relX, float relY, float relWidth,~\\
\cellcolor{green} & 11 & \verb~111~ & \verb~        {~\\
\cellcolor{green} & 11 & \verb~112~ & \verb~            _position = new ScreenPoint (screen, relX, relY);~\\
\cellcolor{green} & 11 & \verb~113~ & \verb~            _size = new ScreenPoint (screen, relWidth, relHeight);~\\
\cellcolor{green} & 11 & \verb~114~ & \verb~            _padding = new ScreenPoint (screen, Vector2.Zero);~\\
\cellcolor{green} & 11 & \verb~115~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & \verb~        public bool Contains (Point point)~\\
\cellcolor{green} & 1 & \verb~118~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~119~ & \verb~            return Rectangle.Contains (point);~\\
\cellcolor{green} & 1 & \verb~120~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~        public bool Contains (ScreenPoint point)~\\
\cellcolor{green} & 1 & \verb~123~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~124~ & \verb~            return Rectangle.Contains ((Point)point);~\\
\cellcolor{green} & 1 & \verb~125~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~126~ & \verb~~\\
\cellcolor{gray} &  & \verb~127~ & \verb~        public static Bounds Zero (IScreen screen)~\\
\cellcolor{green} & 81 & \verb~128~ & \verb~        {~\\
\cellcolor{green} & 81 & \verb~129~ & \verb~            return new Bounds (~\\
\cellcolor{gray} &  & \verb~130~ & \verb~                       position: ScreenPoint.Zero (screen),~\\
\cellcolor{gray} &  & \verb~131~ & \verb~                       size: ScreenPoint.Zero (screen),~\\
\cellcolor{gray} &  & \verb~132~ & \verb~                       padding: ScreenPoint.Zero (screen)~\\
\cellcolor{gray} &  & \verb~133~ & \verb~                   );~\\
\cellcolor{green} & 81 & \verb~134~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        public Bounds FromLeft (Func<float> percent)~\\
\cellcolor{green} & 3 & \verb~137~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~138~ & \verb~            return new Bounds (~\\
\cellcolor{gray} &  & \verb~139~ & \verb~                       position: Position,~\\
\cellcolor{green} & 4 & \verb~140~ & \verb~                       size: new ScreenPoint (Size.Screen, () => Size.Relative~\\
\cellcolor{gray} &  & \verb~141~ & \verb~                       padding: Padding~\\
\cellcolor{gray} &  & \verb~142~ & \verb~                   );~\\
\cellcolor{green} & 3 & \verb~143~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & \verb~        public Bounds FromRight (Func<float> percent)~\\
\cellcolor{green} & 1 & \verb~146~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~147~ & \verb~            return new Bounds (~\\
\cellcolor{green} & 4 & \verb~148~ & \verb~                       position: Position + new ScreenPoint (Size.Screen, () =~\\
\cellcolor{green} & 4 & \verb~149~ & \verb~                       size: new ScreenPoint (Size.Screen, () => Size.Relative~\\
\cellcolor{gray} &  & \verb~150~ & \verb~                       padding: Padding~\\
\cellcolor{gray} &  & \verb~151~ & \verb~                   );~\\
\cellcolor{green} & 1 & \verb~152~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~~\\
\cellcolor{gray} &  & \verb~154~ & \verb~        public Bounds FromTop (Func<float> percent)~\\
\cellcolor{green} & 3 & \verb~155~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~156~ & \verb~            return new Bounds (~\\
\cellcolor{gray} &  & \verb~157~ & \verb~                       position: Position,~\\
\cellcolor{green} & 4 & \verb~158~ & \verb~                       size: new ScreenPoint (Size.Screen, () => Size.Relative~\\
\cellcolor{gray} &  & \verb~159~ & \verb~                       padding: Padding~\\
\cellcolor{gray} &  & \verb~160~ & \verb~                   );~\\
\cellcolor{green} & 3 & \verb~161~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~162~ & \verb~~\\
\cellcolor{gray} &  & \verb~163~ & \verb~        public Bounds FromBottom (Func<float> percent)~\\
\cellcolor{green} & 1 & \verb~164~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~165~ & \verb~            return new Bounds (~\\
\cellcolor{green} & 4 & \verb~166~ & \verb~                       position: Position + new ScreenPoint (Size.Screen, () =~\\
\cellcolor{green} & 4 & \verb~167~ & \verb~                       size: new ScreenPoint (Size.Screen, () => Size.Relative~\\
\cellcolor{gray} &  & \verb~168~ & \verb~                       padding: Padding~\\
\cellcolor{gray} &  & \verb~169~ & \verb~                   );~\\
\cellcolor{green} & 1 & \verb~170~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~171~ & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & \verb~        public Bounds FromLeft (float percent)~\\
\cellcolor{green} & 3 & \verb~173~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~174~ & \verb~            return FromLeft (() => percent);~\\
\cellcolor{green} & 3 & \verb~175~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & \verb~        public Bounds FromRight (float percent)~\\
\cellcolor{green} & 1 & \verb~178~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~179~ & \verb~            return FromRight (() => percent);~\\
\cellcolor{green} & 1 & \verb~180~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~181~ & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & \verb~        public Bounds FromTop (float percent)~\\
\cellcolor{green} & 3 & \verb~183~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~184~ & \verb~            return FromTop (() => percent);~\\
\cellcolor{green} & 3 & \verb~185~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{gray} &  & \verb~187~ & \verb~        public Bounds FromBottom (float percent)~\\
\cellcolor{green} & 1 & \verb~188~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~189~ & \verb~            return FromBottom (() => percent);~\\
\cellcolor{green} & 1 & \verb~190~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & \verb~        public Bounds In (Bounds container)~\\
\cellcolor{green} & 1 & \verb~193~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~194~ & \verb~            return new Bounds (Position + container.Position, Size, Padding);~\\
\cellcolor{green} & 1 & \verb~195~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & \verb~        public Bounds Grow (int x, int y)~\\
\cellcolor{green} & 4 & \verb~198~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~199~ & \verb~            ScreenPoint diff = ScreenPoint.FromAbsolute (x, y, Position.Screen~\\
\cellcolor{green} & 4 & \verb~200~ & \verb~            return new Bounds (Position - diff, Size + diff * 2);~\\
\cellcolor{green} & 4 & \verb~201~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~202~ & \verb~~\\
\cellcolor{gray} &  & \verb~203~ & \verb~        public Bounds Shrink (int x, int y)~\\
\cellcolor{green} & 1 & \verb~204~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~205~ & \verb~            return Grow (-x, -y);~\\
\cellcolor{green} & 1 & \verb~206~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~207~ & \verb~~\\
\cellcolor{gray} &  & \verb~208~ & \verb~        public Bounds Grow (int xy)~\\
\cellcolor{green} & 1 & \verb~209~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~210~ & \verb~            return Grow (xy, xy);~\\
\cellcolor{green} & 1 & \verb~211~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~212~ & \verb~~\\
\cellcolor{gray} &  & \verb~213~ & \verb~        public Bounds Shrink (int xy)~\\
\cellcolor{green} & 1 & \verb~214~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~215~ & \verb~            return Grow (-xy, -xy);~\\
\cellcolor{green} & 1 & \verb~216~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~217~ & \verb~~\\
\cellcolor{gray} &  & \verb~218~ & \verb~        public static implicit operator Rectangle (Bounds bounds)~\\
\cellcolor{red} & 0 & \verb~219~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~            return bounds.Rectangle;~\\
\cellcolor{red} & 0 & \verb~221~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~222~ & \verb~~\\
\cellcolor{gray} &  & \verb~223~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~224~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~225~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~226~ & \verb~            return "(" + Position.Relative.X + "x" + Position.Relative.Y + ","~\\
\cellcolor{gray} &  & \verb~227~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~228~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~229~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Math.RayExtensions}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Math.RayExtensions\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash RayExtensions.cs}\end{minipage} \\
\textbf{Coverage:} & 68\%\\
\textbf{Covered lines:} & 34\\
\textbf{Uncovered lines:} & 16\\
\textbf{Coverable lines:} & 50\\
\textbf{Total lines:} & 142\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{Intersects(...)} & 21 & 61.90 & 53.66\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash RayExtensions.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Math~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    public static class RayExtensions~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~39~ & \verb~        public static float? Intersects (this Ray ray, BoundingCylinder cylind~\\
\cellcolor{green} & 10 & \verb~40~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~41~ & \verb~            Vector3 dirAB = cylinder.SideB - cylinder.SideA;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~            // Raystart innerhalb des Zylinders~\\
\cellcolor{green} & 16 & \verb~43~ & \verb~            if (Vector3.Cross ((ray.Position - cylinder.SideA), ray.Direction)~\\
\cellcolor{green} & 6 & \verb~44~ & \verb~                return 0.0f;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~46~ & \verb~            Vector3 perpendicular = Vector3.Cross (dirAB, ray.Direction);~\\
\cellcolor{gray} &  & \verb~47~ & \verb~            // if !(Ray Parallel zum Zylinder)~\\
\cellcolor{green} & 8 & \verb~48~ & \verb~            if (perpendicular.Length () > 0.0000001f) {~\\
\cellcolor{green} & 4 & \verb~49~ & \verb~                perpendicular.Normalize ();~\\
\cellcolor{green} & 4 & \verb~50~ & \verb~                if (Vector3.Dot (perpendicular, ray.Direction) > 0) {~\\
\cellcolor{red} & 0 & \verb~51~ & \verb~                    perpendicular = -perpendicular;~\\
\cellcolor{red} & 0 & \verb~52~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~53~ & \verb~                Vector3 perpendicular2 = Vector3.Cross (dirAB, perpendicular);~\\
\cellcolor{gray} &  & \verb~54~ & \verb~                // If (Ray Senkrecht zum Zylinder)~\\
\cellcolor{green} & 4 & \verb~55~ & \verb~                if (perpendicular2.Length () < 0.0000001f) {~\\
\cellcolor{red} & 0 & \verb~56~ & \verb~                    if (Vector3.Dot (dirAB, ray.Position - cylinder.SideA) < 0~\\
\cellcolor{red} & 0 & \verb~57~ & \verb~                        return null;~\\
\cellcolor{gray} &  & \verb~58~ & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~59~ & \verb~                    float? result = Vector3.Cross ((ray.Position - cylinder.Si~\\
\cellcolor{red} & 0 & \verb~60~ & \verb~                    if (result < 0) {~\\
\cellcolor{red} & 0 & \verb~61~ & \verb~                        result = 0.0f;~\\
\cellcolor{red} & 0 & \verb~62~ & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~63~ & \verb~                    return result;~\\
\cellcolor{gray} &  & \verb~64~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~65~ & \verb~                if (Vector3.Dot (perpendicular2, ray.Direction) > 0) {~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~                    perpendicular2 = -perpendicular2;~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~68~ & \verb~                perpendicular2.Normalize ();~\\
\cellcolor{green} & 4 & \verb~69~ & \verb~                float minDist = System.Math.Abs (Vector3.Dot (cylinder.SideA -~\\
\cellcolor{green} & 4 & \verb~70~ & \verb~                if (minDist > cylinder.Radius) {~\\
\cellcolor{red} & 0 & \verb~71~ & \verb~                    return null;~\\
\cellcolor{gray} &  & \verb~72~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~73~ & \verb~                Vector3 plainNorm = perpendicular * minDist + (float)System.Ma~\\
\cellcolor{green} & 4 & \verb~74~ & \verb~                plainNorm.Normalize ();~\\
\cellcolor{green} & 4 & \verb~75~ & \verb~                float? other_result = ray.Intersects (new Plane (plainNorm, Ve~\\
\cellcolor{green} & 4 & \verb~76~ & \verb~                if (other_result == null) {~\\
\cellcolor{red} & 0 & \verb~77~ & \verb~                    return null;~\\
\cellcolor{gray} &  & \verb~78~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~79~ & \verb~                Vector3 cutA = ray.Position + ray.Direction * (float)other_res~\\
\cellcolor{green} & 4 & \verb~80~ & \verb~                Vector3 cutB = ray.Position + ray.Direction * (float)other_res~\\
\cellcolor{green} & 4 & \verb~81~ & \verb~                if (Vector3.Dot (dirAB, cutA) > 0 && Vector3.Dot (-dirAB, cutB~\\
\cellcolor{red} & 0 & \verb~82~ & \verb~                    return other_result;~\\
\cellcolor{gray} &  & \verb~83~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~84~ & \verb~            }~\\
\cellcolor{green} & 6 & \verb~85~ & \verb~            if (Vector3.Distance (ray.Position, cylinder.SideA) < Vector3.Dist~\\
\cellcolor{green} & 2 & \verb~86~ & \verb~                dirAB.Normalize ();~\\
\cellcolor{green} & 2 & \verb~87~ & \verb~                float? result = ray.Intersects (new Plane (dirAB, Vector3.Dot ~\\
\cellcolor{green} & 4 & \verb~88~ & \verb~                if (result == null || Vector3.Distance (ray.Position + ray.Dir~\\
\cellcolor{green} & 2 & \verb~89~ & \verb~                    return null;~\\
\cellcolor{gray} &  & \verb~90~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~                return result;~\\
\cellcolor{gray} &  & \verb~92~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~93~ & \verb~            else {~\\
\cellcolor{green} & 2 & \verb~94~ & \verb~                dirAB.Normalize ();~\\
\cellcolor{green} & 2 & \verb~95~ & \verb~                dirAB = -dirAB;~\\
\cellcolor{green} & 2 & \verb~96~ & \verb~                float? result = ray.Intersects (new Plane (dirAB, Vector3.Dot ~\\
\cellcolor{green} & 4 & \verb~97~ & \verb~                if (result == null || Vector3.Distance (ray.Position + ray.Dir~\\
\cellcolor{green} & 2 & \verb~98~ & \verb~                    return null;~\\
\cellcolor{gray} &  & \verb~99~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~                return result;~\\
\cellcolor{gray} &  & \verb~101~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~            /*~\\
\cellcolor{gray} &  & \verb~103~ & \verb~            Vector3 diffA = capsule.CornerA - ray.Position;~\\
\cellcolor{gray} &  & \verb~104~ & \verb~            Vector3 diffB = capsule.CornerB - ray.Position;~\\
\cellcolor{gray} &  & \verb~105~ & \verb~            float diffASquared = diffA.LengthSquared ();~\\
\cellcolor{gray} &  & \verb~106~ & \verb~            float diffBSquared = diffB.LengthSquared ();~\\
\cellcolor{gray} &  & \verb~107~ & \verb~            float radiusSquared = capsule.Radius * capsule.Radius;~\\
\cellcolor{gray} &  & \verb~108~ & \verb~            // Startpunkt innerhalb der Eckkugeln~\\
\cellcolor{gray} &  & \verb~109~ & \verb~            if (diffASquared < radiusSquared || diffBSquared < radiusSquared)~\\
\cellcolor{gray} &  & \verb~110~ & \verb~            {~\\
\cellcolor{gray} &  & \verb~111~ & \verb~                return 0.0f;~\\
\cellcolor{gray} &  & \verb~112~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~            Vector3 dirBA = (capsule.CornerA - capsule.CornerB);~\\
\cellcolor{gray} &  & \verb~114~ & \verb~            float distAlongAB = Vector3.Dot (diffA, dirBA) / dirBA.Length ();~\\
\cellcolor{gray} &  & \verb~115~ & \verb~            // Startpunkt innerhalb des Zylinders~\\
\cellcolor{gray} &  & \verb~116~ & \verb~            if (distAlongAB > 0 && distAlongAB < dirBA.Length () && (distAlong~\\
\cellcolor{gray} &  & \verb~117~ & \verb~            {~\\
\cellcolor{gray} &  & \verb~118~ & \verb~                return 0.0f;~\\
\cellcolor{gray} &  & \verb~119~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~120~ & \verb~            float distAlongRayA = Vector3.Dot (ray.Direction, diffA);~\\
\cellcolor{gray} &  & \verb~121~ & \verb~            float distAlongRayB = Vector3.Dot (ray.Direction, diffB);~\\
\cellcolor{gray} &  & \verb~122~ & \verb~            // Richtung geht weg von der Kapsel~\\
\cellcolor{gray} &  & \verb~123~ & \verb~            if (distAlongRayA < 0 && distAlongRayB < 0)~\\
\cellcolor{gray} &  & \verb~124~ & \verb~                return null;~\\
\cellcolor{gray} &  & \verb~125~ & \verb~            Vector3 perpendicular = Vector3.Cross (ray.Direction, dirBA);~\\
\cellcolor{gray} &  & \verb~126~ & \verb~            perpendicular.Normalize ();~\\
\cellcolor{gray} &  & \verb~127~ & \verb~            float minDistance = Math.Abs (Vector3.Dot (diffA, perpendicular));~\\
\cellcolor{gray} &  & \verb~128~ & \verb~            // Kommt selbst der Geraden nie nahe genug.~\\
\cellcolor{gray} &  & \verb~129~ & \verb~            if (minDistance > capsule.Radius)~\\
\cellcolor{gray} &  & \verb~130~ & \verb~            {~\\
\cellcolor{gray} &  & \verb~131~ & \verb~                return null;~\\
\cellcolor{gray} &  & \verb~132~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~133~ & \verb~            Vector3 normDirAB = -dirBA;~\\
\cellcolor{gray} &  & \verb~134~ & \verb~            normDirAB.Normalize ();~\\
\cellcolor{gray} &  & \verb~135~ & \verb~            Vector3 extensionToBase = Vector3.Cross (normDirAB, perpendicular)~\\
\cellcolor{gray} &  & \verb~136~ & \verb~            extensionToBase.Normalize ();~\\
\cellcolor{gray} &  & \verb~137~ & \verb~            Matrix transformation = new Matrix (normDirAB.X, normDirAB.Y, norm~\\
\cellcolor{gray} &  & \verb~138~ & \verb~            transformation = Matrix.Invert (transformation);~\\
\cellcolor{gray} &  & \verb~139~ & \verb~             */~\\
\cellcolor{green} & 10 & \verb~140~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~141~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Math.ScreenPoint}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Math.ScreenPoint\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{scal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash ScreenPoint.cs}\end{minipage} \\
\textbf{Coverage:} & 51.8\%\\
\textbf{Covered lines:} & 69\\
\textbf{Uncovered lines:} & 64\\
\textbf{Coverable lines:} & 133\\
\textbf{Total lines:} & 278\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 66.67\\
\hline
\textbf{.ctor(...)} & 1 & 0 & 0\\
\hline
\textbf{Assign(...)} & 1 & 100 & 100\\
\hline
\textbf{FromAbsolute(...)} & 1 & 100 & 100\\
\hline
\textbf{FromAbsolute(...)} & 1 & 0 & 0\\
\hline
\textbf{Zero(...)} & 1 & 100 & 100\\
\hline
\textbf{TopLeft(...)} & 1 & 0 & 0\\
\hline
\textbf{BottomRight(...)} & 1 & 0 & 0\\
\hline
\textbf{Centered(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Implicit(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Implicit(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Implicit(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Multiply(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Multiply(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Division(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Addition(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Subtraction(...)} & 1 & 100 & 100\\
\hline
\textbf{ScaleX(...)} & 1 & 0 & 0\\
\hline
\textbf{ScaleY(...)} & 1 & 0 & 0\\
\hline
\textbf{op\_Equality(...)} & 4 & 66.67 & 57.14\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{Equals(...)} & 3 & 100 & 60\\
\hline
\textbf{Equals(...)} & 6 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{scal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Math\textbackslash ScreenPoint.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~~\\
\cellcolor{gray} &  & \verb~40~ & \verb~namespace Knot3.Framework.Math~\\
\cellcolor{gray} &  & \verb~41~ & \verb~{~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    public class ScreenPoint : IEquatable<ScreenPoint>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    {~\\
\cellcolor{green} & 406 & \verb~44~ & \verb~        public IScreen Screen { get; private set; }~\\
\cellcolor{gray} &  & \verb~45~ & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public Vector2 Relative~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        {~\\
\cellcolor{green} & 169 & \verb~48~ & \verb~            get {~\\
\cellcolor{green} & 169 & \verb~49~ & \verb~                return RelativeFunc ();~\\
\cellcolor{green} & 169 & \verb~50~ & \verb~            }~\\
\cellcolor{green} & 321 & \verb~51~ & \verb~            set {~\\
\cellcolor{green} & 448 & \verb~52~ & \verb~                RelativeFunc = () => value;~\\
\cellcolor{green} & 321 & \verb~53~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{green} & 517 & \verb~56~ & \verb~        public Func<Vector2> RelativeFunc~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~58~ & \verb~            set;~\\
\cellcolor{gray} &  & \verb~59~ & \verb~            private get;~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        public Point Absolute~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~64~ & \verb~            get {~\\
\cellcolor{green} & 8 & \verb~65~ & \verb~                Vector2 scaled = Relative.Scale (Screen.Viewport);~\\
\cellcolor{green} & 8 & \verb~66~ & \verb~                return new Point ((int)scaled.X, (int)scaled.Y);~\\
\cellcolor{green} & 8 & \verb~67~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        public Vector2 AbsoluteVector~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        {~\\
\cellcolor{green} & 5 & \verb~72~ & \verb~            get {~\\
\cellcolor{green} & 5 & \verb~73~ & \verb~                return Relative.Scale (Screen.Viewport);~\\
\cellcolor{green} & 5 & \verb~74~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        public ScreenPoint OnlyX~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~79~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~80~ & \verb~                return new ScreenPoint (Screen, () => new Vector2 (RelativeFun~\\
\cellcolor{red} & 0 & \verb~81~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        public ScreenPoint OnlyY~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~86~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~87~ & \verb~                return new ScreenPoint (Screen, () => new Vector2 (0, Relative~\\
\cellcolor{red} & 0 & \verb~88~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~90~ & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        public ScreenPoint Const~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~93~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~                return new ScreenPoint (Screen, Relative.X, Relative.Y);~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{red} & 0 & \verb~98~ & \verb~        public bool IsEmpty { get { return Relative.Length () == 0; } }~\\
\cellcolor{gray} &  & \verb~99~ & \verb~~\\
\cellcolor{green} & 15 & \verb~100~ & \verb~        public ScreenPoint (IScreen screen, Func<Vector2> func)~\\
\cellcolor{green} & 15 & \verb~101~ & \verb~        {~\\
\cellcolor{green} & 15 & \verb~102~ & \verb~            Screen = screen;~\\
\cellcolor{green} & 15 & \verb~103~ & \verb~            RelativeFunc = func;~\\
\cellcolor{green} & 15 & \verb~104~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~~\\
\cellcolor{green} & 270 & \verb~106~ & \verb~        public ScreenPoint (IScreen screen, Vector2 vector)~\\
\cellcolor{green} & 270 & \verb~107~ & \verb~        {~\\
\cellcolor{green} & 270 & \verb~108~ & \verb~            Screen = screen;~\\
\cellcolor{green} & 270 & \verb~109~ & \verb~            Relative = vector;~\\
\cellcolor{green} & 270 & \verb~110~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~111~ & \verb~~\\
\cellcolor{green} & 51 & \verb~112~ & \verb~        public ScreenPoint (IScreen screen, float x, float y)~\\
\cellcolor{green} & 51 & \verb~113~ & \verb~        {~\\
\cellcolor{green} & 51 & \verb~114~ & \verb~            Screen = screen;~\\
\cellcolor{green} & 51 & \verb~115~ & \verb~            Relative = new Vector2 (x, y);~\\
\cellcolor{green} & 51 & \verb~116~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~~\\
\cellcolor{green} & 10 & \verb~118~ & \verb~        public ScreenPoint (IScreen screen, Func<float> x, Func<float> y)~\\
\cellcolor{green} & 10 & \verb~119~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~120~ & \verb~            Screen = screen;~\\
\cellcolor{green} & 22 & \verb~121~ & \verb~            RelativeFunc = () => new Vector2 (x (), y ());~\\
\cellcolor{green} & 10 & \verb~122~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{red} & 0 & \verb~124~ & \verb~        public ScreenPoint (IScreen screen, float xy)~\\
\cellcolor{red} & 0 & \verb~125~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~126~ & \verb~            Screen = screen;~\\
\cellcolor{red} & 0 & \verb~127~ & \verb~            Relative = new Vector2 (xy, xy);~\\
\cellcolor{red} & 0 & \verb~128~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & \verb~        public void Assign (ScreenPoint other)~\\
\cellcolor{green} & 1 & \verb~131~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~132~ & \verb~            Screen = other.Screen;~\\
\cellcolor{green} & 1 & \verb~133~ & \verb~            RelativeFunc = other.RelativeFunc;~\\
\cellcolor{green} & 1 & \verb~134~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        public static ScreenPoint FromAbsolute (float x, float y, IScreen scre~\\
\cellcolor{green} & 4 & \verb~137~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~138~ & \verb~            return new ScreenPoint (screen, x / screen.Viewport.Width, y / scr~\\
\cellcolor{green} & 4 & \verb~139~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~140~ & \verb~~\\
\cellcolor{gray} &  & \verb~141~ & \verb~        public static ScreenPoint FromAbsolute (Point point, IScreen screen)~\\
\cellcolor{red} & 0 & \verb~142~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~143~ & \verb~            return FromAbsolute ((float)point.X, (float)point.Y, screen);~\\
\cellcolor{red} & 0 & \verb~144~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~145~ & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & \verb~        public static ScreenPoint Zero (IScreen screen)~\\
\cellcolor{green} & 243 & \verb~147~ & \verb~        {~\\
\cellcolor{green} & 243 & \verb~148~ & \verb~            return new ScreenPoint (screen, Vector2.Zero);~\\
\cellcolor{green} & 243 & \verb~149~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~150~ & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & \verb~        public static ScreenPoint TopLeft (IScreen screen)~\\
\cellcolor{red} & 0 & \verb~152~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~153~ & \verb~            return new ScreenPoint (screen, Vector2.Zero);~\\
\cellcolor{red} & 0 & \verb~154~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~        public static ScreenPoint BottomRight (IScreen screen)~\\
\cellcolor{red} & 0 & \verb~157~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~158~ & \verb~            return new ScreenPoint (screen, Vector2.One);~\\
\cellcolor{red} & 0 & \verb~159~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~160~ & \verb~~\\
\cellcolor{gray} &  & \verb~161~ & \verb~        public static ScreenPoint Centered (IScreen screen, Bounds sizeOf)~\\
\cellcolor{red} & 0 & \verb~162~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~163~ & \verb~            return new ScreenPoint (screen, () => (ScreenPoint.BottomRight (sc~\\
\cellcolor{red} & 0 & \verb~164~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & \verb~        public static implicit operator Vector2 (ScreenPoint point)~\\
\cellcolor{red} & 0 & \verb~167~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~168~ & \verb~            return point.Relative;~\\
\cellcolor{red} & 0 & \verb~169~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~170~ & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & \verb~        public static implicit operator Func<Vector2> (ScreenPoint point)~\\
\cellcolor{red} & 0 & \verb~172~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~173~ & \verb~            return point.RelativeFunc;~\\
\cellcolor{red} & 0 & \verb~174~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~175~ & \verb~~\\
\cellcolor{gray} &  & \verb~176~ & \verb~        public static implicit operator Point (ScreenPoint point)~\\
\cellcolor{green} & 2 & \verb~177~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~178~ & \verb~            return point.Absolute;~\\
\cellcolor{green} & 2 & \verb~179~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~180~ & \verb~~\\
\cellcolor{gray} &  & \verb~181~ & \verb~        public static implicit operator bool (ScreenPoint point)~\\
\cellcolor{red} & 0 & \verb~182~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~183~ & \verb~            return !point.IsEmpty;~\\
\cellcolor{red} & 0 & \verb~184~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~185~ & \verb~~\\
\cellcolor{gray} &  & \verb~186~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~187~ & \verb~        public override string ToString ()~\\
\cellcolor{gray} &  & \verb~188~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~189~ & \verb~            return "(" + Relative.X + "x" + Relative.Y + ")";~\\
\cellcolor{gray} &  & \verb~190~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~191~ & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & \verb~        public static ScreenPoint operator * (ScreenPoint a, float b)~\\
\cellcolor{green} & 4 & \verb~193~ & \verb~        {~\\
\cellcolor{green} & 12 & \verb~194~ & \verb~            return new ScreenPoint (a.Screen, () => a.Relative * b);~\\
\cellcolor{green} & 4 & \verb~195~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~196~ & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & \verb~        public static ScreenPoint operator * (ScreenPoint a, ScreenPoint b)~\\
\cellcolor{red} & 0 & \verb~198~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~199~ & \verb~            return new ScreenPoint (a.Screen, () => new Vector2 (a.Relative.X ~\\
\cellcolor{red} & 0 & \verb~200~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~201~ & \verb~~\\
\cellcolor{gray} &  & \verb~202~ & \verb~        public static ScreenPoint operator / (ScreenPoint a, float b)~\\
\cellcolor{red} & 0 & \verb~203~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~204~ & \verb~            return new ScreenPoint (a.Screen, () => a.Relative / b);~\\
\cellcolor{red} & 0 & \verb~205~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~206~ & \verb~~\\
\cellcolor{gray} &  & \verb~207~ & \verb~        public static ScreenPoint operator + (ScreenPoint a, ScreenPoint b)~\\
\cellcolor{green} & 7 & \verb~208~ & \verb~        {~\\
\cellcolor{green} & 21 & \verb~209~ & \verb~            return new ScreenPoint (a.Screen, () => a.Relative + b.Relative);~\\
\cellcolor{green} & 7 & \verb~210~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~211~ & \verb~~\\
\cellcolor{gray} &  & \verb~212~ & \verb~        public static ScreenPoint operator - (ScreenPoint a, ScreenPoint b)~\\
\cellcolor{green} & 4 & \verb~213~ & \verb~        {~\\
\cellcolor{green} & 12 & \verb~214~ & \verb~            return new ScreenPoint (a.Screen, () => a.Relative - b.Relative);~\\
\cellcolor{green} & 4 & \verb~215~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~216~ & \verb~~\\
\cellcolor{gray} &  & \verb~217~ & \verb~        public ScreenPoint ScaleX (float percent)~\\
\cellcolor{red} & 0 & \verb~218~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~219~ & \verb~            return new ScreenPoint (Screen, () => new Vector2 (Relative.X * pe~\\
\cellcolor{red} & 0 & \verb~220~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~221~ & \verb~~\\
\cellcolor{gray} &  & \verb~222~ & \verb~        public ScreenPoint ScaleY (float percent)~\\
\cellcolor{red} & 0 & \verb~223~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~224~ & \verb~            return new ScreenPoint (Screen, () => new Vector2 (Relative.X, Rel~\\
\cellcolor{red} & 0 & \verb~225~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~226~ & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & \verb~        public static bool operator == (ScreenPoint a, ScreenPoint b)~\\
\cellcolor{green} & 21 & \verb~228~ & \verb~        {~\\
\cellcolor{green} & 21 & \verb~229~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{red} & 0 & \verb~230~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~231~ & \verb~            }~\\
\cellcolor{green} & 42 & \verb~232~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 21 & \verb~233~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~234~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~235~ & \verb~            return a.Equals (b);~\\
\cellcolor{green} & 21 & \verb~236~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~237~ & \verb~~\\
\cellcolor{gray} &  & \verb~238~ & \verb~        public static bool operator != (ScreenPoint d1, ScreenPoint d2)~\\
\cellcolor{green} & 21 & \verb~239~ & \verb~        {~\\
\cellcolor{green} & 21 & \verb~240~ & \verb~            return !(d1 == d2);~\\
\cellcolor{green} & 21 & \verb~241~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~242~ & \verb~~\\
\cellcolor{gray} &  & \verb~243~ & \verb~        public bool Equals (ScreenPoint other)~\\
\cellcolor{green} & 21 & \verb~244~ & \verb~        {~\\
\cellcolor{green} & 21 & \verb~245~ & \verb~            float epsilon = 0.000001f;~\\
\cellcolor{gray} &  & \verb~246~ & \verb~~\\
\cellcolor{green} & 21 & \verb~247~ & \verb~            return other != null && System.Math.Abs (Relative.X - other.Relati~\\
\cellcolor{green} & 21 & \verb~248~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~249~ & \verb~~\\
\cellcolor{gray} &  & \verb~250~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{red} & 0 & \verb~251~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~252~ & \verb~            if (other == null) {~\\
\cellcolor{red} & 0 & \verb~253~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~254~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~255~ & \verb~            else if (other is ScreenPoint) {~\\
\cellcolor{red} & 0 & \verb~256~ & \verb~                return Equals ((ScreenPoint)other);~\\
\cellcolor{gray} &  & \verb~257~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~258~ & \verb~            else if (other is Vector2) {~\\
\cellcolor{red} & 0 & \verb~259~ & \verb~                return Relative.Equals ((Vector2)other);~\\
\cellcolor{gray} &  & \verb~260~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~261~ & \verb~            else if (other is Point) {~\\
\cellcolor{red} & 0 & \verb~262~ & \verb~                return Absolute.Equals ((Point)other);~\\
\cellcolor{gray} &  & \verb~263~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~264~ & \verb~            else if ((other = other as string) != null) {~\\
\cellcolor{red} & 0 & \verb~265~ & \verb~                return ToString ().Equals (other);~\\
\cellcolor{gray} &  & \verb~266~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~267~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~268~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~269~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~270~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~271~ & \verb~~\\
\cellcolor{gray} &  & \verb~272~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~273~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~274~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~275~ & \verb~            return Relative.GetHashCode ();~\\
\cellcolor{gray} &  & \verb~276~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~277~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~278~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Platform.SystemInfo}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Platform.SystemInfo\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Platform\textbackslash SystemInfo.cs\\ocuments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Platform\textbackslash SystemInfo-MG.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 17\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 17\\
\textbf{Total lines:} & 266\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{IsRunningOnMono()} & 1 & 100 & 100\\
\hline
\textbf{IsRunningOnMonogame(} & 1 & 100 & 100\\
\hline
\textbf{IsRunningOnLinux()} & 1 & 100 & 100\\
\hline
\textbf{IsRunningOnWindows()} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Platform\textbackslash SystemInfo.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Platform~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    public static partial class SystemInfo~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~40~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        /// Das Einstellungsverzeichnis.~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        public static string SettingsDirectory~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~46~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~47~ & \verb~                if (settingsDirectory != null) {~\\
\cellcolor{gray} &  & \verb~48~ & \verb~                    return settingsDirectory;~\\
\cellcolor{gray} &  & \verb~49~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~50~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~51~ & \verb~                    string directory;~\\
\cellcolor{gray} &  & \verb~52~ & \verb~                    if (SystemInfo.IsRunningOnLinux ()) {~\\
\cellcolor{gray} &  & \verb~53~ & \verb~                        directory = Environment.GetEnvironmentVariable ("HOME"~\\
\cellcolor{gray} &  & \verb~54~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~55~ & \verb~                    else {~\\
\cellcolor{gray} &  & \verb~56~ & \verb~                        directory = Environment.GetFolderPath (System.Environm~\\
\cellcolor{gray} &  & \verb~57~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~                    Directory.CreateDirectory (directory);~\\
\cellcolor{gray} &  & \verb~59~ & \verb~                    return settingsDirectory = directory;~\\
\cellcolor{gray} &  & \verb~60~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~            set {~\\
\cellcolor{gray} &  & \verb~63~ & \verb~                settingsDirectory = value;~\\
\cellcolor{gray} &  & \verb~64~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        }~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        private static string settingsDirectory = null;~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// Das Spielstandverzeichnis.~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        public static string SavegameDirectory~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~74~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~75~ & \verb~                string directory = SettingsDirectory + "Savegames";~\\
\cellcolor{gray} &  & \verb~76~ & \verb~                Directory.CreateDirectory (directory);~\\
\cellcolor{gray} &  & \verb~77~ & \verb~                return directory;~\\
\cellcolor{gray} &  & \verb~78~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        /// Das Bildschirmfotoverzeichnis.~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        public static string ScreenshotDirectory~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~86~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~87~ & \verb~                string directory;~\\
\cellcolor{gray} &  & \verb~88~ & \verb~                if (SystemInfo.IsRunningOnLinux ()) {~\\
\cellcolor{gray} &  & \verb~89~ & \verb~                    directory = Environment.GetEnvironmentVariable ("HOME");~\\
\cellcolor{gray} &  & \verb~90~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~91~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~92~ & \verb~                    directory = Environment.GetFolderPath (System.Environment.~\\
\cellcolor{gray} &  & \verb~93~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~                Directory.CreateDirectory (directory);~\\
\cellcolor{gray} &  & \verb~95~ & \verb~                return directory;~\\
\cellcolor{gray} &  & \verb~96~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        public static string DecodedMusicCache~\\
\cellcolor{gray} &  & \verb~100~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~101~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~102~ & \verb~                if (decodedMusicCache != null) {~\\
\cellcolor{gray} &  & \verb~103~ & \verb~                    return decodedMusicCache;~\\
\cellcolor{gray} &  & \verb~104~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~106~ & \verb~                    string directory;~\\
\cellcolor{gray} &  & \verb~107~ & \verb~                    if (SystemInfo.IsRunningOnLinux ()) {~\\
\cellcolor{gray} &  & \verb~108~ & \verb~                        directory = "/var/tmp/knot3/";~\\
\cellcolor{gray} &  & \verb~109~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~                    else {~\\
\cellcolor{gray} &  & \verb~111~ & \verb~                        directory = Environment.GetFolderPath (System.Environm~\\
\cellcolor{gray} &  & \verb~112~ & \verb~                    }~\\
\cellcolor{gray} &  & \verb~113~ & \verb~                    Directory.CreateDirectory (directory);~\\
\cellcolor{gray} &  & \verb~114~ & \verb~                    return decodedMusicCache = directory;~\\
\cellcolor{gray} &  & \verb~115~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~116~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~117~ & \verb~            set {~\\
\cellcolor{gray} &  & \verb~118~ & \verb~                decodedMusicCache = value;~\\
\cellcolor{gray} &  & \verb~119~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~120~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & \verb~        private static string decodedMusicCache = null;~\\
\cellcolor{gray} &  & \verb~123~ & \verb~~\\
\cellcolor{green} & 1 & \verb~124~ & \verb~        public static string BaseDirectory~\\
\cellcolor{gray} &  & \verb~125~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~126~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~127~ & \verb~                if (baseDirectory != null) {~\\
\cellcolor{gray} &  & \verb~128~ & \verb~                    return baseDirectory;~\\
\cellcolor{gray} &  & \verb~129~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~130~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~131~ & \verb~                    findBaseDirectory ();~\\
\cellcolor{gray} &  & \verb~132~ & \verb~                    return baseDirectory;~\\
\cellcolor{gray} &  & \verb~133~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~134~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~136~ & \verb~~\\
\cellcolor{gray} &  & \verb~137~ & \verb~        public static string RelativeBaseDirectory~\\
\cellcolor{gray} &  & \verb~138~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~139~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~140~ & \verb~                if (relativeBaseDirectory != null) {~\\
\cellcolor{gray} &  & \verb~141~ & \verb~                    return relativeBaseDirectory;~\\
\cellcolor{gray} &  & \verb~142~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~                else {~\\
\cellcolor{gray} &  & \verb~144~ & \verb~                    findBaseDirectory ();~\\
\cellcolor{gray} &  & \verb~145~ & \verb~                    return relativeBaseDirectory;~\\
\cellcolor{gray} &  & \verb~146~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~147~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~148~ & \verb~            set {~\\
\cellcolor{gray} &  & \verb~149~ & \verb~                Log.Debug ("Set Base directory: ", value);~\\
\cellcolor{gray} &  & \verb~150~ & \verb~                baseDirectory = value;~\\
\cellcolor{gray} &  & \verb~151~ & \verb~                Log.Debug ("Set Base directory (relative): ", value);~\\
\cellcolor{gray} &  & \verb~152~ & \verb~                relativeBaseDirectory = value;~\\
\cellcolor{gray} &  & \verb~153~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~157~ & \verb~        private static void findBaseDirectory ()~\\
\cellcolor{gray} &  & \verb~158~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~159~ & \verb~            string baseDir = Directory.GetCurrentDirectory ();~\\
\cellcolor{gray} &  & \verb~160~ & \verb~            string relBaseDir = "." + PathSeparator;~\\
\cellcolor{gray} &  & \verb~161~ & \verb~            string[] binDirectories = new string[] {~\\
\cellcolor{gray} &  & \verb~162~ & \verb~                "Debug",~\\
\cellcolor{gray} &  & \verb~163~ & \verb~                "Release",~\\
\cellcolor{gray} &  & \verb~164~ & \verb~                "x86",~\\
\cellcolor{gray} &  & \verb~165~ & \verb~                "bin",~\\
\cellcolor{gray} &  & \verb~166~ & \verb~                "Game",~\\
\cellcolor{gray} &  & \verb~167~ & \verb~                "ModelEditor",~\\
\cellcolor{gray} &  & \verb~168~ & \verb~                "Tools",~\\
\cellcolor{gray} &  & \verb~169~ & \verb~                "VisualTests",~\\
\cellcolor{gray} &  & \verb~170~ & \verb~            };~\\
\cellcolor{gray} &  & \verb~171~ & \verb~            foreach (string dir in binDirectories) {~\\
\cellcolor{gray} &  & \verb~172~ & \verb~                if (baseDir.ToLower ().EndsWith (dir.ToLower ())) {~\\
\cellcolor{gray} &  & \verb~173~ & \verb~                    baseDir = baseDir.Substring (0, baseDir.Length - dir.Lengt~\\
\cellcolor{gray} &  & \verb~174~ & \verb~                    relBaseDir += ".." + PathSeparator;~\\
\cellcolor{gray} &  & \verb~175~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~176~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~177~ & \verb~            Log.Debug ("Base directory: ", baseDir);~\\
\cellcolor{gray} &  & \verb~178~ & \verb~            baseDirectory = baseDir;~\\
\cellcolor{gray} &  & \verb~179~ & \verb~            Log.Debug ("Base directory (relative): ", relBaseDir);~\\
\cellcolor{gray} &  & \verb~180~ & \verb~            relativeBaseDirectory = relBaseDir;~\\
\cellcolor{gray} &  & \verb~181~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~182~ & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & \verb~        private static string relativeBaseDirectory = null;~\\
\cellcolor{gray} &  & \verb~184~ & \verb~        private static string baseDirectory = null;~\\
\cellcolor{gray} &  & \verb~185~ & \verb~        public readonly static char PathSeparator = Path.DirectorySeparatorCha~\\
\cellcolor{gray} &  & \verb~186~ & \verb~~\\
\cellcolor{green} & 1 & \verb~187~ & \verb~        public static string RelativeContentDirectory~\\
\cellcolor{green} & 1 & \verb~188~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~189~ & \verb~            get {~\\
\cellcolor{gray} &  & \verb~190~ & \verb~                return SystemInfo.RelativeBaseDirectory + "Content" + PathSepa~\\
\cellcolor{gray} &  & \verb~191~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~192~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~193~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~194~ & \verb~}~\\
\end{longtable}
\subsubsection{ocuments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Platform\textbackslash SystemInfo-MG.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Microsoft.Xna.Framework;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~using Microsoft.Xna.Framework.Audio;~\\
\cellcolor{gray} &  & \verb~39~ & \verb~using Microsoft.Xna.Framework.Content;~\\
\cellcolor{gray} &  & \verb~40~ & \verb~using Microsoft.Xna.Framework.Graphics;~\\
\cellcolor{gray} &  & \verb~41~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & \verb~using Knot3.Framework.Core;~\\
\cellcolor{gray} &  & \verb~44~ & \verb~using Knot3.Framework.Input;~\\
\cellcolor{gray} &  & \verb~45~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~namespace Knot3.Framework.Platform~\\
\cellcolor{gray} &  & \verb~49~ & \verb~{~\\
\cellcolor{gray} &  & \verb~50~ & \verb~    public static partial class SystemInfo~\\
\cellcolor{gray} &  & \verb~51~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        public static bool IsRunningOnMono ()~\\
\cellcolor{green} & 1 & \verb~53~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~54~ & \verb~            return Type.GetType ("Mono.Runtime") != null;~\\
\cellcolor{green} & 1 & \verb~55~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        public static bool IsRunningOnMonogame ()~\\
\cellcolor{green} & 6 & \verb~58~ & \verb~        {~\\
\cellcolor{green} & 6 & \verb~59~ & \verb~            return true;~\\
\cellcolor{green} & 6 & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        public static bool IsRunningOnLinux ()~\\
\cellcolor{green} & 447 & \verb~63~ & \verb~        {~\\
\cellcolor{green} & 447 & \verb~64~ & \verb~            return Environment.OSVersion.Platform == PlatformID.Unix;~\\
\cellcolor{green} & 447 & \verb~65~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        public static bool IsRunningOnWindows ()~\\
\cellcolor{green} & 1 & \verb~68~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~69~ & \verb~            return !IsRunningOnLinux ();~\\
\cellcolor{green} & 1 & \verb~70~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.BooleanOption}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.BooleanOption\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash BooleanOption.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 10\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 68\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 66.67\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash BooleanOption.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~34~ & \verb~{~\\
\cellcolor{gray} &  & \verb~35~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~36~ & \verb~    /// Diese Klasse repräsentiert eine Option, welche die Werte \glqq Wahr\gr~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    public sealed class BooleanOption : DistinctOption~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~40~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurückgibt.~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        public new bool Value~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~45~ & \verb~            get {~\\
\cellcolor{green} & 7 & \verb~46~ & \verb~                return base.Value == ConfigFile.True ? true : false;~\\
\cellcolor{green} & 7 & \verb~47~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~48~ & \verb~            set {~\\
\cellcolor{green} & 3 & \verb~49~ & \verb~                base.Value = value ? ConfigFile.True : ConfigFile.False;~\\
\cellcolor{green} & 3 & \verb~50~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{green} & 1 & \verb~53~ & \verb~        public new static string[] ValidValues = new string[] {~\\
\cellcolor{gray} &  & \verb~54~ & \verb~            ConfigFile.True,~\\
\cellcolor{gray} &  & \verb~55~ & \verb~            ConfigFile.False~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        };~\\
\cellcolor{gray} &  & \verb~57~ & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// Erstellt eine neue Option, welche die Werte \glqq Wahr\grqq oder \~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        /// angegebenen Abschnitt der angegebenen Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// [base=section, name, defaultValue?ConfigFile.True:ConfigFile.False~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~63~ & \verb~        public BooleanOption (string section, string name, bool defaultValue, ~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        : base (section, name, defaultValue?ConfigFile.True:ConfigFile.False, ~\\
\cellcolor{green} & 1 & \verb~65~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~66~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~67~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.Config}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.Config\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Config.cs}\end{minipage} \\
\textbf{Coverage:} & 66.6\%\\
\textbf{Covered lines:} & 10\\
\textbf{Uncovered lines:} & 5\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 73\\
\end{longtable}
\subsection{File(s)}
\subsubsection{Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Config.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// Eine statische Klasse, die eine Referenz auf die zentrale Einstellungs~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    public static class Config~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// Die zentrale Einstellungsdatei des Spiels.~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public static ConfigFile Default~\\
\cellcolor{green} & 42 & \verb~47~ & \verb~        {~\\
\cellcolor{green} & 42 & \verb~48~ & \verb~            get {~\\
\cellcolor{red} & 0 & \verb~49~ & \verb~                if (_default == null) {~\\
\cellcolor{red} & 0 & \verb~50~ & \verb~                    _default = new ConfigFile (SystemInfo.SettingsDirectory + ~\\
\cellcolor{green} & 42 & \verb~51~ & \verb~                }~\\
\cellcolor{green} & 42 & \verb~52~ & \verb~                return _default;~\\
\cellcolor{green} & 1 & \verb~53~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~54~ & \verb~            set {~\\
\cellcolor{green} & 1 & \verb~55~ & \verb~                _default = value;~\\
\cellcolor{gray} &  & \verb~56~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        private static ConfigFile _default;~\\
\cellcolor{gray} &  & \verb~60~ & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        public static ConfigFile Models~\\
\cellcolor{green} & 4 & \verb~62~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~63~ & \verb~            get {~\\
\cellcolor{green} & 4 & \verb~64~ & \verb~                if (_models == null) {~\\
\cellcolor{red} & 0 & \verb~65~ & \verb~                    _models = new ConfigFile (SystemInfo.RelativeContentDirect~\\
\cellcolor{red} & 0 & \verb~66~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~67~ & \verb~                return _models;~\\
\cellcolor{gray} &  & \verb~68~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~70~ & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        private static ConfigFile _models;~\\
\cellcolor{gray} &  & \verb~72~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.ConfigFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.ConfigFile\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash ConfigFile.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 55\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 55\\
\textbf{Total lines:} & 155\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 66.67\\
\hline
\textbf{SetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{GetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{SetOption(...)} & 2 & 100 & 100\\
\hline
\textbf{GetOption(...)} & 4 & 100 & 80\\
\hline
\textbf{SetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{GetOption(...)} & 1 & 100 & 100\\
\hline
\textbf{floatToString(...)} & 1 & 100 & 100\\
\hline
\textbf{stringToFloat(...)} & 2 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{al\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash ConfigFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// Repräsentiert eine Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public sealed class ConfigFile~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// Die Repräsentation des Wahrheitswerts "wahr" als String in einer E~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// </summary>~\\
\cellcolor{green} & 489 & \verb~45~ & \verb~        public static string True { get { return "true"; } }~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// Die Repräsentation des Wahrheitswerts "falsch" als String in einer~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// </summary>~\\
\cellcolor{green} & 450 & \verb~50~ & \verb~        public static string False { get { return "false"; } }~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        private string Filename;~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        private IniFile ini;~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{green} & 26 & \verb~55~ & \verb~        public ConfigFile (string filename)~\\
\cellcolor{green} & 26 & \verb~56~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~57~ & \verb~            // load ini file~\\
\cellcolor{green} & 26 & \verb~58~ & \verb~            Filename = filename;~\\
\cellcolor{gray} &  & \verb~59~ & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & \verb~            // create a new ini parser~\\
\cellcolor{green} & 48 & \verb~61~ & \verb~            using (StreamWriter w = File.AppendText (Filename)) {~\\
\cellcolor{green} & 22 & \verb~62~ & \verb~            }~\\
\cellcolor{green} & 22 & \verb~63~ & \verb~            ini = new IniFile (Filename);~\\
\cellcolor{green} & 22 & \verb~64~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        /// Setzt den Wert der Option mit dem angegebenen Namen in den angegeb~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        public void SetOption (string section, string option, string _value)~\\
\cellcolor{green} & 336 & \verb~70~ & \verb~        {~\\
\cellcolor{green} & 336 & \verb~71~ & \verb~            ini [section, option] = _value;~\\
\cellcolor{green} & 336 & \verb~72~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~73~ & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// Gibt den aktuell in der Datei vorhandenen Wert für die angegebene ~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        public string GetOption (string section, string option, string default~\\
\cellcolor{green} & 625 & \verb~78~ & \verb~        {~\\
\cellcolor{green} & 625 & \verb~79~ & \verb~            return ini [section, option, defaultValue];~\\
\cellcolor{green} & 625 & \verb~80~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~81~ & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// Setzt den Wert der Option mit dem angegebenen Namen in den angegeb~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        public void SetOption (string section, string option, bool _value)~\\
\cellcolor{green} & 100 & \verb~86~ & \verb~        {~\\
\cellcolor{green} & 100 & \verb~87~ & \verb~            SetOption (section, option, _value ? True : False);~\\
\cellcolor{green} & 100 & \verb~88~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~91~ & \verb~        /// Gibt den aktuell in der Datei vorhandenen Wert für die angegebene ~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~93~ & \verb~        public bool GetOption (string section, string option, bool defaultValu~\\
\cellcolor{green} & 100 & \verb~94~ & \verb~        {~\\
\cellcolor{green} & 100 & \verb~95~ & \verb~            return GetOption (section, option, defaultValue ? True : False) ==~\\
\cellcolor{green} & 100 & \verb~96~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~~\\
\cellcolor{gray} &  & \verb~98~ & \verb~        public void SetOption (string section, string option, float _value)~\\
\cellcolor{green} & 101 & \verb~99~ & \verb~        {~\\
\cellcolor{green} & 101 & \verb~100~ & \verb~            SetOption (section, option, floatToString (_value));~\\
\cellcolor{green} & 101 & \verb~101~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~102~ & \verb~~\\
\cellcolor{gray} &  & \verb~103~ & \verb~        public float GetOption (string section, string option, float defaultVa~\\
\cellcolor{green} & 230 & \verb~104~ & \verb~        {~\\
\cellcolor{green} & 230 & \verb~105~ & \verb~            return stringToFloat (GetOption (section, option, floatToString (d~\\
\cellcolor{green} & 230 & \verb~106~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        private string floatToString (float f)~\\
\cellcolor{green} & 331 & \verb~109~ & \verb~        {~\\
\cellcolor{green} & 331 & \verb~110~ & \verb~            return String.Empty + ((int) (f * 1000)).ToString ();~\\
\cellcolor{green} & 331 & \verb~111~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~112~ & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & \verb~        private float stringToFloat (string s)~\\
\cellcolor{green} & 230 & \verb~114~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~115~ & \verb~            int i;~\\
\cellcolor{green} & 230 & \verb~116~ & \verb~            bool result = Int32.TryParse (s, out i);~\\
\cellcolor{green} & 360 & \verb~117~ & \verb~            if (true == result) {~\\
\cellcolor{green} & 130 & \verb~118~ & \verb~                return ((float)i) / 1000f;~\\
\cellcolor{gray} &  & \verb~119~ & \verb~            }~\\
\cellcolor{green} & 100 & \verb~120~ & \verb~            else {~\\
\cellcolor{green} & 100 & \verb~121~ & \verb~                return 0;~\\
\cellcolor{gray} &  & \verb~122~ & \verb~            }~\\
\cellcolor{green} & 230 & \verb~123~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~124~ & \verb~~\\
\cellcolor{gray} &  & \verb~125~ & \verb~        public bool this [string section, string option, bool defaultValue = f~\\
\cellcolor{gray} &  & \verb~126~ & \verb~        {~\\
\cellcolor{green} & 100 & \verb~127~ & \verb~            get {~\\
\cellcolor{green} & 100 & \verb~128~ & \verb~                return GetOption (section, option, defaultValue);~\\
\cellcolor{green} & 100 & \verb~129~ & \verb~            }~\\
\cellcolor{green} & 100 & \verb~130~ & \verb~            set {~\\
\cellcolor{green} & 100 & \verb~131~ & \verb~                SetOption (section, option, value);~\\
\cellcolor{green} & 100 & \verb~132~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~133~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~134~ & \verb~~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        public float this [string section, string option, float defaultValue =~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        {~\\
\cellcolor{green} & 230 & \verb~137~ & \verb~            get {~\\
\cellcolor{green} & 230 & \verb~138~ & \verb~                return GetOption (section, option, defaultValue);~\\
\cellcolor{green} & 230 & \verb~139~ & \verb~            }~\\
\cellcolor{green} & 101 & \verb~140~ & \verb~            set {~\\
\cellcolor{green} & 101 & \verb~141~ & \verb~                SetOption (section, option, value);~\\
\cellcolor{green} & 101 & \verb~142~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~144~ & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & \verb~        public string this [string section, string option, string defaultValue~\\
\cellcolor{gray} &  & \verb~146~ & \verb~        {~\\
\cellcolor{green} & 295 & \verb~147~ & \verb~            get {~\\
\cellcolor{green} & 295 & \verb~148~ & \verb~                return GetOption (section, option, defaultValue);~\\
\cellcolor{green} & 295 & \verb~149~ & \verb~            }~\\
\cellcolor{green} & 135 & \verb~150~ & \verb~            set {~\\
\cellcolor{green} & 135 & \verb~151~ & \verb~                SetOption (section, option, value);~\\
\cellcolor{green} & 135 & \verb~152~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~153~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~155~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.DistinctOption}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.DistinctOption\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ocuments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash DistinctOption.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 22\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 22\\
\textbf{Total lines:} & 85\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 3 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ocuments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash DistinctOption.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// Diese Klasse repräsentiert eine Option, die einen Wert aus einer disti~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public class DistinctOption : Option~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// Eine Menge von Texten, welche die für die Option gültigen Werte be~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// </summary>~\\
\cellcolor{green} & 39 & \verb~45~ & \verb~        public HashSet<string> ValidValues { get; private set; }~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{green} & 11 & \verb~47~ & \verb~        public virtual Dictionary<string,string> DisplayValidValues { get; pri~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurück gibt~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        public override string Value~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        {~\\
\cellcolor{green} & 28 & \verb~53~ & \verb~            get {~\\
\cellcolor{green} & 28 & \verb~54~ & \verb~                return base.Value;~\\
\cellcolor{green} & 28 & \verb~55~ & \verb~            }~\\
\cellcolor{green} & 13 & \verb~56~ & \verb~            set {~\\
\cellcolor{green} & 22 & \verb~57~ & \verb~                if (ValidValues.Contains (value)) {~\\
\cellcolor{green} & 9 & \verb~58~ & \verb~                    base.Value = value;~\\
\cellcolor{green} & 9 & \verb~59~ & \verb~                }~\\
\cellcolor{green} & 4 & \verb~60~ & \verb~                else {~\\
\cellcolor{green} & 4 & \verb~61~ & \verb~                    base.Value = DefaultValue;~\\
\cellcolor{green} & 4 & \verb~62~ & \verb~                }~\\
\cellcolor{green} & 13 & \verb~63~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        public virtual string DisplayValue~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~67~ & \verb~            get {~\\
\cellcolor{green} & 7 & \verb~68~ & \verb~                return Value;~\\
\cellcolor{green} & 7 & \verb~69~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// Erstellt eine neue Option, die einen der angegebenen Werte aus val~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// angegebenen Abschnitt der angegebenen Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        /// [base=section, name, defaultValue, configFile]~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        /// </summary>~\\
\cellcolor{green} & 7 & \verb~77~ & \verb~        public DistinctOption (string section, string name, string defaultValu~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        : base (section, name, defaultValue, configFile)~\\
\cellcolor{green} & 7 & \verb~79~ & \verb~        {~\\
\cellcolor{green} & 7 & \verb~80~ & \verb~            ValidValues = new HashSet<string> (validValues);~\\
\cellcolor{green} & 7 & \verb~81~ & \verb~            ValidValues.Add (defaultValue);~\\
\cellcolor{green} & 365 & \verb~82~ & \verb~            DisplayValidValues = new Dictionary<string,string> (ValidValues.To~\\
\cellcolor{green} & 7 & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.FileUtility}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.FileUtility\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash FileUtility.cs}\end{minipage} \\
\textbf{Coverage:} & 97.2\%\\
\textbf{Covered lines:} & 35\\
\textbf{Uncovered lines:} & 1\\
\textbf{Coverable lines:} & 36\\
\textbf{Total lines:} & 107\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{ConvertToFileName(..} & 2 & 100 & 100\\
\hline
\textbf{GetHash(...)} & 1 & 100 & 100\\
\hline
\textbf{ToMD5Hash(...)} & 2 & 77.78 & 66.67\\
\hline
\textbf{SearchFiles(...)} & 3 & 100 & 80\\
\hline
\textbf{SearchFiles(...)} & 3 & 100 & 80\\
\hline
\textbf{MoveNext()} & 5 & 100 & 71.43\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash FileUtility.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using System.Security.Cryptography;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using System.Text;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// Eine Hilfsklasse für Dateioperationen.~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    public static class FileUtility~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// Konvertiert einen Namen eines Knotens oder einer Challenge in eine~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        public static string ConvertToFileName (string name)~\\
\cellcolor{green} & 92 & \verb~50~ & \verb~        {~\\
\cellcolor{green} & 92 & \verb~51~ & \verb~            char[] arr = name.ToCharArray ();~\\
\cellcolor{green} & 670 & \verb~52~ & \verb~            arr = Array.FindAll<char> (arr, (c => (char.IsLetterOrDigit (c)~\\
\cellcolor{gray} &  & \verb~53~ & \verb~                                                   || char.IsWhiteSpace (c)~\\
\cellcolor{gray} &  & \verb~54~ & \verb~                                                   || c == '-'))~\\
\cellcolor{gray} &  & \verb~55~ & \verb~                                      );~\\
\cellcolor{green} & 92 & \verb~56~ & \verb~            return new string (arr);~\\
\cellcolor{green} & 92 & \verb~57~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        /// Liefert einen Hash-Wert zu der durch filename spezifizierten Datei~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        public static string GetHash (string filename)~\\
\cellcolor{green} & 4 & \verb~63~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~64~ & \verb~            return string.Join ("\n", FileUtility.ReadFrom (filename)).ToMD5Ha~\\
\cellcolor{green} & 4 & \verb~65~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~66~ & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        public static string ToMD5Hash (this string TextToHash)~\\
\cellcolor{green} & 4 & \verb~68~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~69~ & \verb~            if (string.IsNullOrEmpty (TextToHash)) {~\\
\cellcolor{red} & 0 & \verb~70~ & \verb~                return string.Empty;~\\
\cellcolor{gray} &  & \verb~71~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{green} & 4 & \verb~73~ & \verb~            MD5 md5 = new MD5CryptoServiceProvider ();~\\
\cellcolor{green} & 4 & \verb~74~ & \verb~            byte[] textToHash = Encoding.Default.GetBytes (TextToHash);~\\
\cellcolor{green} & 4 & \verb~75~ & \verb~            byte[] result = md5.ComputeHash (textToHash);~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{green} & 4 & \verb~77~ & \verb~            return System.BitConverter.ToString (result);~\\
\cellcolor{green} & 4 & \verb~78~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        public static IEnumerable<string> ReadFrom (string file)~\\
\cellcolor{green} & 17 & \verb~81~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            string line;~\\
\cellcolor{green} & 31 & \verb~83~ & \verb~            using (var reader = File.OpenText (file)) {~\\
\cellcolor{green} & 146 & \verb~84~ & \verb~                while ((line = reader.ReadLine ()) != null) {~\\
\cellcolor{green} & 66 & \verb~85~ & \verb~                    yield return line;~\\
\cellcolor{green} & 66 & \verb~86~ & \verb~                }~\\
\cellcolor{green} & 14 & \verb~87~ & \verb~            }~\\
\cellcolor{green} & 14 & \verb~88~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~89~ & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & \verb~        public static void SearchFiles (IEnumerable<string> directories, IEnum~\\
\cellcolor{green} & 2 & \verb~91~ & \verb~        {~\\
\cellcolor{green} & 18 & \verb~92~ & \verb~            foreach (string directory in directories) {~\\
\cellcolor{green} & 4 & \verb~93~ & \verb~                SearchFiles (directory, extensions, add);~\\
\cellcolor{green} & 4 & \verb~94~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        public static void SearchFiles (string directory, IEnumerable<string> ~\\
\cellcolor{green} & 9 & \verb~98~ & \verb~        {~\\
\cellcolor{green} & 9 & \verb~99~ & \verb~            Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 9 & \verb~100~ & \verb~            var files = Directory.GetFiles (directory, "*.*", SearchOption.All~\\
\cellcolor{green} & 141 & \verb~101~ & \verb~                        .Where (s => extensions.Any (e => s.EndsWith (e)));~\\
\cellcolor{green} & 69 & \verb~102~ & \verb~            foreach (string file in files) {~\\
\cellcolor{green} & 14 & \verb~103~ & \verb~                add (file);~\\
\cellcolor{green} & 14 & \verb~104~ & \verb~            }~\\
\cellcolor{green} & 9 & \verb~105~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.FloatOption}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.FloatOption\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash FloatOption.cs}\end{minipage} \\
\textbf{Coverage:} & 92\%\\
\textbf{Covered lines:} & 23\\
\textbf{Uncovered lines:} & 2\\
\textbf{Coverable lines:} & 25\\
\textbf{Total lines:} & 96\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{convertToString(...)} & 1 & 100 & 100\\
\hline
\textbf{stringToFloat(...)} & 2 & 75 & 66.67\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{l\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash FloatOption.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~37~ & \verb~{~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// Diese Klasse repräsentiert eine Option, welche die Werte \glqq Wahr\gr~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    public sealed class FloatOption : DistinctOption~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurückgibt.~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        public new float Value~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~48~ & \verb~            get {~\\
\cellcolor{green} & 4 & \verb~49~ & \verb~                return stringToFloat (base.Value);~\\
\cellcolor{green} & 4 & \verb~50~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~51~ & \verb~            set {~\\
\cellcolor{green} & 2 & \verb~52~ & \verb~                base.Value = convertToString (value);~\\
\cellcolor{green} & 2 & \verb~53~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        public override string DisplayValue~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~58~ & \verb~            get {~\\
\cellcolor{green} & 4 & \verb~59~ & \verb~                return String.Empty + stringToFloat (base.Value);~\\
\cellcolor{green} & 4 & \verb~60~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        public override Dictionary<string,string> DisplayValidValues~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        {~\\
\cellcolor{green} & 2 & \verb~65~ & \verb~            get {~\\
\cellcolor{green} & 22 & \verb~66~ & \verb~                return new Dictionary<string, string>(base.ValidValues.ToDicti~\\
\cellcolor{green} & 2 & \verb~67~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        /// Erstellt eine neue Option, welche die Werte \glqq Wahr\grqq oder \~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        /// angegebenen Abschnitt der angegebenen Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~73~ & \verb~        /// [base=section, name, defaultValue?ConfigFile.True:ConfigFile.False~\\
\cellcolor{gray} &  & \verb~74~ & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~75~ & \verb~        public FloatOption (string section, string name, float defaultValue, I~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        : base (section, name, convertToString ( defaultValue),validValues.Sel~\\
\cellcolor{green} & 1 & \verb~77~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~78~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        private static string convertToString (float f)~\\
\cellcolor{green} & 8 & \verb~81~ & \verb~        {~\\
\cellcolor{green} & 8 & \verb~82~ & \verb~            return (String.Empty + (int)(f * 1000f));~\\
\cellcolor{green} & 8 & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        private static float stringToFloat (string s)~\\
\cellcolor{green} & 18 & \verb~85~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~86~ & \verb~            int i;~\\
\cellcolor{green} & 18 & \verb~87~ & \verb~            bool result = Int32.TryParse (s, out i);~\\
\cellcolor{green} & 36 & \verb~88~ & \verb~            if (true == result) {~\\
\cellcolor{green} & 18 & \verb~89~ & \verb~                return ((float)i) / 1000f;~\\
\cellcolor{gray} &  & \verb~90~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~                return 0;~\\
\cellcolor{gray} &  & \verb~93~ & \verb~            }~\\
\cellcolor{green} & 18 & \verb~94~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~95~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.IniFile}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.IniFile\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash IniFile.cs}\end{minipage} \\
\textbf{Coverage:} & 96.9\%\\
\textbf{Covered lines:} & 64\\
\textbf{Uncovered lines:} & 2\\
\textbf{Coverable lines:} & 66\\
\textbf{Total lines:} & 140\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 9 & 100 & 70.59\\
\hline
\textbf{Save()} & 8 & 100 & 80\\
\hline
\textbf{StripComments(...)} & 3 & 66.67 & 60\\
\hline
\textbf{Encode(...)} & 1 & 100 & 100\\
\hline
\textbf{Decode(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash IniFile.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~38~ & \verb~{~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    public sealed class IniFile : IDisposable~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~41~ & \verb~        private string Filename;~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        public Dictionary<string, Dictionary<string, string>> Data;~\\
\cellcolor{gray} &  & \verb~43~ & \verb~~\\
\cellcolor{green} & 22 & \verb~44~ & \verb~        public IniFile (string filename)~\\
\cellcolor{green} & 22 & \verb~45~ & \verb~        {~\\
\cellcolor{green} & 22 & \verb~46~ & \verb~            Data = new Dictionary<string, Dictionary<string, string>> ();~\\
\cellcolor{green} & 22 & \verb~47~ & \verb~            Filename = filename;~\\
\cellcolor{green} & 44 & \verb~48~ & \verb~            if (File.Exists (filename)) {~\\
\cellcolor{green} & 44 & \verb~49~ & \verb~                using (StreamReader reader = new StreamReader (filename)) {~\\
\cellcolor{green} & 22 & \verb~50~ & \verb~                    string section = null;~\\
\cellcolor{green} & 126 & \verb~51~ & \verb~                    while (reader.Peek () != -1) {~\\
\cellcolor{green} & 52 & \verb~52~ & \verb~                        string line = StripComments (reader.ReadLine ().Trim (~\\
\cellcolor{green} & 78 & \verb~53~ & \verb~                        if (line.StartsWith ("[") && line.EndsWith ("]")) {~\\
\cellcolor{green} & 26 & \verb~54~ & \verb~                            section = line.Substring (1, line.Length - 2);~\\
\cellcolor{green} & 52 & \verb~55~ & \verb~                            if (!Data.ContainsKey (section)) {~\\
\cellcolor{green} & 26 & \verb~56~ & \verb~                                Data [section] = new Dictionary<string,string>~\\
\cellcolor{green} & 26 & \verb~57~ & \verb~                            }~\\
\cellcolor{green} & 26 & \verb~58~ & \verb~                        }~\\
\cellcolor{green} & 52 & \verb~59~ & \verb~                        else if (line.Contains ("=")) {~\\
\cellcolor{green} & 26 & \verb~60~ & \verb~                            string[] parts = line.Split ('=');~\\
\cellcolor{green} & 52 & \verb~61~ & \verb~                            if (section != null) {~\\
\cellcolor{green} & 26 & \verb~62~ & \verb~                                Data [section] [Decode (parts [0].Trim ())] = ~\\
\cellcolor{green} & 26 & \verb~63~ & \verb~                            }~\\
\cellcolor{green} & 26 & \verb~64~ & \verb~                        }~\\
\cellcolor{green} & 52 & \verb~65~ & \verb~                    }~\\
\cellcolor{green} & 22 & \verb~66~ & \verb~                }~\\
\cellcolor{green} & 22 & \verb~67~ & \verb~            }~\\
\cellcolor{green} & 22 & \verb~68~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        public void Dispose ()~\\
\cellcolor{gray} &  & \verb~72~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~73~ & \verb~            Dispose (true);~\\
\cellcolor{gray} &  & \verb~74~ & \verb~            GC.SuppressFinalize (this);~\\
\cellcolor{gray} &  & \verb~75~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        private void Dispose (bool disposing)~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~80~ & \verb~            if (disposing) {~\\
\cellcolor{gray} &  & \verb~81~ & \verb~                Save ();~\\
\cellcolor{gray} &  & \verb~82~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        public void Save ()~\\
\cellcolor{green} & 447 & \verb~86~ & \verb~        {~\\
\cellcolor{green} & 894 & \verb~87~ & \verb~            using (StreamWriter writer = new StreamWriter (Filename)) {~\\
\cellcolor{green} & 14049 & \verb~88~ & \verb~                foreach (string section in Data.Keys.OrderBy (x => x)) {~\\
\cellcolor{green} & 3177 & \verb~89~ & \verb~                    writer.WriteLine ("[" + section + "]");~\\
\cellcolor{green} & 132319 & \verb~90~ & \verb~                    foreach (string key  in Data [section].Keys.OrderBy (x => ~\\
\cellcolor{green} & 30697 & \verb~91~ & \verb~                        writer.WriteLine (Encode (key) + "=" + Encode (Data [s~\\
\cellcolor{green} & 30697 & \verb~92~ & \verb~                    }~\\
\cellcolor{green} & 3177 & \verb~93~ & \verb~                }~\\
\cellcolor{green} & 447 & \verb~94~ & \verb~            }~\\
\cellcolor{green} & 447 & \verb~95~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & \verb~        private static string StripComments (string line)~\\
\cellcolor{green} & 52 & \verb~98~ & \verb~        {~\\
\cellcolor{green} & 104 & \verb~99~ & \verb~            if (line != null) {~\\
\cellcolor{green} & 52 & \verb~100~ & \verb~                if (line.Contains ("//")) {~\\
\cellcolor{red} & 0 & \verb~101~ & \verb~                    return line.Remove (line.IndexOf ("//")).Trim ();~\\
\cellcolor{gray} &  & \verb~102~ & \verb~                }~\\
\cellcolor{green} & 52 & \verb~103~ & \verb~                return line.Trim ();~\\
\cellcolor{gray} &  & \verb~104~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~105~ & \verb~            return string.Empty;~\\
\cellcolor{green} & 52 & \verb~106~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~107~ & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        public string this [string section, string key, string defaultValue = ~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        {~\\
\cellcolor{green} & 625 & \verb~110~ & \verb~            get {~\\
\cellcolor{green} & 641 & \verb~111~ & \verb~                if (!Data.ContainsKey (section)) {~\\
\cellcolor{green} & 16 & \verb~112~ & \verb~                    Data [section] = new Dictionary<string,string> ();~\\
\cellcolor{green} & 16 & \verb~113~ & \verb~                }~\\
\cellcolor{green} & 736 & \verb~114~ & \verb~                if (!Data [section].ContainsKey (key)) {~\\
\cellcolor{green} & 111 & \verb~115~ & \verb~                    Data [section] [key] = defaultValue;~\\
\cellcolor{green} & 111 & \verb~116~ & \verb~                    Save ();~\\
\cellcolor{green} & 111 & \verb~117~ & \verb~                }~\\
\cellcolor{green} & 625 & \verb~118~ & \verb~                string value = Data [section] [key];~\\
\cellcolor{green} & 625 & \verb~119~ & \verb~                return value;~\\
\cellcolor{green} & 625 & \verb~120~ & \verb~            }~\\
\cellcolor{green} & 336 & \verb~121~ & \verb~            set {~\\
\cellcolor{green} & 341 & \verb~122~ & \verb~                if (!Data.ContainsKey (section)) {~\\
\cellcolor{green} & 5 & \verb~123~ & \verb~                    Data [section] = new Dictionary<string,string> ();~\\
\cellcolor{green} & 5 & \verb~124~ & \verb~                }~\\
\cellcolor{green} & 336 & \verb~125~ & \verb~                Data [section] [key] = value;~\\
\cellcolor{green} & 336 & \verb~126~ & \verb~                Save ();~\\
\cellcolor{green} & 336 & \verb~127~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~128~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & \verb~        private string Encode (string text)~\\
\cellcolor{green} & 61394 & \verb~131~ & \verb~        {~\\
\cellcolor{green} & 61394 & \verb~132~ & \verb~            return text.Replace ("\r", "").Replace ("\n", "\\n");~\\
\cellcolor{green} & 61394 & \verb~133~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~134~ & \verb~~\\
\cellcolor{gray} &  & \verb~135~ & \verb~        private string Decode (string text)~\\
\cellcolor{green} & 52 & \verb~136~ & \verb~        {~\\
\cellcolor{green} & 52 & \verb~137~ & \verb~            return text.Replace ("\\n", "\n");~\\
\cellcolor{green} & 52 & \verb~138~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~139~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~140~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.KeyOption}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.KeyOption\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash KeyOption.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 10\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 10\\
\textbf{Total lines:} & 62\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash KeyOption.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using Microsoft.Xna.Framework.Input;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & \verb~using Knot3.Framework.Utilities;~\\
\cellcolor{gray} &  & \verb~37~ & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~39~ & \verb~{~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public class KeyOption : DistinctOption~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// Eine Eigenschaft, die den aktuell abgespeicherten Wert zurückgibt.~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        public new Keys Value~\\
\cellcolor{gray} &  & \verb~46~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~47~ & \verb~            get {~\\
\cellcolor{green} & 3 & \verb~48~ & \verb~                return base.Value.ToEnumValue<Keys> ();~\\
\cellcolor{green} & 3 & \verb~49~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~50~ & \verb~            set {~\\
\cellcolor{green} & 1 & \verb~51~ & \verb~                base.Value = value.ToEnumDescription<Keys> ();~\\
\cellcolor{green} & 1 & \verb~52~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{green} & 1 & \verb~55~ & \verb~        public new static IEnumerable<string> ValidValues = typeof (Keys).ToEn~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{green} & 1 & \verb~57~ & \verb~        public KeyOption (string section, string name, Keys defaultValue, Conf~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        : base (section, name, defaultValue.ToEnumDescription<Keys> (), ValidV~\\
\cellcolor{green} & 1 & \verb~59~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~62~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.Language}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.Language\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{scal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Language.cs}\end{minipage} \\
\textbf{Coverage:} & 87.8\%\\
\textbf{Covered lines:} & 29\\
\textbf{Uncovered lines:} & 4\\
\textbf{Coverable lines:} & 33\\
\textbf{Total lines:} & 110\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Inequality(...)} & 1 & 100 & 100\\
\hline
\textbf{op\_Equality(...)} & 4 & 88.89 & 71.43\\
\hline
\textbf{Equals(...)} & 2 & 100 & 66.67\\
\hline
\textbf{Equals(...)} & 3 & 60 & 60\\
\hline
\textbf{op\_Implicit(...)} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{scal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Language.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~35~ & \verb~{~\\
\cellcolor{gray} &  & \verb~36~ & \verb~    public class Language~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~38~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & \verb~        /// Der Sprachcode der Sprache.~\\
\cellcolor{gray} &  & \verb~40~ & \verb~        /// </summary>~\\
\cellcolor{green} & 122 & \verb~41~ & \verb~        public string Code { get; private set; }~\\
\cellcolor{gray} &  & \verb~42~ & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// Der Anzeigename der Sprache.~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        /// </summary>~\\
\cellcolor{green} & 93 & \verb~46~ & \verb~        public string DisplayName { get { return Localization ["language", "di~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Die Datei, welche Informationen für die Lokalisierung enthält.~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// </summary>~\\
\cellcolor{green} & 62 & \verb~51~ & \verb~        public ConfigFile Localization { get; private set; }~\\
\cellcolor{gray} &  & \verb~52~ & \verb~~\\
\cellcolor{green} & 17 & \verb~53~ & \verb~        public Language (string file)~\\
\cellcolor{green} & 17 & \verb~54~ & \verb~        {~\\
\cellcolor{green} & 17 & \verb~55~ & \verb~            Code = Path.GetFileNameWithoutExtension (file).ToLower ();~\\
\cellcolor{green} & 17 & \verb~56~ & \verb~            file = Localizer.LanguageDirectory + Code + ".ini";~\\
\cellcolor{green} & 17 & \verb~57~ & \verb~            Localization = new ConfigFile (file);~\\
\cellcolor{green} & 17 & \verb~58~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        public static bool operator != (Language a, Language b)~\\
\cellcolor{green} & 4 & \verb~61~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~62~ & \verb~            return !(a == b);~\\
\cellcolor{green} & 4 & \verb~63~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~64~ & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        public static bool operator == (Language a, Language b)~\\
\cellcolor{green} & 7 & \verb~66~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~67~ & \verb~            // If both are null, or both are same instance, return true.~\\
\cellcolor{green} & 11 & \verb~68~ & \verb~            if (System.Object.ReferenceEquals (a, b)) {~\\
\cellcolor{green} & 4 & \verb~69~ & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~70~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & \verb~            // If one is null, but not both, return false.~\\
\cellcolor{green} & 6 & \verb~73~ & \verb~            if (((object)a == null) || ((object)b == null)) {~\\
\cellcolor{green} & 3 & \verb~74~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~75~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & \verb~            // Return true if the fields match:~\\
\cellcolor{red} & 0 & \verb~78~ & \verb~            return a.Code == b.Code;~\\
\cellcolor{green} & 7 & \verb~79~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        public bool Equals (Language other)~\\
\cellcolor{green} & 1 & \verb~82~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~83~ & \verb~            return other != null && Code == other.Code;~\\
\cellcolor{green} & 1 & \verb~84~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~85~ & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        public override bool Equals (object other)~\\
\cellcolor{green} & 1 & \verb~87~ & \verb~        {~\\
\cellcolor{green} & 1 & \verb~88~ & \verb~            if (other == null) {~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~90~ & \verb~            }~\\
\cellcolor{green} & 2 & \verb~91~ & \verb~            else if (other is Language) {~\\
\cellcolor{green} & 1 & \verb~92~ & \verb~                return Equals (other as Language);~\\
\cellcolor{gray} &  & \verb~93~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~            else {~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~                return false;~\\
\cellcolor{gray} &  & \verb~96~ & \verb~            }~\\
\cellcolor{green} & 1 & \verb~97~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & \verb~        public static implicit operator string (Language language)~\\
\cellcolor{green} & 3 & \verb~100~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~101~ & \verb~            return language.Code;~\\
\cellcolor{green} & 3 & \verb~102~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~103~ & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & \verb~        [ExcludeFromCodeCoverageAttribute]~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        public override int GetHashCode ()~\\
\cellcolor{gray} &  & \verb~106~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~107~ & \verb~            return Code.GetHashCode ();~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~110~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.LanguageOption}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.LanguageOption\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ocuments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash LanguageOption.cs}\end{minipage} \\
\textbf{Coverage:} & 76.9\%\\
\textbf{Covered lines:} & 30\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 39\\
\textbf{Total lines:} & 98\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{.ctor(...)} & 2 & 100 & 100\\
\hline
\textbf{toDisplayName(...)} & 5 & 100 & 85.71\\
\hline
\textbf{fromDisplayName(...)} & 5 & 0 & 0\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ocuments\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash LanguageOption.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    public class LanguageOption: DistinctOption~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~39~ & \verb~        public new Language Value~\\
\cellcolor{gray} &  & \verb~40~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~41~ & \verb~            get {~\\
\cellcolor{green} & 3 & \verb~42~ & \verb~                string code = base.Value;~\\
\cellcolor{green} & 15 & \verb~43~ & \verb~                foreach (Language lang in Localizer.ValidLanguages) {~\\
\cellcolor{green} & 6 & \verb~44~ & \verb~                    if (lang.Code == code) {~\\
\cellcolor{green} & 3 & \verb~45~ & \verb~                        return lang;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~47~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~48~ & \verb~                return Localizer.CurrentLanguage;~\\
\cellcolor{green} & 3 & \verb~49~ & \verb~            }~\\
\cellcolor{green} & 4 & \verb~50~ & \verb~            set {~\\
\cellcolor{green} & 4 & \verb~51~ & \verb~                base.Value = value.Code;~\\
\cellcolor{green} & 4 & \verb~52~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~54~ & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & \verb~        public override string DisplayValue~\\
\cellcolor{gray} &  & \verb~56~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~57~ & \verb~            get {~\\
\cellcolor{green} & 3 & \verb~58~ & \verb~                return toDisplayName (Value);~\\
\cellcolor{green} & 3 & \verb~59~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        public override Dictionary<string,string> DisplayValidValues~\\
\cellcolor{gray} &  & \verb~63~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~64~ & \verb~            get {~\\
\cellcolor{green} & 3 & \verb~65~ & \verb~                Dictionary<string, string> dict = new Dictionary<string, strin~\\
\cellcolor{green} & 36 & \verb~66~ & \verb~                foreach (string value in base.ValidValues) {~\\
\cellcolor{green} & 9 & \verb~67~ & \verb~                    dict [toDisplayName (value)] = value;~\\
\cellcolor{green} & 9 & \verb~68~ & \verb~                }~\\
\cellcolor{green} & 3 & \verb~69~ & \verb~                return dict;~\\
\cellcolor{green} & 3 & \verb~70~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~71~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & \verb~~\\
\cellcolor{green} & 4 & \verb~73~ & \verb~        public LanguageOption (string section, string name, ConfigFile configF~\\
\cellcolor{green} & 8 & \verb~74~ & \verb~        : base (section, name, Localizer.DefaultLanguageCode, from lang in Loc~\\
\cellcolor{green} & 4 & \verb~75~ & \verb~        {~\\
\cellcolor{green} & 4 & \verb~76~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        private string toDisplayName (string code)~\\
\cellcolor{green} & 12 & \verb~79~ & \verb~        {~\\
\cellcolor{green} & 81 & \verb~80~ & \verb~            foreach (Language lang in Localizer.ValidLanguages) {~\\
\cellcolor{green} & 27 & \verb~81~ & \verb~                if (lang.Code == code) {~\\
\cellcolor{green} & 9 & \verb~82~ & \verb~                    return lang.DisplayName;~\\
\cellcolor{gray} &  & \verb~83~ & \verb~                }~\\
\cellcolor{green} & 9 & \verb~84~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~85~ & \verb~            return Localizer.CurrentLanguage != null ? Localizer.CurrentLangua~\\
\cellcolor{green} & 12 & \verb~86~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~87~ & \verb~~\\
\cellcolor{gray} &  & \verb~88~ & \verb~        private string fromDisplayName (string displayName)~\\
\cellcolor{red} & 0 & \verb~89~ & \verb~        {~\\
\cellcolor{red} & 0 & \verb~90~ & \verb~            foreach (Language lang in Localizer.ValidLanguages) {~\\
\cellcolor{red} & 0 & \verb~91~ & \verb~                if (lang.DisplayName == displayName) {~\\
\cellcolor{red} & 0 & \verb~92~ & \verb~                    return lang.Code;~\\
\cellcolor{gray} &  & \verb~93~ & \verb~                }~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~            }~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~            return Localizer.CurrentLanguage != null ? Localizer.CurrentLangua~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~97~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~98~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.Localizer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.Localizer\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Localizer.cs}\end{minipage} \\
\textbf{Coverage:} & 87.5\%\\
\textbf{Covered lines:} & 49\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 56\\
\textbf{Total lines:} & 143\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|l|l|l|}
\hline
\textbf{Method} & \textbf{Cyclomatic Complexity} & \textbf{Sequence Coverage} & \textbf{Branch Coverage}\\
\hline
\textbf{Localize(...)} & 9 & 85.19 & 76.47\\
\hline
\textbf{ToUnicode(...)} & 1 & 100 & 100\\
\hline
\textbf{.cctor()} & 1 & 100 & 100\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{cal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Localizer.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~35~ & \verb~using System.Linq;~\\
\cellcolor{gray} &  & \verb~36~ & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~38~ & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~40~ & \verb~{~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~42~ & \verb~    /// Eine statische Klasse, die Bezeichner in lokalisierten Text umsetzen k~\\
\cellcolor{gray} &  & \verb~43~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~44~ & \verb~    public static class Localizer~\\
\cellcolor{gray} &  & \verb~45~ & \verb~    {~\\
\cellcolor{green} & 1 & \verb~46~ & \verb~        public static readonly string DefaultLanguageCode = "en";~\\
\cellcolor{gray} &  & \verb~47~ & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// Gibt die zur Zeit in der zentralen Konfigurationsdatei eingestellt~\\
\cellcolor{gray} &  & \verb~50~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~51~ & \verb~        private static Option CurrentLanguageCode~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        {~\\
\cellcolor{green} & 10 & \verb~53~ & \verb~            get {~\\
\cellcolor{green} & 11 & \verb~54~ & \verb~                if (_currentLanguageCode == null) {~\\
\cellcolor{green} & 1 & \verb~55~ & \verb~                    _currentLanguageCode = new Option ("language", "current", ~\\
\cellcolor{gray} &  & \verb~56~ & \verb~                    { Verbose = false };~\\
\cellcolor{green} & 1 & \verb~57~ & \verb~                }~\\
\cellcolor{green} & 10 & \verb~58~ & \verb~                return _currentLanguageCode;~\\
\cellcolor{green} & 10 & \verb~59~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~60~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{gray} &  & \verb~62~ & \verb~        private static Option _currentLanguageCode;~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        /// Die aktuell geladene Sprache.~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// </summary>~\\
\cellcolor{green} & 15 & \verb~67~ & \verb~        public static Language CurrentLanguage { get; private set; }~\\
\cellcolor{gray} &  & \verb~68~ & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & \verb~        public static string LanguageDirectory~\\
\cellcolor{gray} &  & \verb~70~ & \verb~        {~\\
\cellcolor{green} & 29 & \verb~71~ & \verb~            get {~\\
\cellcolor{green} & 29 & \verb~72~ & \verb~                string directory = SystemInfo.RelativeContentDirectory + "Lang~\\
\cellcolor{green} & 29 & \verb~73~ & \verb~                Directory.CreateDirectory (directory);~\\
\cellcolor{green} & 29 & \verb~74~ & \verb~                return directory;~\\
\cellcolor{green} & 29 & \verb~75~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~76~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~77~ & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & \verb~        private static Language[] _validLanguages;~\\
\cellcolor{gray} &  & \verb~79~ & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & \verb~        public static Language[] ValidLanguages~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        {~\\
\cellcolor{green} & 21 & \verb~82~ & \verb~            get {~\\
\cellcolor{green} & 39 & \verb~83~ & \verb~                if (_validLanguages != null) {~\\
\cellcolor{green} & 18 & \verb~84~ & \verb~                    return _validLanguages;~\\
\cellcolor{gray} &  & \verb~85~ & \verb~                }~\\
\cellcolor{green} & 3 & \verb~86~ & \verb~                else {~\\
\cellcolor{green} & 3 & \verb~87~ & \verb~                    string[] files = Directory.GetFiles (LanguageDirectory);~\\
\cellcolor{green} & 3 & \verb~88~ & \verb~                    List<Language> languages = new List<Language> ();~\\
\cellcolor{green} & 33 & \verb~89~ & \verb~                    foreach (string file in files) {~\\
\cellcolor{green} & 8 & \verb~90~ & \verb~                        try {~\\
\cellcolor{green} & 8 & \verb~91~ & \verb~                            Log.Debug ("Language file: ", file);~\\
\cellcolor{green} & 8 & \verb~92~ & \verb~                            languages.Add (new Language (file: file));~\\
\cellcolor{green} & 8 & \verb~93~ & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~94~ & \verb~                        catch (Exception ex) {~\\
\cellcolor{red} & 0 & \verb~95~ & \verb~                            Log.Error (ex);~\\
\cellcolor{red} & 0 & \verb~96~ & \verb~                        }~\\
\cellcolor{green} & 8 & \verb~97~ & \verb~                    }~\\
\cellcolor{green} & 3 & \verb~98~ & \verb~                    if (languages.Count == 0) {~\\
\cellcolor{red} & 0 & \verb~99~ & \verb~                        languages.Add (new Language (file: LanguageDirectory +~\\
\cellcolor{red} & 0 & \verb~100~ & \verb~                    }~\\
\cellcolor{green} & 11 & \verb~101~ & \verb~                    Log.Message ("Valid Languages: " + string.Join (", ", from~\\
\cellcolor{green} & 3 & \verb~102~ & \verb~                    return _validLanguages = languages.ToArray ();~\\
\cellcolor{gray} &  & \verb~103~ & \verb~                }~\\
\cellcolor{green} & 21 & \verb~104~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~105~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~108~ & \verb~        /// Liefert zu dem übergebenen Bezeichner den zugehörigen Text aus der~\\
\cellcolor{gray} &  & \verb~109~ & \verb~        /// aktuellen Sprache zurück, die dabei aus der Einstellungsdatei des ~\\
\cellcolor{gray} &  & \verb~110~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~111~ & \verb~        public static string Localize (this string text)~\\
\cellcolor{green} & 3 & \verb~112~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~113~ & \verb~            if (text == null) {~\\
\cellcolor{red} & 0 & \verb~114~ & \verb~                return "";~\\
\cellcolor{gray} &  & \verb~115~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~116~ & \verb~            else if (text == string.Empty || text.Contains ("Exception") || te~\\
\cellcolor{red} & 0 & \verb~117~ & \verb~                return text;~\\
\cellcolor{gray} &  & \verb~118~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~119~ & \verb~            else {~\\
\cellcolor{green} & 5 & \verb~120~ & \verb~                if (CurrentLanguage == null || CurrentLanguage.Code != Current~\\
\cellcolor{green} & 2 & \verb~121~ & \verb~                    _validLanguages = null;~\\
\cellcolor{green} & 24 & \verb~122~ & \verb~                    foreach (Language lang in ValidLanguages) {~\\
\cellcolor{green} & 8 & \verb~123~ & \verb~                        if (lang.Code == CurrentLanguageCode.Value) {~\\
\cellcolor{green} & 2 & \verb~124~ & \verb~                            CurrentLanguage = lang;~\\
\cellcolor{green} & 2 & \verb~125~ & \verb~                        }~\\
\cellcolor{green} & 6 & \verb~126~ & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~127~ & \verb~                    CurrentLanguageCode.Value = CurrentLanguage.Code;~\\
\cellcolor{green} & 2 & \verb~128~ & \verb~                }~\\
\cellcolor{gray} &  & \verb~129~ & \verb~~\\
\cellcolor{green} & 3 & \verb~130~ & \verb~                string trimmed = text.Trim ('\r', '\n', ' ', '\t', ':', '!', '~\\
\cellcolor{green} & 3 & \verb~131~ & \verb~                string localized = CurrentLanguage.Localization ["text", trimm~\\
\cellcolor{green} & 3 & \verb~132~ & \verb~                return ToUnicode (text.Replace (trimmed, localized));~\\
\cellcolor{gray} &  & \verb~133~ & \verb~            }~\\
\cellcolor{green} & 3 & \verb~134~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~135~ & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & \verb~        public static string ToUnicode (string text)~\\
\cellcolor{green} & 3 & \verb~137~ & \verb~        {~\\
\cellcolor{green} & 3 & \verb~138~ & \verb~            return text.Replace ("&auml;", "\u00E4").Replace ("&ouml;", "\u00F~\\
\cellcolor{gray} &  & \verb~139~ & \verb~                   .Replace ("&Auml;", "\u00C4").Replace ("&Ouml;", "\u00D6").~\\
\cellcolor{gray} &  & \verb~140~ & \verb~                   .Replace ("&szlig;", "\u00DF");~\\
\cellcolor{green} & 3 & \verb~141~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~142~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~143~ & \verb~}~\\
\end{longtable}
\newpage
\section{Knot3.Framework.Storage.Option}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Knot3.Framework.Storage.Option\\
\textbf{Assembly:} & Knot3.Framework\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Option.cs}\end{minipage} \\
\textbf{Coverage:} & 100\%\\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 14\\
\textbf{Total lines:} & 94\\
\end{longtable}
\subsection{File(s)}
\subsubsection{Pascal\textbackslash Documents\textbackslash GitHub\textbackslash knot3-code\textbackslash framework\textbackslash Knot3.Framework\textbackslash Storage\textbackslash Option.cs}
\begin{longtable}[l]{lrrl}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{Coverage}\\
\cellcolor{gray} &  & \verb~1~ & \verb~/*~\\
\cellcolor{gray} &  & \verb~2~ & \verb~ * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,~\\
\cellcolor{gray} &  & \verb~3~ & \verb~ *                         Gerd Augsburg, Christina Erler, Daniel Warzel~\\
\cellcolor{gray} &  & \verb~4~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~5~ & \verb~ * This source code file is part of Knot3. Copying, redistribution and~\\
\cellcolor{gray} &  & \verb~6~ & \verb~ * use of the source code in this file in source and binary forms,~\\
\cellcolor{gray} &  & \verb~7~ & \verb~ * with or without modification, are permitted provided that the conditions~\\
\cellcolor{gray} &  & \verb~8~ & \verb~ * of the MIT license are met:~\\
\cellcolor{gray} &  & \verb~9~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~10~ & \verb~ *   Permission is hereby granted, free of charge, to any person obtaining a c~\\
\cellcolor{gray} &  & \verb~11~ & \verb~ *   of this software and associated documentation files (the "Software"), to ~\\
\cellcolor{gray} &  & \verb~12~ & \verb~ *   in the Software without restriction, including without limitation the rig~\\
\cellcolor{gray} &  & \verb~13~ & \verb~ *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell~\\
\cellcolor{gray} &  & \verb~14~ & \verb~ *   copies of the Software, and to permit persons to whom the Software is~\\
\cellcolor{gray} &  & \verb~15~ & \verb~ *   furnished to do so, subject to the following conditions:~\\
\cellcolor{gray} &  & \verb~16~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~17~ & \verb~ *   The above copyright notice and this permission notice shall be included i~\\
\cellcolor{gray} &  & \verb~18~ & \verb~ *   copies or substantial portions of the Software.~\\
\cellcolor{gray} &  & \verb~19~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~20~ & \verb~ *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS O~\\
\cellcolor{gray} &  & \verb~21~ & \verb~ *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,~\\
\cellcolor{gray} &  & \verb~22~ & \verb~ *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL T~\\
\cellcolor{gray} &  & \verb~23~ & \verb~ *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER~\\
\cellcolor{gray} &  & \verb~24~ & \verb~ *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING F~\\
\cellcolor{gray} &  & \verb~25~ & \verb~ *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN~\\
\cellcolor{gray} &  & \verb~26~ & \verb~ *   SOFTWARE.~\\
\cellcolor{gray} &  & \verb~27~ & \verb~ *~\\
\cellcolor{gray} &  & \verb~28~ & \verb~ * See the LICENSE file for full license details of the Knot3 project.~\\
\cellcolor{gray} &  & \verb~29~ & \verb~ */~\\
\cellcolor{gray} &  & \verb~30~ & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & \verb~using System.Diagnostics.CodeAnalysis;~\\
\cellcolor{gray} &  & \verb~32~ & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & \verb~using Knot3.Framework.Platform;~\\
\cellcolor{gray} &  & \verb~34~ & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & \verb~namespace Knot3.Framework.Storage~\\
\cellcolor{gray} &  & \verb~36~ & \verb~{~\\
\cellcolor{gray} &  & \verb~37~ & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & \verb~    /// Enthält Informationen über einen Eintrag in einer Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~39~ & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~40~ & \verb~    public class Option~\\
\cellcolor{gray} &  & \verb~41~ & \verb~    {~\\
\cellcolor{gray} &  & \verb~42~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & \verb~        /// Die Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~44~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~45~ & \verb~        private ConfigFile ConfigFile;~\\
\cellcolor{gray} &  & \verb~46~ & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & \verb~        /// Der Abschnitt der Einstellungsdatei.~\\
\cellcolor{gray} &  & \verb~49~ & \verb~        /// </summary>~\\
\cellcolor{green} & 130 & \verb~50~ & \verb~        public string Section { get; private set; }~\\
\cellcolor{gray} &  & \verb~51~ & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~53~ & \verb~        /// Der Name der Option.~\\
\cellcolor{gray} &  & \verb~54~ & \verb~        /// </summary>~\\
\cellcolor{green} & 130 & \verb~55~ & \verb~        public string Name { get; private set; }~\\
\cellcolor{gray} &  & \verb~56~ & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~58~ & \verb~        /// Der Standardwert der Option.~\\
\cellcolor{gray} &  & \verb~59~ & \verb~        /// </summary>~\\
\cellcolor{green} & 91 & \verb~60~ & \verb~        public string DefaultValue { get; private set; }~\\
\cellcolor{gray} &  & \verb~61~ & \verb~~\\
\cellcolor{green} & 45 & \verb~62~ & \verb~        public bool Verbose { get; set; }~\\
\cellcolor{gray} &  & \verb~63~ & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & \verb~        /// Der Wert der Option.~\\
\cellcolor{gray} &  & \verb~66~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~67~ & \verb~        public virtual string Value~\\
\cellcolor{gray} &  & \verb~68~ & \verb~        {~\\
\cellcolor{green} & 36 & \verb~69~ & \verb~            get {~\\
\cellcolor{green} & 64 & \verb~70~ & \verb~                if (Verbose) {~\\
\cellcolor{green} & 28 & \verb~71~ & \verb~                    Log.Debug ("Option: ", Section, ".", Name, " => ", ConfigF~\\
\cellcolor{green} & 28 & \verb~72~ & \verb~                }~\\
\cellcolor{green} & 36 & \verb~73~ & \verb~                return ConfigFile [Section, Name, DefaultValue];~\\
\cellcolor{green} & 36 & \verb~74~ & \verb~            }~\\
\cellcolor{green} & 15 & \verb~75~ & \verb~            set {~\\
\cellcolor{green} & 15 & \verb~76~ & \verb~                Log.Debug ("Option: ", Section, ".", Name, " <= ", value);~\\
\cellcolor{green} & 15 & \verb~77~ & \verb~                ConfigFile [Section, Name, DefaultValue] = value;~\\
\cellcolor{green} & 15 & \verb~78~ & \verb~            }~\\
\cellcolor{gray} &  & \verb~79~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~80~ & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & \verb~        /// Erstellt ein neues OptionsInfo-Objekt aus den übergegebenen Werten~\\
\cellcolor{gray} &  & \verb~83~ & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~84~ & \verb~        [ExcludeFromCodeCoverage]~\\
\cellcolor{gray} &  & \verb~85~ & \verb~        public Option (string section, string name, string defaultValue, Confi~\\
\cellcolor{gray} &  & \verb~86~ & \verb~        {~\\
\cellcolor{gray} &  & \verb~87~ & \verb~            Section = section;~\\
\cellcolor{gray} &  & \verb~88~ & \verb~            Name = name;~\\
\cellcolor{gray} &  & \verb~89~ & \verb~            DefaultValue = defaultValue;~\\
\cellcolor{gray} &  & \verb~90~ & \verb~            ConfigFile = configFile != null ? configFile : Config.Default;~\\
\cellcolor{gray} &  & \verb~91~ & \verb~            Verbose = true;~\\
\cellcolor{gray} &  & \verb~92~ & \verb~        }~\\
\cellcolor{gray} &  & \verb~93~ & \verb~    }~\\
\cellcolor{gray} &  & \verb~94~ & \verb~}~\\
\end{longtable}
\end{document}