% !TeX encoding = UTF-8
%



\chapter{Schluss}
\label{Kapitel:Abschluss}

~\\



\section{Bewertung}
\label{Abschnitt:Abschluss:Bewertung}

Die Qualität des Spiels Knot3 ist verbessert worden. Durch eine Komponententestabdeckung von über 80 \% und Funktionstests für alle elementaren Spielfunktionen ist jetzt die einwandfreie Funktion von Knot3 gewährleistet.\\

Alle Grundfunktionen sind getestet und funktionieren zuverlässig. Bei der Abnahme in Spielbarkeitstests durch menschliche Testspieler hat sich gezeigt, dass unser Produkt, wenn auch nicht perfekt, für eine interessante Spielerfahrung geeignet und für den Einsatz bereit ist.\\

In den Negativtests sichern wir das Programm weiter ab. Das Spiel ist so robust gegen die wahrscheinlichsten Störfälle. Die Algorithmen für die Knotentransformationen erfüllen ihre Aufgaben und es ist nicht möglich ungültige Knoten zu erzeugen (NT\_10, NT\_30, Komponententests). Die Robustheit wird zudem in Extremtests bei der Verarbeitung großer Datenmengen sichergestellt, so dass es bei realitätsnahen Knotengrößen mit um die 1000 Kanten zu keinen Problemen kommt (ET\_1). Erst bei 5000 Kanten verringert sich die Spielgeschwindigkeit gravierend. Die Hardware der Testsysteme ist schon etwas älter. D.h. Knot3 läuft auf allen gängigen Systemen. Des weiteren ist durch Tests überprüft worden, dass bei nicht zugewiesenen Eingaben kein Fehlverhalten auftritt (NT\_50). Der Spieler wird während dem gesamten Spiel dadurch unterstützt, dass wir ungültige Aktionen nicht zulassen.\\

Selbst bei Systemfehlern oder unerwarteten Fehlern geben wir einen Hinweis in Form einer Textmeldung an den Spieler. Diese Nachrichten sind im Nachhinein verwendbar, falls wir trotz allem etwas übersehen haben sollten, um den Fehler schnell zu finden und eine Aktualisierung bereit zu stellen.\\

Ein weiterer Punkt, der für die Funktionstüchtigkeit spricht ist die Verwendung von automatischen Test- und Fehleranalyse-Werkzeugen. Gendarme hat mit zu einer besseren Code-Qualität beigetragen und insgesamt auf mehr als 1000 Probleme hingewiesen. 75 \% davon haben wir korrigiert. Darunter befanden sich auch zahlreiche kleinere Verbesserungen der Performance. Die restlichen 25 \% sind nicht weiter schlimm. Denn Gendarme zeigt neben ernstzunehmenden Problemen oft kleinere syntaktische Feinheiten an. Wir nutzten diese Zeit besser für die Lösung der Probleme die wir bei unserer eigenen Fehlersuche gefunden haben. Dabei sind wir sehr präzise vorgegangen, unterstützt durch das Issuesystem von GitHub, Screencapturing, das parallele Schreiben der Komponententests und Berichten von Spieletestern, wobei wir selbst häufig zum Testen gespielt haben. Zudem haben wir Testknoten zu grundlegenden Knotenarchitekturen erstellt und deren Bau überprüft. In einem Spiel kommen genau diese in einem großen Knoten wiederholt vor. Wir erhoffen uns durch die zusätzliche, einmalige Überprüfung der Spielsituationen, dass die nötigen Transformationen auch in komplexeren Fällen durchführbar sind. Testspieler konnten diese Knoten fehlerfrei aufbauen und abbauen.\\

Ein weiteres Kriterium für die Qualität von Knot3 ist die hohe Portabilität des Spiels. Durch die Verwendung von MonoGame-SDL2 statt XNA lässt sich Knot3 auf alle Plattformen portieren, die von SDL2 unterstützt werden. Im wesentlichen sind das die drei wichtigen Desktop-Plattformen (Windows, Linux, Mac OS X).\\

Um den Anteil an plattformspezifischem Code zu minimieren, werden so weit es geht externe Programmbibliotheken genutzt und Abstraktionsklassen verwendet. Die Qualität des Codes wird auch dadurch deutlich, dass der Code des Spiels nicht nur mit MonoGame-SDL2 kompatibel ist, das auf aktueller freier Software aufbaut, sondern ein Großteil der Funktionalität auch noch mit der nicht mehr weiterentwickelten Implementierung der XNA-API von Microsoft verwendet werden kann.\\

Knot3 wurde von Anfang an parallel zur Entwicklung mit XNA/Visual Studio mit MonoGame und MonoDevelop/Xamarin Studio entwickelt. Das Entwickeln und Testen mit beiden Implementierungen der XNA-API hat uns die Stärken und Schwächen beider Implementierungen vor Augen geführt und wesentlich dazu beigetragen, dass wir Bugs in unserem Code gefunden haben, die wir bei der Entwicklung nur für eine Implementierung oder nur für Plattform übersehen hätten.\\

Besonders hilfreich war auch die Möglichkeit, sich die interne Implementierung diverser Klassen und Methoden in dem quelloffenen MonoGame-SDL2 ansehen zu können, da die Dokumentation von XNA 4.0 von Microsoft gerade bei komplizierten Themen wie der Nutzung von Shadern, Hardware Instancing relativ schlecht und spärlich ist. Auch haben sich die Autoren von MonoGame-SDL2 als sehr hilfreich erwiesen, wenn wir auf Bugs oder Unterschiede zwischen MonoGame und XNA gestoßen sind. \\
Gleichzeitig hat uns dies auch die Grenzen von XNA 4.0 vor Augen geführt, da in einer offiziell eingestellten prorietären Library keine Bugs mehr korrigiert werden können und ein tieferes Verständnis von den internen Abläufen in XNA notwendig war, um diese Bugs umgehen zu können. Dies hat dann auch zu einer ausgereifteren Verwendung der XNA-API geführt, als wenn wir nur der offiziellen Dokumentation gefolgt wären, die diverse Probleme (etwa mit dem Anti-Aliasing oder der Shader-Unterstützung) nicht erwähnt oder die Entwickler im Glauben lässt, bestimmte Teile der API von XNA 4.0 würden zuverlässiger funktionieren (Probleme mit dem Setzen/Abfragen der Maus-Position und reagieren auf Eingaben in anderen Fenstern).\\







